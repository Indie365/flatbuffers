// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


class EnumWithReservedNames {
  final int value;
  const EnumWithReservedNames._(this.value);

  factory EnumWithReservedNames.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum EnumWithReservedNames');
    }
    return result;
  }

  static EnumWithReservedNames? _createOrNull(int? value) => 
      value == null ? null : EnumWithReservedNames.fromValue(value);

  static const int minValue = 1;
  static const int maxValue = 4;
  static bool containsValue(int value) => values.containsKey(value);

  static const EnumWithReservedNames $value = EnumWithReservedNames._(1);
  static const EnumWithReservedNames $values = EnumWithReservedNames._(2);
  static const EnumWithReservedNames $minValue = EnumWithReservedNames._(3);
  static const EnumWithReservedNames $maxValue = EnumWithReservedNames._(4);
  static const Map<int, EnumWithReservedNames> values = {
    1: $value,
    2: $values,
    3: $minValue,
    4: $maxValue};

  static const fb.Reader<EnumWithReservedNames> reader = _EnumWithReservedNamesReader();

  @override
  String toString() {
    return 'EnumWithReservedNames{value: $value}';
  }
}

class _EnumWithReservedNamesReader extends fb.Reader<EnumWithReservedNames> {
  const _EnumWithReservedNamesReader();

  @override
  int get size => 4;

  @override
  EnumWithReservedNames read(fb.BufferContext bc, int offset) =>
      EnumWithReservedNames.fromValue(const fb.Uint32Reader().read(bc, offset));
}

