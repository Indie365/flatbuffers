// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: multinamespaces
#ifndef GRPC_multinamespaces__INCLUDED
#define GRPC_multinamespaces__INCLUDED

#include "multinamespaces_generated.h"
#include "flatbuffers/grpc.h"

#include <grpc++/impl/codegen/async_stream.h>
#include <grpc++/impl/codegen/async_unary_call.h>
#include <grpc++/impl/codegen/method_handler_impl.h>
#include <grpc++/impl/codegen/proto_utils.h>
#include <grpc++/impl/codegen/rpc_method.h>
#include <grpc++/impl/codegen/service_type.h>
#include <grpc++/impl/codegen/status.h>
#include <grpc++/impl/codegen/stub_options.h>
#include <grpc++/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace a {

class ServiceAB final {
 public:
  static constexpr char const* service_full_name() {
    return "a.ServiceAB";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status MethodAA(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, flatbuffers::grpc::Message<A>* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<A>>> AsyncMethodAA(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<A>>>(AsyncMethodAARaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<A>>> PrepareAsyncMethodAA(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<A>>>(PrepareAsyncMethodAARaw(context, request, cq));
    }
    virtual ::grpc::Status MethodAB(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, flatbuffers::grpc::Message<b::B>* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<b::B>>> AsyncMethodAB(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<b::B>>>(AsyncMethodABRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<b::B>>> PrepareAsyncMethodAB(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<b::B>>>(PrepareAsyncMethodABRaw(context, request, cq));
    }
    virtual ::grpc::Status MethodBA(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, flatbuffers::grpc::Message<A>* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<A>>> AsyncMethodBA(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<A>>>(AsyncMethodBARaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<A>>> PrepareAsyncMethodBA(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<A>>>(PrepareAsyncMethodBARaw(context, request, cq));
    }
    virtual ::grpc::Status MethodBB(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, flatbuffers::grpc::Message<b::B>* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<b::B>>> AsyncMethodBB(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<b::B>>>(AsyncMethodBBRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<b::B>>> PrepareAsyncMethodBB(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<b::B>>>(PrepareAsyncMethodBBRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<A>>* AsyncMethodAARaw(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<A>>* PrepareAsyncMethodAARaw(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<b::B>>* AsyncMethodABRaw(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<b::B>>* PrepareAsyncMethodABRaw(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<A>>* AsyncMethodBARaw(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<A>>* PrepareAsyncMethodBARaw(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<b::B>>* AsyncMethodBBRaw(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< flatbuffers::grpc::Message<b::B>>* PrepareAsyncMethodBBRaw(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status MethodAA(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, flatbuffers::grpc::Message<A>* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<A>>> AsyncMethodAA(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<A>>>(AsyncMethodAARaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<A>>> PrepareAsyncMethodAA(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<A>>>(PrepareAsyncMethodAARaw(context, request, cq));
    }
    ::grpc::Status MethodAB(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, flatbuffers::grpc::Message<b::B>* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<b::B>>> AsyncMethodAB(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<b::B>>>(AsyncMethodABRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<b::B>>> PrepareAsyncMethodAB(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<b::B>>>(PrepareAsyncMethodABRaw(context, request, cq));
    }
    ::grpc::Status MethodBA(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, flatbuffers::grpc::Message<A>* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<A>>> AsyncMethodBA(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<A>>>(AsyncMethodBARaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<A>>> PrepareAsyncMethodBA(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<A>>>(PrepareAsyncMethodBARaw(context, request, cq));
    }
    ::grpc::Status MethodBB(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, flatbuffers::grpc::Message<b::B>* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<b::B>>> AsyncMethodBB(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<b::B>>>(AsyncMethodBBRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<b::B>>> PrepareAsyncMethodBB(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<b::B>>>(PrepareAsyncMethodBBRaw(context, request, cq));
    }
  
   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<A>>* AsyncMethodAARaw(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<A>>* PrepareAsyncMethodAARaw(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<b::B>>* AsyncMethodABRaw(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<b::B>>* PrepareAsyncMethodABRaw(::grpc::ClientContext* context, const flatbuffers::grpc::Message<A>& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<A>>* AsyncMethodBARaw(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<A>>* PrepareAsyncMethodBARaw(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<b::B>>* AsyncMethodBBRaw(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< flatbuffers::grpc::Message<b::B>>* PrepareAsyncMethodBBRaw(::grpc::ClientContext* context, const flatbuffers::grpc::Message<b::B>& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_MethodAA_;
    const ::grpc::internal::RpcMethod rpcmethod_MethodAB_;
    const ::grpc::internal::RpcMethod rpcmethod_MethodBA_;
    const ::grpc::internal::RpcMethod rpcmethod_MethodBB_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
  
  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status MethodAA(::grpc::ServerContext* context, const flatbuffers::grpc::Message<A>* request, flatbuffers::grpc::Message<A>* response);
    virtual ::grpc::Status MethodAB(::grpc::ServerContext* context, const flatbuffers::grpc::Message<A>* request, flatbuffers::grpc::Message<b::B>* response);
    virtual ::grpc::Status MethodBA(::grpc::ServerContext* context, const flatbuffers::grpc::Message<b::B>* request, flatbuffers::grpc::Message<A>* response);
    virtual ::grpc::Status MethodBB(::grpc::ServerContext* context, const flatbuffers::grpc::Message<b::B>* request, flatbuffers::grpc::Message<b::B>* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_MethodAA : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_MethodAA() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_MethodAA() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MethodAA(::grpc::ServerContext* context, const flatbuffers::grpc::Message<A>* request, flatbuffers::grpc::Message<A>* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMethodAA(::grpc::ServerContext* context, flatbuffers::grpc::Message<A>* request, ::grpc::ServerAsyncResponseWriter< flatbuffers::grpc::Message<A>>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MethodAB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_MethodAB() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_MethodAB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MethodAB(::grpc::ServerContext* context, const flatbuffers::grpc::Message<A>* request, flatbuffers::grpc::Message<b::B>* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMethodAB(::grpc::ServerContext* context, flatbuffers::grpc::Message<A>* request, ::grpc::ServerAsyncResponseWriter< flatbuffers::grpc::Message<b::B>>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MethodBA : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_MethodBA() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_MethodBA() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MethodBA(::grpc::ServerContext* context, const flatbuffers::grpc::Message<b::B>* request, flatbuffers::grpc::Message<A>* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMethodBA(::grpc::ServerContext* context, flatbuffers::grpc::Message<b::B>* request, ::grpc::ServerAsyncResponseWriter< flatbuffers::grpc::Message<A>>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MethodBB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_MethodBB() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_MethodBB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MethodBB(::grpc::ServerContext* context, const flatbuffers::grpc::Message<b::B>* request, flatbuffers::grpc::Message<b::B>* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMethodBB(::grpc::ServerContext* context, flatbuffers::grpc::Message<b::B>* request, ::grpc::ServerAsyncResponseWriter< flatbuffers::grpc::Message<b::B>>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef   WithAsyncMethod_MethodAA<  WithAsyncMethod_MethodAB<  WithAsyncMethod_MethodBA<  WithAsyncMethod_MethodBB<  Service   >   >   >   >   AsyncService;
  template <class BaseClass>
  class WithGenericMethod_MethodAA : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_MethodAA() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_MethodAA() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MethodAA(::grpc::ServerContext* context, const flatbuffers::grpc::Message<A>* request, flatbuffers::grpc::Message<A>* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MethodAB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_MethodAB() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_MethodAB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MethodAB(::grpc::ServerContext* context, const flatbuffers::grpc::Message<A>* request, flatbuffers::grpc::Message<b::B>* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MethodBA : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_MethodBA() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_MethodBA() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MethodBA(::grpc::ServerContext* context, const flatbuffers::grpc::Message<b::B>* request, flatbuffers::grpc::Message<A>* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MethodBB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_MethodBB() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_MethodBB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MethodBB(::grpc::ServerContext* context, const flatbuffers::grpc::Message<b::B>* request, flatbuffers::grpc::Message<b::B>* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MethodAA : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_MethodAA() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< flatbuffers::grpc::Message<A>, flatbuffers::grpc::Message<A>>(std::bind(&WithStreamedUnaryMethod_MethodAA<BaseClass>::StreamedMethodAA, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_MethodAA() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MethodAA(::grpc::ServerContext* context, const flatbuffers::grpc::Message<A>* request, flatbuffers::grpc::Message<A>* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMethodAA(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< flatbuffers::grpc::Message<A>,flatbuffers::grpc::Message<A>>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MethodAB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_MethodAB() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< flatbuffers::grpc::Message<A>, flatbuffers::grpc::Message<b::B>>(std::bind(&WithStreamedUnaryMethod_MethodAB<BaseClass>::StreamedMethodAB, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_MethodAB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MethodAB(::grpc::ServerContext* context, const flatbuffers::grpc::Message<A>* request, flatbuffers::grpc::Message<b::B>* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMethodAB(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< flatbuffers::grpc::Message<A>,flatbuffers::grpc::Message<b::B>>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MethodBA : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_MethodBA() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< flatbuffers::grpc::Message<b::B>, flatbuffers::grpc::Message<A>>(std::bind(&WithStreamedUnaryMethod_MethodBA<BaseClass>::StreamedMethodBA, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_MethodBA() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MethodBA(::grpc::ServerContext* context, const flatbuffers::grpc::Message<b::B>* request, flatbuffers::grpc::Message<A>* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMethodBA(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< flatbuffers::grpc::Message<b::B>,flatbuffers::grpc::Message<A>>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MethodBB : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_MethodBB() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< flatbuffers::grpc::Message<b::B>, flatbuffers::grpc::Message<b::B>>(std::bind(&WithStreamedUnaryMethod_MethodBB<BaseClass>::StreamedMethodBB, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_MethodBB() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MethodBB(::grpc::ServerContext* context, const flatbuffers::grpc::Message<b::B>* request, flatbuffers::grpc::Message<b::B>* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMethodBB(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< flatbuffers::grpc::Message<b::B>,flatbuffers::grpc::Message<b::B>>* server_unary_streamer) = 0;
  };
  typedef   WithStreamedUnaryMethod_MethodAA<  WithStreamedUnaryMethod_MethodAB<  WithStreamedUnaryMethod_MethodBA<  WithStreamedUnaryMethod_MethodBB<  Service   >   >   >   >   StreamedUnaryService;
  typedef   Service   SplitStreamedService;
  typedef   WithStreamedUnaryMethod_MethodAA<  WithStreamedUnaryMethod_MethodAB<  WithStreamedUnaryMethod_MethodBA<  WithStreamedUnaryMethod_MethodBB<  Service   >   >   >   >   StreamedService;
};

}  // namespace a


#endif  // GRPC_multinamespaces__INCLUDED
