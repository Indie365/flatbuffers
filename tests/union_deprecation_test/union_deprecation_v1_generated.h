// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_UNIONDEPRECATIONV1_UNIONDEPRECATION_V1_H_
#define FLATBUFFERS_GENERATED_UNIONDEPRECATIONV1_UNIONDEPRECATION_V1_H_

#include "flatbuffers/flatbuffers.h"

namespace UnionDeprecation {
namespace V1 {

struct TableA;
struct TableABuilder;

struct TableB;
struct TableBBuilder;

struct Root;
struct RootBuilder;

enum Union {
  Union_NONE = 0,
  Union_TableA = 1,
  Union_TableB = 2,
  Union_MIN = Union_NONE,
  Union_MAX = Union_TableB
};

inline const Union (&EnumValuesUnion())[3] {
  static const Union values[] = {
    Union_NONE,
    Union_TableA,
    Union_TableB
  };
  return values;
}

inline const char * const *EnumNamesUnion() {
  static const char * const names[4] = {
    "NONE",
    "TableA",
    "TableB",
    nullptr
  };
  return names;
}

inline const char *EnumNameUnion(Union e) {
  if (flatbuffers::IsOutRange(e, Union_NONE, Union_TableB)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUnion()[index];
}

template<typename T> struct UnionTraits {
  static const Union enum_value = Union_NONE;
};

template<> struct UnionTraits<UnionDeprecation::V1::TableA> {
  static const Union enum_value = Union_TableA;
};

template<> struct UnionTraits<UnionDeprecation::V1::TableB> {
  static const Union enum_value = Union_TableB;
};

bool VerifyUnion(flatbuffers::Verifier &verifier, const void *obj, Union type);
bool VerifyUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct TableA FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableABuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4,
    VT_B = 6
  };
  float a() const {
    return GetField<float>(VT_A, 0.0f);
  }
  int32_t b() const {
    return GetField<int32_t>(VT_B, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_A) &&
           VerifyField<int32_t>(verifier, VT_B) &&
           verifier.EndTable();
  }
};

struct TableABuilder {
  typedef TableA Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_a(float a) {
    fbb_.AddElement<float>(TableA::VT_A, a, 0.0f);
  }
  void add_b(int32_t b) {
    fbb_.AddElement<int32_t>(TableA::VT_B, b, 0);
  }
  explicit TableABuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TableA> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableA>(end);
    return o;
  }
};

inline flatbuffers::Offset<TableA> CreateTableA(
    flatbuffers::FlatBufferBuilder &_fbb,
    float a = 0.0f,
    int32_t b = 0) {
  TableABuilder builder_(_fbb);
  builder_.add_b(b);
  builder_.add_a(a);
  return builder_.Finish();
}

struct TableB FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4
  };
  int32_t a() const {
    return GetField<int32_t>(VT_A, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_A) &&
           verifier.EndTable();
  }
};

struct TableBBuilder {
  typedef TableB Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_a(int32_t a) {
    fbb_.AddElement<int32_t>(TableB::VT_A, a, 0);
  }
  explicit TableBBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TableB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableB>(end);
    return o;
  }
};

inline flatbuffers::Offset<TableB> CreateTableB(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t a = 0) {
  TableBBuilder builder_(_fbb);
  builder_.add_a(a);
  return builder_.Finish();
}

struct Root FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RootBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4,
    VT_B = 6,
    VT_C_TYPE = 8,
    VT_C = 10,
    VT_D = 12,
    VT_E = 14
  };
  int32_t a() const {
    return GetField<int32_t>(VT_A, 0);
  }
  bool b() const {
    return GetField<uint8_t>(VT_B, 0) != 0;
  }
  UnionDeprecation::V1::Union c_type() const {
    return static_cast<UnionDeprecation::V1::Union>(GetField<uint8_t>(VT_C_TYPE, 0));
  }
  const void *c() const {
    return GetPointer<const void *>(VT_C);
  }
  template<typename T> const T *c_as() const;
  const UnionDeprecation::V1::TableA *c_as_TableA() const {
    return c_type() == UnionDeprecation::V1::Union_TableA ? static_cast<const UnionDeprecation::V1::TableA *>(c()) : nullptr;
  }
  const UnionDeprecation::V1::TableB *c_as_TableB() const {
    return c_type() == UnionDeprecation::V1::Union_TableB ? static_cast<const UnionDeprecation::V1::TableB *>(c()) : nullptr;
  }
  const UnionDeprecation::V1::TableA *d() const {
    return GetPointer<const UnionDeprecation::V1::TableA *>(VT_D);
  }
  int32_t e() const {
    return GetField<int32_t>(VT_E, 1234);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_A) &&
           VerifyField<uint8_t>(verifier, VT_B) &&
           VerifyField<uint8_t>(verifier, VT_C_TYPE) &&
           VerifyOffset(verifier, VT_C) &&
           VerifyUnion(verifier, c(), c_type()) &&
           VerifyOffset(verifier, VT_D) &&
           verifier.VerifyTable(d()) &&
           VerifyField<int32_t>(verifier, VT_E) &&
           verifier.EndTable();
  }
};

template<> inline const UnionDeprecation::V1::TableA *Root::c_as<UnionDeprecation::V1::TableA>() const {
  return c_as_TableA();
}

template<> inline const UnionDeprecation::V1::TableB *Root::c_as<UnionDeprecation::V1::TableB>() const {
  return c_as_TableB();
}

struct RootBuilder {
  typedef Root Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_a(int32_t a) {
    fbb_.AddElement<int32_t>(Root::VT_A, a, 0);
  }
  void add_b(bool b) {
    fbb_.AddElement<uint8_t>(Root::VT_B, static_cast<uint8_t>(b), 0);
  }
  void add_c_type(UnionDeprecation::V1::Union c_type) {
    fbb_.AddElement<uint8_t>(Root::VT_C_TYPE, static_cast<uint8_t>(c_type), 0);
  }
  void add_c(flatbuffers::Offset<void> c) {
    fbb_.AddOffset(Root::VT_C, c);
  }
  void add_d(flatbuffers::Offset<UnionDeprecation::V1::TableA> d) {
    fbb_.AddOffset(Root::VT_D, d);
  }
  void add_e(int32_t e) {
    fbb_.AddElement<int32_t>(Root::VT_E, e, 1234);
  }
  explicit RootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Root> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Root>(end);
    return o;
  }
};

inline flatbuffers::Offset<Root> CreateRoot(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t a = 0,
    bool b = false,
    UnionDeprecation::V1::Union c_type = UnionDeprecation::V1::Union_NONE,
    flatbuffers::Offset<void> c = 0,
    flatbuffers::Offset<UnionDeprecation::V1::TableA> d = 0,
    int32_t e = 1234) {
  RootBuilder builder_(_fbb);
  builder_.add_e(e);
  builder_.add_d(d);
  builder_.add_c(c);
  builder_.add_a(a);
  builder_.add_c_type(c_type);
  builder_.add_b(b);
  return builder_.Finish();
}

inline bool VerifyUnion(flatbuffers::Verifier &verifier, const void *obj, Union type) {
  switch (type) {
    case Union_NONE: {
      return true;
    }
    case Union_TableA: {
      auto ptr = reinterpret_cast<const UnionDeprecation::V1::TableA *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Union_TableB: {
      auto ptr = reinterpret_cast<const UnionDeprecation::V1::TableB *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUnion(
        verifier,  values->Get(i), types->GetEnum<Union>(i))) {
      return false;
    }
  }
  return true;
}

inline const UnionDeprecation::V1::Root *GetRoot(const void *buf) {
  return flatbuffers::GetRoot<UnionDeprecation::V1::Root>(buf);
}

inline const UnionDeprecation::V1::Root *GetSizePrefixedRoot(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<UnionDeprecation::V1::Root>(buf);
}

inline bool VerifyRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<UnionDeprecation::V1::Root>(nullptr);
}

inline bool VerifySizePrefixedRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<UnionDeprecation::V1::Root>(nullptr);
}

inline void FinishRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<UnionDeprecation::V1::Root> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<UnionDeprecation::V1::Root> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace V1
}  // namespace UnionDeprecation

#endif  // FLATBUFFERS_GENERATED_UNIONDEPRECATIONV1_UNIONDEPRECATION_V1_H_
