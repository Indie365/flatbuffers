// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_UNIONDEPRECATIONV2_UNIONDEPRECATION_V2_H_
#define FLATBUFFERS_GENERATED_UNIONDEPRECATIONV2_UNIONDEPRECATION_V2_H_

#include "flatbuffers/flatbuffers.h"

namespace UnionDeprecation {
namespace V2 {

struct TableA;
struct TableABuilder;

struct TableB;
struct TableBBuilder;

struct TableC;
struct TableCBuilder;

struct Root;
struct RootBuilder;

enum Union {
  Union_NONE = 0,
  Union_TableA = 1,
  Union_TableB = 2,
  Union_TableC = 3,
  Union_MIN = Union_NONE,
  Union_MAX = Union_TableC
};

inline const Union (&EnumValuesUnion())[4] {
  static const Union values[] = {
    Union_NONE,
    Union_TableA,
    Union_TableB,
    Union_TableC
  };
  return values;
}

inline const char * const *EnumNamesUnion() {
  static const char * const names[5] = {
    "NONE",
    "TableA",
    "TableB",
    "TableC",
    nullptr
  };
  return names;
}

inline const char *EnumNameUnion(Union e) {
  if (flatbuffers::IsOutRange(e, Union_NONE, Union_TableC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUnion()[index];
}

template<typename T> struct UnionTraits {
  static const Union enum_value = Union_NONE;
};

template<> struct UnionTraits<UnionDeprecation::V2::TableA> {
  static const Union enum_value = Union_TableA;
};

template<> struct UnionTraits<UnionDeprecation::V2::TableB> {
  static const Union enum_value = Union_TableB;
};

template<> struct UnionTraits<UnionDeprecation::V2::TableC> {
  static const Union enum_value = Union_TableC;
};

bool VerifyUnion(flatbuffers::Verifier &verifier, const void *obj, Union type);
bool VerifyUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct TableA FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableABuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4,
    VT_B = 6,
    VT_C = 8
  };
  float a() const {
    return GetField<float>(VT_A, 0.0f);
  }
  int32_t b() const {
    return GetField<int32_t>(VT_B, 0);
  }
  const flatbuffers::String *c() const {
    return GetPointer<const flatbuffers::String *>(VT_C);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_A) &&
           VerifyField<int32_t>(verifier, VT_B) &&
           VerifyOffset(verifier, VT_C) &&
           verifier.VerifyString(c()) &&
           verifier.EndTable();
  }
};

struct TableABuilder {
  typedef TableA Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_a(float a) {
    fbb_.AddElement<float>(TableA::VT_A, a, 0.0f);
  }
  void add_b(int32_t b) {
    fbb_.AddElement<int32_t>(TableA::VT_B, b, 0);
  }
  void add_c(flatbuffers::Offset<flatbuffers::String> c) {
    fbb_.AddOffset(TableA::VT_C, c);
  }
  explicit TableABuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TableA> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableA>(end);
    return o;
  }
};

inline flatbuffers::Offset<TableA> CreateTableA(
    flatbuffers::FlatBufferBuilder &_fbb,
    float a = 0.0f,
    int32_t b = 0,
    flatbuffers::Offset<flatbuffers::String> c = 0) {
  TableABuilder builder_(_fbb);
  builder_.add_c(c);
  builder_.add_b(b);
  builder_.add_a(a);
  return builder_.Finish();
}

inline flatbuffers::Offset<TableA> CreateTableADirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float a = 0.0f,
    int32_t b = 0,
    const char *c = nullptr) {
  auto c__ = c ? _fbb.CreateString(c) : 0;
  return UnionDeprecation::V2::CreateTableA(
      _fbb,
      a,
      b,
      c__);
}

struct TableB FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4
  };
  int32_t a() const {
    return GetField<int32_t>(VT_A, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_A) &&
           verifier.EndTable();
  }
};

struct TableBBuilder {
  typedef TableB Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_a(int32_t a) {
    fbb_.AddElement<int32_t>(TableB::VT_A, a, 0);
  }
  explicit TableBBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TableB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableB>(end);
    return o;
  }
};

inline flatbuffers::Offset<TableB> CreateTableB(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t a = 0) {
  TableBBuilder builder_(_fbb);
  builder_.add_a(a);
  return builder_.Finish();
}

struct TableC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TableCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4,
    VT_B = 6
  };
  double a() const {
    return GetField<double>(VT_A, 0.0);
  }
  const flatbuffers::String *b() const {
    return GetPointer<const flatbuffers::String *>(VT_B);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_A) &&
           VerifyOffset(verifier, VT_B) &&
           verifier.VerifyString(b()) &&
           verifier.EndTable();
  }
};

struct TableCBuilder {
  typedef TableC Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_a(double a) {
    fbb_.AddElement<double>(TableC::VT_A, a, 0.0);
  }
  void add_b(flatbuffers::Offset<flatbuffers::String> b) {
    fbb_.AddOffset(TableC::VT_B, b);
  }
  explicit TableCBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TableC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TableC>(end);
    return o;
  }
};

inline flatbuffers::Offset<TableC> CreateTableC(
    flatbuffers::FlatBufferBuilder &_fbb,
    double a = 0.0,
    flatbuffers::Offset<flatbuffers::String> b = 0) {
  TableCBuilder builder_(_fbb);
  builder_.add_a(a);
  builder_.add_b(b);
  return builder_.Finish();
}

inline flatbuffers::Offset<TableC> CreateTableCDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double a = 0.0,
    const char *b = nullptr) {
  auto b__ = b ? _fbb.CreateString(b) : 0;
  return UnionDeprecation::V2::CreateTableC(
      _fbb,
      a,
      b__);
}

struct Root FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RootBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_B = 6,
    VT_D = 12,
    VT_E = 14,
    VT_F = 16,
    VT_G = 18
  };
  bool b() const {
    return GetField<uint8_t>(VT_B, 0) != 0;
  }
  const UnionDeprecation::V2::TableA *d() const {
    return GetPointer<const UnionDeprecation::V2::TableA *>(VT_D);
  }
  uint32_t e() const {
    return GetField<uint32_t>(VT_E, 1234);
  }
  const UnionDeprecation::V2::TableC *f() const {
    return GetPointer<const UnionDeprecation::V2::TableC *>(VT_F);
  }
  uint8_t g() const {
    return GetField<uint8_t>(VT_G, 56);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_B) &&
           VerifyOffset(verifier, VT_D) &&
           verifier.VerifyTable(d()) &&
           VerifyField<uint32_t>(verifier, VT_E) &&
           VerifyOffset(verifier, VT_F) &&
           verifier.VerifyTable(f()) &&
           VerifyField<uint8_t>(verifier, VT_G) &&
           verifier.EndTable();
  }
};

struct RootBuilder {
  typedef Root Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_b(bool b) {
    fbb_.AddElement<uint8_t>(Root::VT_B, static_cast<uint8_t>(b), 0);
  }
  void add_d(flatbuffers::Offset<UnionDeprecation::V2::TableA> d) {
    fbb_.AddOffset(Root::VT_D, d);
  }
  void add_e(uint32_t e) {
    fbb_.AddElement<uint32_t>(Root::VT_E, e, 1234);
  }
  void add_f(flatbuffers::Offset<UnionDeprecation::V2::TableC> f) {
    fbb_.AddOffset(Root::VT_F, f);
  }
  void add_g(uint8_t g) {
    fbb_.AddElement<uint8_t>(Root::VT_G, g, 56);
  }
  explicit RootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Root> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Root>(end);
    return o;
  }
};

inline flatbuffers::Offset<Root> CreateRoot(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool b = false,
    flatbuffers::Offset<UnionDeprecation::V2::TableA> d = 0,
    uint32_t e = 1234,
    flatbuffers::Offset<UnionDeprecation::V2::TableC> f = 0,
    uint8_t g = 56) {
  RootBuilder builder_(_fbb);
  builder_.add_f(f);
  builder_.add_e(e);
  builder_.add_d(d);
  builder_.add_g(g);
  builder_.add_b(b);
  return builder_.Finish();
}

inline bool VerifyUnion(flatbuffers::Verifier &verifier, const void *obj, Union type) {
  switch (type) {
    case Union_NONE: {
      return true;
    }
    case Union_TableA: {
      auto ptr = reinterpret_cast<const UnionDeprecation::V2::TableA *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Union_TableB: {
      auto ptr = reinterpret_cast<const UnionDeprecation::V2::TableB *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Union_TableC: {
      auto ptr = reinterpret_cast<const UnionDeprecation::V2::TableC *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUnion(
        verifier,  values->Get(i), types->GetEnum<Union>(i))) {
      return false;
    }
  }
  return true;
}

inline const UnionDeprecation::V2::Root *GetRoot(const void *buf) {
  return flatbuffers::GetRoot<UnionDeprecation::V2::Root>(buf);
}

inline const UnionDeprecation::V2::Root *GetSizePrefixedRoot(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<UnionDeprecation::V2::Root>(buf);
}

inline bool VerifyRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<UnionDeprecation::V2::Root>(nullptr);
}

inline bool VerifySizePrefixedRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<UnionDeprecation::V2::Root>(nullptr);
}

inline void FinishRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<UnionDeprecation::V2::Root> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<UnionDeprecation::V2::Root> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace V2
}  // namespace UnionDeprecation

#endif  // FLATBUFFERS_GENERATED_UNIONDEPRECATIONV2_UNIONDEPRECATION_V2_H_
