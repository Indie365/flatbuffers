// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_UNIONUNDERLYINGTYPE_UNION_UNDERLYING_TYPE_H_
#define FLATBUFFERS_GENERATED_UNIONUNDERLYINGTYPE_UNION_UNDERLYING_TYPE_H_

#include "flatbuffers/flatbuffers.h"

namespace union_underlying_type {

struct A;
struct ABuilder;
struct AT;

struct B;
struct BBuilder;
struct BT;

struct ABTable;
struct ABTableBuilder;
struct ABTableT;

bool operator==(const AT &lhs, const AT &rhs);
bool operator!=(const AT &lhs, const AT &rhs);
bool operator==(const BT &lhs, const BT &rhs);
bool operator!=(const BT &lhs, const BT &rhs);
bool operator==(const ABTableT &lhs, const ABTableT &rhs);
bool operator!=(const ABTableT &lhs, const ABTableT &rhs);

inline const flatbuffers::TypeTable *ATypeTable();

inline const flatbuffers::TypeTable *BTypeTable();

inline const flatbuffers::TypeTable *ABTableTypeTable();

enum AB : int32_t {
  AB_NONE = 0,
  AB_A = 1,
  AB_B = 2,
  AB_MIN = AB_NONE,
  AB_MAX = AB_B
};

inline const AB (&EnumValuesAB())[3] {
  static const AB values[] = {
    AB_NONE,
    AB_A,
    AB_B
  };
  return values;
}

inline const char * const *EnumNamesAB() {
  static const char * const names[4] = {
    "NONE",
    "A",
    "B",
    nullptr
  };
  return names;
}

inline const char *EnumNameAB(AB e) {
  if (flatbuffers::IsOutRange(e, AB_NONE, AB_B)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAB()[index];
}

template<typename T> struct ABTraits {
  static const AB enum_value = AB_NONE;
};

template<> struct ABTraits<union_underlying_type::A> {
  static const AB enum_value = AB_A;
};

template<> struct ABTraits<union_underlying_type::B> {
  static const AB enum_value = AB_B;
};

struct ABUnion {
  AB type;
  void *value;

  ABUnion() : type(AB_NONE), value(nullptr) {}
  ABUnion(ABUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(AB_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ABUnion(const ABUnion &);
  ABUnion &operator=(const ABUnion &u)
    { ABUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ABUnion &operator=(ABUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ABUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = ABTraits<typename RT::TableType>::enum_value;
    if (type != AB_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, AB type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  union_underlying_type::AT *AsA() {
    return type == AB_A ?
      reinterpret_cast<union_underlying_type::AT *>(value) : nullptr;
  }
  const union_underlying_type::AT *AsA() const {
    return type == AB_A ?
      reinterpret_cast<const union_underlying_type::AT *>(value) : nullptr;
  }
  union_underlying_type::BT *AsB() {
    return type == AB_B ?
      reinterpret_cast<union_underlying_type::BT *>(value) : nullptr;
  }
  const union_underlying_type::BT *AsB() const {
    return type == AB_B ?
      reinterpret_cast<const union_underlying_type::BT *>(value) : nullptr;
  }
};


inline bool operator==(const ABUnion &lhs, const ABUnion &rhs) {
  if (lhs.type != rhs.type) return false;
  switch (lhs.type) {
    case AB_NONE: {
      return true;
    }
    case AB_A: {
      return *(reinterpret_cast<const union_underlying_type::AT *>(lhs.value)) ==
             *(reinterpret_cast<const union_underlying_type::AT *>(rhs.value));
    }
    case AB_B: {
      return *(reinterpret_cast<const union_underlying_type::BT *>(lhs.value)) ==
             *(reinterpret_cast<const union_underlying_type::BT *>(rhs.value));
    }
    default: {
      return false;
    }
  }
}

inline bool operator!=(const ABUnion &lhs, const ABUnion &rhs) {
    return !(lhs == rhs);
}

bool VerifyAB(flatbuffers::Verifier &verifier, const void *obj, AB type);
bool VerifyABVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct AT : public flatbuffers::NativeTable {
  typedef A TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "union_underlying_type.AT";
  }
};

struct A FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AT NativeTableType;
  typedef ABuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ATypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "union_underlying_type.A";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  AT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<A> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ABuilder {
  typedef A Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ABuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<A> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<A>(end);
    return o;
  }
};

inline flatbuffers::Offset<A> CreateA(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ABuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<A> CreateA(flatbuffers::FlatBufferBuilder &_fbb, const AT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BT : public flatbuffers::NativeTable {
  typedef B TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "union_underlying_type.BT";
  }
};

struct B FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BT NativeTableType;
  typedef BBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "union_underlying_type.B";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<B> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BBuilder {
  typedef B Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<B> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<B>(end);
    return o;
  }
};

inline flatbuffers::Offset<B> CreateB(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<B> CreateB(flatbuffers::FlatBufferBuilder &_fbb, const BT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ABTableT : public flatbuffers::NativeTable {
  typedef ABTable TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "union_underlying_type.ABTableT";
  }
  union_underlying_type::AB ab_type = union_underlying_type::AB_NONE;
  union_underlying_type::ABUnion ab{};
};

struct ABTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ABTableT NativeTableType;
  typedef ABTableBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ABTableTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "union_underlying_type.ABTable";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AB_TYPE = 4,
    VT_AB = 6
  };
  union_underlying_type::AB ab_type() const {
    return static_cast<union_underlying_type::AB>(GetField<int32_t>(VT_AB_TYPE, 0));
  }
  const void *ab() const {
    return GetPointer<const void *>(VT_AB);
  }
  template<typename T> const T *ab_as() const;
  const union_underlying_type::A *ab_as_A() const {
    return ab_type() == union_underlying_type::AB_A ? static_cast<const union_underlying_type::A *>(ab()) : nullptr;
  }
  const union_underlying_type::B *ab_as_B() const {
    return ab_type() == union_underlying_type::AB_B ? static_cast<const union_underlying_type::B *>(ab()) : nullptr;
  }
  void *mutable_ab() {
    return GetPointer<void *>(VT_AB);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AB_TYPE) &&
           VerifyOffset(verifier, VT_AB) &&
           VerifyAB(verifier, ab(), ab_type()) &&
           verifier.EndTable();
  }
  ABTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ABTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ABTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ABTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const union_underlying_type::A *ABTable::ab_as<union_underlying_type::A>() const {
  return ab_as_A();
}

template<> inline const union_underlying_type::B *ABTable::ab_as<union_underlying_type::B>() const {
  return ab_as_B();
}

struct ABTableBuilder {
  typedef ABTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ab_type(union_underlying_type::AB ab_type) {
    fbb_.AddElement<int32_t>(ABTable::VT_AB_TYPE, static_cast<int32_t>(ab_type), 0);
  }
  void add_ab(flatbuffers::Offset<void> ab) {
    fbb_.AddOffset(ABTable::VT_AB, ab);
  }
  explicit ABTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ABTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ABTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<ABTable> CreateABTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    union_underlying_type::AB ab_type = union_underlying_type::AB_NONE,
    flatbuffers::Offset<void> ab = 0) {
  ABTableBuilder builder_(_fbb);
  builder_.add_ab(ab);
  builder_.add_ab_type(ab_type);
  return builder_.Finish();
}

flatbuffers::Offset<ABTable> CreateABTable(flatbuffers::FlatBufferBuilder &_fbb, const ABTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const AT &, const AT &) {
  return true;
}

inline bool operator!=(const AT &lhs, const AT &rhs) {
    return !(lhs == rhs);
}


inline AT *A::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AT>(new AT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void A::UnPackTo(AT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<A> A::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateA(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<A> CreateA(flatbuffers::FlatBufferBuilder &_fbb, const AT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return union_underlying_type::CreateA(
      _fbb);
}


inline bool operator==(const BT &, const BT &) {
  return true;
}

inline bool operator!=(const BT &lhs, const BT &rhs) {
    return !(lhs == rhs);
}


inline BT *B::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BT>(new BT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void B::UnPackTo(BT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<B> B::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateB(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<B> CreateB(flatbuffers::FlatBufferBuilder &_fbb, const BT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return union_underlying_type::CreateB(
      _fbb);
}


inline bool operator==(const ABTableT &lhs, const ABTableT &rhs) {
  return
      (lhs.ab_type == rhs.ab_type) &&
      (lhs.ab == rhs.ab);
}

inline bool operator!=(const ABTableT &lhs, const ABTableT &rhs) {
    return !(lhs == rhs);
}


inline ABTableT *ABTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ABTableT>(new ABTableT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ABTable::UnPackTo(ABTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ab_type(); _o->ab_type = _e; }
  { auto _e = ab(); if (_e) _o->ab.value = union_underlying_type::ABUnion::UnPack(_e, ab_type(), _resolver); }
}

inline flatbuffers::Offset<ABTable> ABTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ABTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateABTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ABTable> CreateABTable(flatbuffers::FlatBufferBuilder &_fbb, const ABTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ABTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ab_type = _o->ab_type;
  auto _ab = _o->ab.Pack(_fbb);
  return union_underlying_type::CreateABTable(
      _fbb,
      _ab_type,
      _ab);
}

inline bool VerifyAB(flatbuffers::Verifier &verifier, const void *obj, AB type) {
  switch (type) {
    case AB_NONE: {
      return true;
    }
    case AB_A: {
      auto ptr = reinterpret_cast<const union_underlying_type::A *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AB_B: {
      auto ptr = reinterpret_cast<const union_underlying_type::B *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyABVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAB(
        verifier,  values->Get(i), types->GetEnum<AB>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ABUnion::UnPack(const void *obj, AB type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case AB_A: {
      auto ptr = reinterpret_cast<const union_underlying_type::A *>(obj);
      return ptr->UnPack(resolver);
    }
    case AB_B: {
      auto ptr = reinterpret_cast<const union_underlying_type::B *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ABUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case AB_A: {
      auto ptr = reinterpret_cast<const union_underlying_type::AT *>(value);
      return CreateA(_fbb, ptr, _rehasher).Union();
    }
    case AB_B: {
      auto ptr = reinterpret_cast<const union_underlying_type::BT *>(value);
      return CreateB(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ABUnion::ABUnion(const ABUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case AB_A: {
      value = new union_underlying_type::AT(*reinterpret_cast<union_underlying_type::AT *>(u.value));
      break;
    }
    case AB_B: {
      value = new union_underlying_type::BT(*reinterpret_cast<union_underlying_type::BT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ABUnion::Reset() {
  switch (type) {
    case AB_A: {
      auto ptr = reinterpret_cast<union_underlying_type::AT *>(value);
      delete ptr;
      break;
    }
    case AB_B: {
      auto ptr = reinterpret_cast<union_underlying_type::BT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = AB_NONE;
}

inline const flatbuffers::TypeTable *ABTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    union_underlying_type::ATypeTable,
    union_underlying_type::BTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "A",
    "B"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ATypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *BTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ABTableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    union_underlying_type::ABTypeTable
  };
  static const char * const names[] = {
    "ab_type",
    "ab"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const union_underlying_type::ABTable *GetABTable(const void *buf) {
  return flatbuffers::GetRoot<union_underlying_type::ABTable>(buf);
}

inline const union_underlying_type::ABTable *GetSizePrefixedABTable(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<union_underlying_type::ABTable>(buf);
}

inline ABTable *GetMutableABTable(void *buf) {
  return flatbuffers::GetMutableRoot<ABTable>(buf);
}

inline union_underlying_type::ABTable *GetMutableSizePrefixedABTable(void *buf) {
  return flatbuffers::GetMutableSizePrefixedRoot<union_underlying_type::ABTable>(buf);
}

inline bool VerifyABTableBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<union_underlying_type::ABTable>(nullptr);
}

inline bool VerifySizePrefixedABTableBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<union_underlying_type::ABTable>(nullptr);
}

inline void FinishABTableBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<union_underlying_type::ABTable> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedABTableBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<union_underlying_type::ABTable> root) {
  fbb.FinishSizePrefixed(root);
}

inline flatbuffers::unique_ptr<union_underlying_type::ABTableT> UnPackABTable(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return flatbuffers::unique_ptr<union_underlying_type::ABTableT>(GetABTable(buf)->UnPack(res));
}

inline flatbuffers::unique_ptr<union_underlying_type::ABTableT> UnPackSizePrefixedABTable(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return flatbuffers::unique_ptr<union_underlying_type::ABTableT>(GetSizePrefixedABTable(buf)->UnPack(res));
}

}  // namespace union_underlying_type

#endif  // FLATBUFFERS_GENERATED_UNIONUNDERLYINGTYPE_UNION_UNDERLYING_TYPE_H_
