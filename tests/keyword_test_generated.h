// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_KEYWORDTEST_KEYWORDTEST_H_
#define FLATBUFFERS_GENERATED_KEYWORDTEST_KEYWORDTEST_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

namespace KeywordTest {

struct KeywordsInTable;
struct KeywordsInTableBuilder;
struct KeywordsInTableT;

struct Table2;
struct Table2Builder;
struct Table2T;

bool operator==(const KeywordsInTableT &lhs, const KeywordsInTableT &rhs);
bool operator!=(const KeywordsInTableT &lhs, const KeywordsInTableT &rhs);
bool operator==(const Table2T &lhs, const Table2T &rhs);
bool operator!=(const Table2T &lhs, const Table2T &rhs);

inline const flatbuffers::TypeTable *KeywordsInTableTypeTable();

inline const flatbuffers::TypeTable *Table2TypeTable();

enum ABC : int32_t {
  ABC_void_ = 0,
  ABC_where = 1,
  ABC_stackalloc = 2,
  ABC_MIN = ABC_void_,
  ABC_MAX = ABC_stackalloc
};

inline const ABC (&EnumValuesABC())[3] {
  static const ABC values[] = {
    ABC_void_,
    ABC_where,
    ABC_stackalloc
  };
  return values;
}

inline const char * const *EnumNamesABC() {
  static const char * const names[4] = {
    "void_",
    "where",
    "stackalloc",
    nullptr
  };
  return names;
}

inline const char *EnumNameABC(ABC e) {
  if (flatbuffers::IsOutRange(e, ABC_void_, ABC_stackalloc)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesABC()[index];
}

enum public_ : int32_t {
  public__NONE = 0,
  public__MIN = public__NONE,
  public__MAX = public__NONE
};

inline const public_ (&EnumValuespublic_())[1] {
  static const public_ values[] = {
    public__NONE
  };
  return values;
}

inline const char * const *EnumNamespublic_() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNamepublic_(public_ e) {
  if (flatbuffers::IsOutRange(e, public__NONE, public__NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamespublic_()[index];
}

enum KeywordsInUnion : uint8_t {
  KeywordsInUnion_NONE = 0,
  KeywordsInUnion_static_ = 1,
  KeywordsInUnion_internal = 2,
  KeywordsInUnion_MIN = KeywordsInUnion_NONE,
  KeywordsInUnion_MAX = KeywordsInUnion_internal
};

inline const KeywordsInUnion (&EnumValuesKeywordsInUnion())[3] {
  static const KeywordsInUnion values[] = {
    KeywordsInUnion_NONE,
    KeywordsInUnion_static_,
    KeywordsInUnion_internal
  };
  return values;
}

inline const char * const *EnumNamesKeywordsInUnion() {
  static const char * const names[4] = {
    "NONE",
    "static_",
    "internal",
    nullptr
  };
  return names;
}

inline const char *EnumNameKeywordsInUnion(KeywordsInUnion e) {
  if (flatbuffers::IsOutRange(e, KeywordsInUnion_NONE, KeywordsInUnion_internal)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKeywordsInUnion()[index];
}

struct KeywordsInUnionUnion {
  KeywordsInUnion type;
  void *value;

  KeywordsInUnionUnion() : type(KeywordsInUnion_NONE), value(nullptr) {}
  KeywordsInUnionUnion(KeywordsInUnionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(KeywordsInUnion_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  KeywordsInUnionUnion(const KeywordsInUnionUnion &);
  KeywordsInUnionUnion &operator=(const KeywordsInUnionUnion &u)
    { KeywordsInUnionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  KeywordsInUnionUnion &operator=(KeywordsInUnionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~KeywordsInUnionUnion() { Reset(); }

  void Reset();

  static void *UnPack(const void *obj, KeywordsInUnion type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  KeywordTest::KeywordsInTableT *Asstatic_() {
    return type == KeywordsInUnion_static_ ?
      reinterpret_cast<KeywordTest::KeywordsInTableT *>(value) : nullptr;
  }
  const KeywordTest::KeywordsInTableT *Asstatic_() const {
    return type == KeywordsInUnion_static_ ?
      reinterpret_cast<const KeywordTest::KeywordsInTableT *>(value) : nullptr;
  }
  KeywordTest::KeywordsInTableT *Asinternal() {
    return type == KeywordsInUnion_internal ?
      reinterpret_cast<KeywordTest::KeywordsInTableT *>(value) : nullptr;
  }
  const KeywordTest::KeywordsInTableT *Asinternal() const {
    return type == KeywordsInUnion_internal ?
      reinterpret_cast<const KeywordTest::KeywordsInTableT *>(value) : nullptr;
  }
};


inline bool operator==(const KeywordsInUnionUnion &lhs, const KeywordsInUnionUnion &rhs) {
  if (lhs.type != rhs.type) return false;
  switch (lhs.type) {
    case KeywordsInUnion_NONE: {
      return true;
    }
    case KeywordsInUnion_static_: {
      return *(reinterpret_cast<const KeywordTest::KeywordsInTableT *>(lhs.value)) ==
             *(reinterpret_cast<const KeywordTest::KeywordsInTableT *>(rhs.value));
    }
    case KeywordsInUnion_internal: {
      return *(reinterpret_cast<const KeywordTest::KeywordsInTableT *>(lhs.value)) ==
             *(reinterpret_cast<const KeywordTest::KeywordsInTableT *>(rhs.value));
    }
    default: {
      return false;
    }
  }
}

inline bool operator!=(const KeywordsInUnionUnion &lhs, const KeywordsInUnionUnion &rhs) {
    return !(lhs == rhs);
}

bool VerifyKeywordsInUnion(flatbuffers::Verifier &verifier, const void *obj, KeywordsInUnion type);
bool VerifyKeywordsInUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct KeywordsInTableT : public flatbuffers::NativeTable {
  typedef KeywordsInTable TableType;
  KeywordTest::ABC is = KeywordTest::ABC_void_;
  KeywordTest::public_ private_ = KeywordTest::public__NONE;
  int32_t type = 0;
  bool default_ = false;
};

struct KeywordsInTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KeywordsInTableT NativeTableType;
  typedef KeywordsInTableBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return KeywordsInTableTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS = 4,
    VT_PRIVATE_ = 6,
    VT_TYPE = 8,
    VT_DEFAULT_ = 10
  };
  KeywordTest::ABC is() const {
    return static_cast<KeywordTest::ABC>(GetField<int32_t>(VT_IS, 0));
  }
  bool mutate_is(KeywordTest::ABC _is = static_cast<KeywordTest::ABC>(0)) {
    return SetField<int32_t>(VT_IS, static_cast<int32_t>(_is), 0);
  }
  KeywordTest::public_ private_() const {
    return static_cast<KeywordTest::public_>(GetField<int32_t>(VT_PRIVATE_, 0));
  }
  bool mutate_private_(KeywordTest::public_ _private_ = static_cast<KeywordTest::public_>(0)) {
    return SetField<int32_t>(VT_PRIVATE_, static_cast<int32_t>(_private_), 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool mutate_type(int32_t _type = 0) {
    return SetField<int32_t>(VT_TYPE, _type, 0);
  }
  bool default_() const {
    return GetField<uint8_t>(VT_DEFAULT_, 0) != 0;
  }
  bool mutate_default_(bool _default_ = 0) {
    return SetField<uint8_t>(VT_DEFAULT_, static_cast<uint8_t>(_default_), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_IS, 4) &&
           VerifyField<int32_t>(verifier, VT_PRIVATE_, 4) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_DEFAULT_, 1) &&
           verifier.EndTable();
  }
  KeywordsInTableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KeywordsInTableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<KeywordsInTable> Pack(flatbuffers::FlatBufferBuilder &_fbb, const KeywordsInTableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KeywordsInTableBuilder {
  typedef KeywordsInTable Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is(KeywordTest::ABC is) {
    fbb_.AddElement<int32_t>(KeywordsInTable::VT_IS, static_cast<int32_t>(is), 0);
  }
  void add_private_(KeywordTest::public_ private_) {
    fbb_.AddElement<int32_t>(KeywordsInTable::VT_PRIVATE_, static_cast<int32_t>(private_), 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(KeywordsInTable::VT_TYPE, type, 0);
  }
  void add_default_(bool default_) {
    fbb_.AddElement<uint8_t>(KeywordsInTable::VT_DEFAULT_, static_cast<uint8_t>(default_), 0);
  }
  explicit KeywordsInTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<KeywordsInTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeywordsInTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<KeywordsInTable> CreateKeywordsInTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    KeywordTest::ABC is = KeywordTest::ABC_void_,
    KeywordTest::public_ private_ = KeywordTest::public__NONE,
    int32_t type = 0,
    bool default_ = false) {
  KeywordsInTableBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_private_(private_);
  builder_.add_is(is);
  builder_.add_default_(default_);
  return builder_.Finish();
}

flatbuffers::Offset<KeywordsInTable> CreateKeywordsInTable(flatbuffers::FlatBufferBuilder &_fbb, const KeywordsInTableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Table2T : public flatbuffers::NativeTable {
  typedef Table2 TableType;
  KeywordTest::KeywordsInUnionUnion type{};
  KeywordTest::KeywordsInUnionUnion constexpr_{};
};

struct Table2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Table2T NativeTableType;
  typedef Table2Builder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Table2TypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE_TYPE = 4,
    VT_TYPE = 6,
    VT_CONSTEXPR_TYPE = 8,
    VT_CONSTEXPR_ = 10
  };
  KeywordTest::KeywordsInUnion type_type() const {
    return static_cast<KeywordTest::KeywordsInUnion>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
  }
  const void *type() const {
    return GetPointer<const void *>(VT_TYPE);
  }
  const KeywordTest::KeywordsInTable *type_as_static_() const {
    return type_type() == KeywordTest::KeywordsInUnion_static_ ? static_cast<const KeywordTest::KeywordsInTable *>(type()) : nullptr;
  }
  const KeywordTest::KeywordsInTable *type_as_internal() const {
    return type_type() == KeywordTest::KeywordsInUnion_internal ? static_cast<const KeywordTest::KeywordsInTable *>(type()) : nullptr;
  }
  void *mutable_type() {
    return GetPointer<void *>(VT_TYPE);
  }
  KeywordTest::KeywordsInUnion constexpr_type() const {
    return static_cast<KeywordTest::KeywordsInUnion>(GetField<uint8_t>(VT_CONSTEXPR_TYPE, 0));
  }
  const void *constexpr_() const {
    return GetPointer<const void *>(VT_CONSTEXPR_);
  }
  const KeywordTest::KeywordsInTable *constexpr__as_static_() const {
    return constexpr_type() == KeywordTest::KeywordsInUnion_static_ ? static_cast<const KeywordTest::KeywordsInTable *>(constexpr_()) : nullptr;
  }
  const KeywordTest::KeywordsInTable *constexpr__as_internal() const {
    return constexpr_type() == KeywordTest::KeywordsInUnion_internal ? static_cast<const KeywordTest::KeywordsInTable *>(constexpr_()) : nullptr;
  }
  void *mutable_constexpr_() {
    return GetPointer<void *>(VT_CONSTEXPR_);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_TYPE) &&
           VerifyKeywordsInUnion(verifier, type(), type_type()) &&
           VerifyField<uint8_t>(verifier, VT_CONSTEXPR_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONSTEXPR_) &&
           VerifyKeywordsInUnion(verifier, constexpr_(), constexpr_type()) &&
           verifier.EndTable();
  }
  Table2T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Table2T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Table2> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Table2T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Table2Builder {
  typedef Table2 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type_type(KeywordTest::KeywordsInUnion type_type) {
    fbb_.AddElement<uint8_t>(Table2::VT_TYPE_TYPE, static_cast<uint8_t>(type_type), 0);
  }
  void add_type(flatbuffers::Offset<void> type) {
    fbb_.AddOffset(Table2::VT_TYPE, type);
  }
  void add_constexpr_type(KeywordTest::KeywordsInUnion constexpr_type) {
    fbb_.AddElement<uint8_t>(Table2::VT_CONSTEXPR_TYPE, static_cast<uint8_t>(constexpr_type), 0);
  }
  void add_constexpr_(flatbuffers::Offset<void> constexpr_) {
    fbb_.AddOffset(Table2::VT_CONSTEXPR_, constexpr_);
  }
  explicit Table2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Table2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Table2>(end);
    return o;
  }
};

inline flatbuffers::Offset<Table2> CreateTable2(
    flatbuffers::FlatBufferBuilder &_fbb,
    KeywordTest::KeywordsInUnion type_type = KeywordTest::KeywordsInUnion_NONE,
    flatbuffers::Offset<void> type = 0,
    KeywordTest::KeywordsInUnion constexpr_type = KeywordTest::KeywordsInUnion_NONE,
    flatbuffers::Offset<void> constexpr_ = 0) {
  Table2Builder builder_(_fbb);
  builder_.add_constexpr_(constexpr_);
  builder_.add_type(type);
  builder_.add_constexpr_type(constexpr_type);
  builder_.add_type_type(type_type);
  return builder_.Finish();
}

flatbuffers::Offset<Table2> CreateTable2(flatbuffers::FlatBufferBuilder &_fbb, const Table2T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const KeywordsInTableT &lhs, const KeywordsInTableT &rhs) {
  return
      (lhs.is == rhs.is) &&
      (lhs.private_ == rhs.private_) &&
      (lhs.type == rhs.type) &&
      (lhs.default_ == rhs.default_);
}

inline bool operator!=(const KeywordsInTableT &lhs, const KeywordsInTableT &rhs) {
    return !(lhs == rhs);
}


inline KeywordsInTableT *KeywordsInTable::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<KeywordsInTableT>(new KeywordsInTableT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void KeywordsInTable::UnPackTo(KeywordsInTableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = is(); _o->is = _e; }
  { auto _e = private_(); _o->private_ = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = default_(); _o->default_ = _e; }
}

inline flatbuffers::Offset<KeywordsInTable> KeywordsInTable::Pack(flatbuffers::FlatBufferBuilder &_fbb, const KeywordsInTableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKeywordsInTable(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<KeywordsInTable> CreateKeywordsInTable(flatbuffers::FlatBufferBuilder &_fbb, const KeywordsInTableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const KeywordsInTableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _is = _o->is;
  auto _private_ = _o->private_;
  auto _type = _o->type;
  auto _default_ = _o->default_;
  return KeywordTest::CreateKeywordsInTable(
      _fbb,
      _is,
      _private_,
      _type,
      _default_);
}


inline bool operator==(const Table2T &lhs, const Table2T &rhs) {
  return
      (lhs.type == rhs.type) &&
      (lhs.constexpr_ == rhs.constexpr_);
}

inline bool operator!=(const Table2T &lhs, const Table2T &rhs) {
    return !(lhs == rhs);
}


inline Table2T *Table2::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Table2T>(new Table2T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Table2::UnPackTo(Table2T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type_type(); _o->type.type = _e; }
  { auto _e = type(); if (_e) _o->type.value = KeywordTest::KeywordsInUnionUnion::UnPack(_e, type_type(), _resolver); }
  { auto _e = constexpr_type(); _o->constexpr_.type = _e; }
  { auto _e = constexpr_(); if (_e) _o->constexpr_.value = KeywordTest::KeywordsInUnionUnion::UnPack(_e, constexpr_type(), _resolver); }
}

inline flatbuffers::Offset<Table2> Table2::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Table2T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTable2(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Table2> CreateTable2(flatbuffers::FlatBufferBuilder &_fbb, const Table2T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Table2T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type_type = _o->type.type;
  auto _type = _o->type.Pack(_fbb);
  auto _constexpr_type = _o->constexpr_.type;
  auto _constexpr_ = _o->constexpr_.Pack(_fbb);
  return KeywordTest::CreateTable2(
      _fbb,
      _type_type,
      _type,
      _constexpr_type,
      _constexpr_);
}

inline bool VerifyKeywordsInUnion(flatbuffers::Verifier &verifier, const void *obj, KeywordsInUnion type) {
  switch (type) {
    case KeywordsInUnion_NONE: {
      return true;
    }
    case KeywordsInUnion_static_: {
      auto ptr = reinterpret_cast<const KeywordTest::KeywordsInTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case KeywordsInUnion_internal: {
      auto ptr = reinterpret_cast<const KeywordTest::KeywordsInTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyKeywordsInUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyKeywordsInUnion(
        verifier,  values->Get(i), types->GetEnum<KeywordsInUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline void *KeywordsInUnionUnion::UnPack(const void *obj, KeywordsInUnion type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case KeywordsInUnion_static_: {
      auto ptr = reinterpret_cast<const KeywordTest::KeywordsInTable *>(obj);
      return ptr->UnPack(resolver);
    }
    case KeywordsInUnion_internal: {
      auto ptr = reinterpret_cast<const KeywordTest::KeywordsInTable *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> KeywordsInUnionUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case KeywordsInUnion_static_: {
      auto ptr = reinterpret_cast<const KeywordTest::KeywordsInTableT *>(value);
      return CreateKeywordsInTable(_fbb, ptr, _rehasher).Union();
    }
    case KeywordsInUnion_internal: {
      auto ptr = reinterpret_cast<const KeywordTest::KeywordsInTableT *>(value);
      return CreateKeywordsInTable(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline KeywordsInUnionUnion::KeywordsInUnionUnion(const KeywordsInUnionUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case KeywordsInUnion_static_: {
      value = new KeywordTest::KeywordsInTableT(*reinterpret_cast<KeywordTest::KeywordsInTableT *>(u.value));
      break;
    }
    case KeywordsInUnion_internal: {
      value = new KeywordTest::KeywordsInTableT(*reinterpret_cast<KeywordTest::KeywordsInTableT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void KeywordsInUnionUnion::Reset() {
  switch (type) {
    case KeywordsInUnion_static_: {
      auto ptr = reinterpret_cast<KeywordTest::KeywordsInTableT *>(value);
      delete ptr;
      break;
    }
    case KeywordsInUnion_internal: {
      auto ptr = reinterpret_cast<KeywordTest::KeywordsInTableT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = KeywordsInUnion_NONE;
}

inline const flatbuffers::TypeTable *ABCTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    KeywordTest::ABCTypeTable
  };
  static const char * const names[] = {
    "void_",
    "where",
    "stackalloc"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *publicTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    KeywordTest::publicTypeTable
  };
  static const char * const names[] = {
    "NONE"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *KeywordsInUnionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    KeywordTest::KeywordsInTableTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "static_",
    "internal"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *KeywordsInTableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    KeywordTest::ABCTypeTable,
    KeywordTest::publicTypeTable
  };
  static const char * const names[] = {
    "is",
    "private_",
    "type",
    "default_"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *Table2TypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    KeywordTest::KeywordsInUnionTypeTable
  };
  static const char * const names[] = {
    "type_type",
    "type",
    "constexpr_type",
    "constexpr_"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace KeywordTest

#endif  // FLATBUFFERS_GENERATED_KEYWORDTEST_KEYWORDTEST_H_
