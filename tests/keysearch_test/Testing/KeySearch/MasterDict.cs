// automatically generated by the FlatBuffers compiler, do not modify

namespace Testing.KeySearch
{

using System;
using FlatBuffers;

public struct MasterDict : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static MasterDict GetRootAsMasterDict(ByteBuffer _bb) { return GetRootAsMasterDict(_bb, new MasterDict()); }
  public static MasterDict GetRootAsMasterDict(ByteBuffer _bb, MasterDict obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool MasterDictBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "FBMD"); }
  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
  public MasterDict __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public UByteEntry? UbyteEntries(int j) { int o = __p.__offset(4); return o != 0 ? (UByteEntry?)(new UByteEntry()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int UbyteEntriesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  public ByteEntry? ByteEntries(int j) { int o = __p.__offset(6); return o != 0 ? (ByteEntry?)(new ByteEntry()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int ByteEntriesLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
  public BoolEntry? BoolEntries(int j) { int o = __p.__offset(8); return o != 0 ? (BoolEntry?)(new BoolEntry()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int BoolEntriesLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
  public ShortEntry? ShortEntries(int j) { int o = __p.__offset(10); return o != 0 ? (ShortEntry?)(new ShortEntry()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int ShortEntriesLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
  public UShortEntry? UshortEntries(int j) { int o = __p.__offset(12); return o != 0 ? (UShortEntry?)(new UShortEntry()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int UshortEntriesLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
  public IntEntry? IntEntries(int j) { int o = __p.__offset(14); return o != 0 ? (IntEntry?)(new IntEntry()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int IntEntriesLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }
  public UIntEntry? UintEntries(int j) { int o = __p.__offset(16); return o != 0 ? (UIntEntry?)(new UIntEntry()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int UintEntriesLength { get { int o = __p.__offset(16); return o != 0 ? __p.__vector_len(o) : 0; } }
  public FloatEntry? FloatEntries(int j) { int o = __p.__offset(18); return o != 0 ? (FloatEntry?)(new FloatEntry()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int FloatEntriesLength { get { int o = __p.__offset(18); return o != 0 ? __p.__vector_len(o) : 0; } }
  public LongEntry? LongEntries(int j) { int o = __p.__offset(20); return o != 0 ? (LongEntry?)(new LongEntry()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int LongEntriesLength { get { int o = __p.__offset(20); return o != 0 ? __p.__vector_len(o) : 0; } }
  public ULongEntry? UlongEntries(int j) { int o = __p.__offset(22); return o != 0 ? (ULongEntry?)(new ULongEntry()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int UlongEntriesLength { get { int o = __p.__offset(22); return o != 0 ? __p.__vector_len(o) : 0; } }
  public DoubleEntry? DoubleEntries(int j) { int o = __p.__offset(24); return o != 0 ? (DoubleEntry?)(new DoubleEntry()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int DoubleEntriesLength { get { int o = __p.__offset(24); return o != 0 ? __p.__vector_len(o) : 0; } }
  public StringEntry? StringEntries(int j) { int o = __p.__offset(26); return o != 0 ? (StringEntry?)(new StringEntry()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int StringEntriesLength { get { int o = __p.__offset(26); return o != 0 ? __p.__vector_len(o) : 0; } }
  public EnumEntry? EnumEntries(int j) { int o = __p.__offset(28); return o != 0 ? (EnumEntry?)(new EnumEntry()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int EnumEntriesLength { get { int o = __p.__offset(28); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<MasterDict> CreateMasterDict(FlatBufferBuilder builder,
      VectorOffset ubyteEntriesOffset = default(VectorOffset),
      VectorOffset byteEntriesOffset = default(VectorOffset),
      VectorOffset boolEntriesOffset = default(VectorOffset),
      VectorOffset shortEntriesOffset = default(VectorOffset),
      VectorOffset ushortEntriesOffset = default(VectorOffset),
      VectorOffset intEntriesOffset = default(VectorOffset),
      VectorOffset uintEntriesOffset = default(VectorOffset),
      VectorOffset floatEntriesOffset = default(VectorOffset),
      VectorOffset longEntriesOffset = default(VectorOffset),
      VectorOffset ulongEntriesOffset = default(VectorOffset),
      VectorOffset doubleEntriesOffset = default(VectorOffset),
      VectorOffset stringEntriesOffset = default(VectorOffset),
      VectorOffset enumEntriesOffset = default(VectorOffset)) {
    builder.StartObject(13);
    MasterDict.AddEnumEntries(builder, enumEntriesOffset);
    MasterDict.AddStringEntries(builder, stringEntriesOffset);
    MasterDict.AddDoubleEntries(builder, doubleEntriesOffset);
    MasterDict.AddUlongEntries(builder, ulongEntriesOffset);
    MasterDict.AddLongEntries(builder, longEntriesOffset);
    MasterDict.AddFloatEntries(builder, floatEntriesOffset);
    MasterDict.AddUintEntries(builder, uintEntriesOffset);
    MasterDict.AddIntEntries(builder, intEntriesOffset);
    MasterDict.AddUshortEntries(builder, ushortEntriesOffset);
    MasterDict.AddShortEntries(builder, shortEntriesOffset);
    MasterDict.AddBoolEntries(builder, boolEntriesOffset);
    MasterDict.AddByteEntries(builder, byteEntriesOffset);
    MasterDict.AddUbyteEntries(builder, ubyteEntriesOffset);
    return MasterDict.EndMasterDict(builder);
  }

  public static void StartMasterDict(FlatBufferBuilder builder) { builder.StartObject(13); }
  public static void AddUbyteEntries(FlatBufferBuilder builder, VectorOffset ubyteEntriesOffset) { builder.AddOffset(0, ubyteEntriesOffset.Value, 0); }
  public static VectorOffset CreateUbyteEntriesVector(FlatBufferBuilder builder, Offset<UByteEntry>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static void StartUbyteEntriesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddByteEntries(FlatBufferBuilder builder, VectorOffset byteEntriesOffset) { builder.AddOffset(1, byteEntriesOffset.Value, 0); }
  public static VectorOffset CreateByteEntriesVector(FlatBufferBuilder builder, Offset<ByteEntry>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static void StartByteEntriesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddBoolEntries(FlatBufferBuilder builder, VectorOffset boolEntriesOffset) { builder.AddOffset(2, boolEntriesOffset.Value, 0); }
  public static VectorOffset CreateBoolEntriesVector(FlatBufferBuilder builder, Offset<BoolEntry>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static void StartBoolEntriesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddShortEntries(FlatBufferBuilder builder, VectorOffset shortEntriesOffset) { builder.AddOffset(3, shortEntriesOffset.Value, 0); }
  public static VectorOffset CreateShortEntriesVector(FlatBufferBuilder builder, Offset<ShortEntry>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static void StartShortEntriesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddUshortEntries(FlatBufferBuilder builder, VectorOffset ushortEntriesOffset) { builder.AddOffset(4, ushortEntriesOffset.Value, 0); }
  public static VectorOffset CreateUshortEntriesVector(FlatBufferBuilder builder, Offset<UShortEntry>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static void StartUshortEntriesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddIntEntries(FlatBufferBuilder builder, VectorOffset intEntriesOffset) { builder.AddOffset(5, intEntriesOffset.Value, 0); }
  public static VectorOffset CreateIntEntriesVector(FlatBufferBuilder builder, Offset<IntEntry>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static void StartIntEntriesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddUintEntries(FlatBufferBuilder builder, VectorOffset uintEntriesOffset) { builder.AddOffset(6, uintEntriesOffset.Value, 0); }
  public static VectorOffset CreateUintEntriesVector(FlatBufferBuilder builder, Offset<UIntEntry>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static void StartUintEntriesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddFloatEntries(FlatBufferBuilder builder, VectorOffset floatEntriesOffset) { builder.AddOffset(7, floatEntriesOffset.Value, 0); }
  public static VectorOffset CreateFloatEntriesVector(FlatBufferBuilder builder, Offset<FloatEntry>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static void StartFloatEntriesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddLongEntries(FlatBufferBuilder builder, VectorOffset longEntriesOffset) { builder.AddOffset(8, longEntriesOffset.Value, 0); }
  public static VectorOffset CreateLongEntriesVector(FlatBufferBuilder builder, Offset<LongEntry>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static void StartLongEntriesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddUlongEntries(FlatBufferBuilder builder, VectorOffset ulongEntriesOffset) { builder.AddOffset(9, ulongEntriesOffset.Value, 0); }
  public static VectorOffset CreateUlongEntriesVector(FlatBufferBuilder builder, Offset<ULongEntry>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static void StartUlongEntriesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddDoubleEntries(FlatBufferBuilder builder, VectorOffset doubleEntriesOffset) { builder.AddOffset(10, doubleEntriesOffset.Value, 0); }
  public static VectorOffset CreateDoubleEntriesVector(FlatBufferBuilder builder, Offset<DoubleEntry>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static void StartDoubleEntriesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddStringEntries(FlatBufferBuilder builder, VectorOffset stringEntriesOffset) { builder.AddOffset(11, stringEntriesOffset.Value, 0); }
  public static VectorOffset CreateStringEntriesVector(FlatBufferBuilder builder, Offset<StringEntry>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static void StartStringEntriesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddEnumEntries(FlatBufferBuilder builder, VectorOffset enumEntriesOffset) { builder.AddOffset(12, enumEntriesOffset.Value, 0); }
  public static VectorOffset CreateEnumEntriesVector(FlatBufferBuilder builder, Offset<EnumEntry>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static void StartEnumEntriesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<MasterDict> EndMasterDict(FlatBufferBuilder builder) {
    int o = builder.EndObject();
    return new Offset<MasterDict>(o);
  }
  public static void FinishMasterDictBuffer(FlatBufferBuilder builder, Offset<MasterDict> offset) { builder.Finish(offset.Value, "FBMD"); }
};


}
