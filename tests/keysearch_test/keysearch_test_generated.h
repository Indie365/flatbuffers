// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_KEYSEARCHTEST_TESTING_KEYSEARCH_H_
#define FLATBUFFERS_GENERATED_KEYSEARCHTEST_TESTING_KEYSEARCH_H_

#include "flatbuffers/flatbuffers.h"

namespace Testing {
namespace KeySearch {

struct MasterDict;

struct UByteEntry;

struct ByteEntry;

struct BoolEntry;

struct ShortEntry;

struct UShortEntry;

struct IntEntry;

struct UIntEntry;

struct FloatEntry;

struct LongEntry;

struct ULongEntry;

struct DoubleEntry;

struct StringEntry;

struct MasterDict FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UBYTEENTRIES = 4,
    VT_BYTEENTRIES = 6,
    VT_BOOLENTRIES = 8,
    VT_SHORTENTRIES = 10,
    VT_USHORTENTRIES = 12,
    VT_INTENTRIES = 14,
    VT_UINTENTRIES = 16,
    VT_FLOATENTRIES = 18,
    VT_LONGENTRIES = 20,
    VT_ULONGENTRIES = 22,
    VT_DOUBLEENTRIES = 24,
    VT_STRINGENTRIES = 26
  };
  const flatbuffers::Vector<flatbuffers::Offset<UByteEntry>> *ubyteEntries() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UByteEntry>> *>(VT_UBYTEENTRIES); }
  flatbuffers::Vector<flatbuffers::Offset<UByteEntry>> *mutable_ubyteEntries() { return GetPointer<flatbuffers::Vector<flatbuffers::Offset<UByteEntry>> *>(VT_UBYTEENTRIES); }
  const flatbuffers::Vector<flatbuffers::Offset<ByteEntry>> *byteEntries() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ByteEntry>> *>(VT_BYTEENTRIES); }
  flatbuffers::Vector<flatbuffers::Offset<ByteEntry>> *mutable_byteEntries() { return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ByteEntry>> *>(VT_BYTEENTRIES); }
  const flatbuffers::Vector<flatbuffers::Offset<BoolEntry>> *boolEntries() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BoolEntry>> *>(VT_BOOLENTRIES); }
  flatbuffers::Vector<flatbuffers::Offset<BoolEntry>> *mutable_boolEntries() { return GetPointer<flatbuffers::Vector<flatbuffers::Offset<BoolEntry>> *>(VT_BOOLENTRIES); }
  const flatbuffers::Vector<flatbuffers::Offset<ShortEntry>> *shortEntries() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShortEntry>> *>(VT_SHORTENTRIES); }
  flatbuffers::Vector<flatbuffers::Offset<ShortEntry>> *mutable_shortEntries() { return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ShortEntry>> *>(VT_SHORTENTRIES); }
  const flatbuffers::Vector<flatbuffers::Offset<UShortEntry>> *ushortEntries() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UShortEntry>> *>(VT_USHORTENTRIES); }
  flatbuffers::Vector<flatbuffers::Offset<UShortEntry>> *mutable_ushortEntries() { return GetPointer<flatbuffers::Vector<flatbuffers::Offset<UShortEntry>> *>(VT_USHORTENTRIES); }
  const flatbuffers::Vector<flatbuffers::Offset<IntEntry>> *intEntries() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<IntEntry>> *>(VT_INTENTRIES); }
  flatbuffers::Vector<flatbuffers::Offset<IntEntry>> *mutable_intEntries() { return GetPointer<flatbuffers::Vector<flatbuffers::Offset<IntEntry>> *>(VT_INTENTRIES); }
  const flatbuffers::Vector<flatbuffers::Offset<UIntEntry>> *uintEntries() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UIntEntry>> *>(VT_UINTENTRIES); }
  flatbuffers::Vector<flatbuffers::Offset<UIntEntry>> *mutable_uintEntries() { return GetPointer<flatbuffers::Vector<flatbuffers::Offset<UIntEntry>> *>(VT_UINTENTRIES); }
  const flatbuffers::Vector<flatbuffers::Offset<FloatEntry>> *floatEntries() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FloatEntry>> *>(VT_FLOATENTRIES); }
  flatbuffers::Vector<flatbuffers::Offset<FloatEntry>> *mutable_floatEntries() { return GetPointer<flatbuffers::Vector<flatbuffers::Offset<FloatEntry>> *>(VT_FLOATENTRIES); }
  const flatbuffers::Vector<flatbuffers::Offset<LongEntry>> *longEntries() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LongEntry>> *>(VT_LONGENTRIES); }
  flatbuffers::Vector<flatbuffers::Offset<LongEntry>> *mutable_longEntries() { return GetPointer<flatbuffers::Vector<flatbuffers::Offset<LongEntry>> *>(VT_LONGENTRIES); }
  const flatbuffers::Vector<flatbuffers::Offset<ULongEntry>> *ulongEntries() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ULongEntry>> *>(VT_ULONGENTRIES); }
  flatbuffers::Vector<flatbuffers::Offset<ULongEntry>> *mutable_ulongEntries() { return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ULongEntry>> *>(VT_ULONGENTRIES); }
  const flatbuffers::Vector<flatbuffers::Offset<DoubleEntry>> *doubleEntries() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DoubleEntry>> *>(VT_DOUBLEENTRIES); }
  flatbuffers::Vector<flatbuffers::Offset<DoubleEntry>> *mutable_doubleEntries() { return GetPointer<flatbuffers::Vector<flatbuffers::Offset<DoubleEntry>> *>(VT_DOUBLEENTRIES); }
  const flatbuffers::Vector<flatbuffers::Offset<StringEntry>> *stringEntries() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StringEntry>> *>(VT_STRINGENTRIES); }
  flatbuffers::Vector<flatbuffers::Offset<StringEntry>> *mutable_stringEntries() { return GetPointer<flatbuffers::Vector<flatbuffers::Offset<StringEntry>> *>(VT_STRINGENTRIES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UBYTEENTRIES) &&
           verifier.Verify(ubyteEntries()) &&
           verifier.VerifyVectorOfTables(ubyteEntries()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BYTEENTRIES) &&
           verifier.Verify(byteEntries()) &&
           verifier.VerifyVectorOfTables(byteEntries()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BOOLENTRIES) &&
           verifier.Verify(boolEntries()) &&
           verifier.VerifyVectorOfTables(boolEntries()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SHORTENTRIES) &&
           verifier.Verify(shortEntries()) &&
           verifier.VerifyVectorOfTables(shortEntries()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_USHORTENTRIES) &&
           verifier.Verify(ushortEntries()) &&
           verifier.VerifyVectorOfTables(ushortEntries()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_INTENTRIES) &&
           verifier.Verify(intEntries()) &&
           verifier.VerifyVectorOfTables(intEntries()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UINTENTRIES) &&
           verifier.Verify(uintEntries()) &&
           verifier.VerifyVectorOfTables(uintEntries()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FLOATENTRIES) &&
           verifier.Verify(floatEntries()) &&
           verifier.VerifyVectorOfTables(floatEntries()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LONGENTRIES) &&
           verifier.Verify(longEntries()) &&
           verifier.VerifyVectorOfTables(longEntries()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ULONGENTRIES) &&
           verifier.Verify(ulongEntries()) &&
           verifier.VerifyVectorOfTables(ulongEntries()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DOUBLEENTRIES) &&
           verifier.Verify(doubleEntries()) &&
           verifier.VerifyVectorOfTables(doubleEntries()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_STRINGENTRIES) &&
           verifier.Verify(stringEntries()) &&
           verifier.VerifyVectorOfTables(stringEntries()) &&
           verifier.EndTable();
  }
};

struct MasterDictBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ubyteEntries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UByteEntry>>> ubyteEntries) { fbb_.AddOffset(MasterDict::VT_UBYTEENTRIES, ubyteEntries); }
  void add_byteEntries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ByteEntry>>> byteEntries) { fbb_.AddOffset(MasterDict::VT_BYTEENTRIES, byteEntries); }
  void add_boolEntries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BoolEntry>>> boolEntries) { fbb_.AddOffset(MasterDict::VT_BOOLENTRIES, boolEntries); }
  void add_shortEntries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShortEntry>>> shortEntries) { fbb_.AddOffset(MasterDict::VT_SHORTENTRIES, shortEntries); }
  void add_ushortEntries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UShortEntry>>> ushortEntries) { fbb_.AddOffset(MasterDict::VT_USHORTENTRIES, ushortEntries); }
  void add_intEntries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<IntEntry>>> intEntries) { fbb_.AddOffset(MasterDict::VT_INTENTRIES, intEntries); }
  void add_uintEntries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UIntEntry>>> uintEntries) { fbb_.AddOffset(MasterDict::VT_UINTENTRIES, uintEntries); }
  void add_floatEntries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FloatEntry>>> floatEntries) { fbb_.AddOffset(MasterDict::VT_FLOATENTRIES, floatEntries); }
  void add_longEntries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LongEntry>>> longEntries) { fbb_.AddOffset(MasterDict::VT_LONGENTRIES, longEntries); }
  void add_ulongEntries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ULongEntry>>> ulongEntries) { fbb_.AddOffset(MasterDict::VT_ULONGENTRIES, ulongEntries); }
  void add_doubleEntries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DoubleEntry>>> doubleEntries) { fbb_.AddOffset(MasterDict::VT_DOUBLEENTRIES, doubleEntries); }
  void add_stringEntries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringEntry>>> stringEntries) { fbb_.AddOffset(MasterDict::VT_STRINGENTRIES, stringEntries); }
  MasterDictBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MasterDictBuilder &operator=(const MasterDictBuilder &);
  flatbuffers::Offset<MasterDict> Finish() {
    auto o = flatbuffers::Offset<MasterDict>(fbb_.EndTable(start_, 12));
    return o;
  }
};

inline flatbuffers::Offset<MasterDict> CreateMasterDict(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UByteEntry>>> ubyteEntries = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ByteEntry>>> byteEntries = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BoolEntry>>> boolEntries = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShortEntry>>> shortEntries = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UShortEntry>>> ushortEntries = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<IntEntry>>> intEntries = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UIntEntry>>> uintEntries = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FloatEntry>>> floatEntries = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LongEntry>>> longEntries = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ULongEntry>>> ulongEntries = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DoubleEntry>>> doubleEntries = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringEntry>>> stringEntries = 0) {
  MasterDictBuilder builder_(_fbb);
  builder_.add_stringEntries(stringEntries);
  builder_.add_doubleEntries(doubleEntries);
  builder_.add_ulongEntries(ulongEntries);
  builder_.add_longEntries(longEntries);
  builder_.add_floatEntries(floatEntries);
  builder_.add_uintEntries(uintEntries);
  builder_.add_intEntries(intEntries);
  builder_.add_ushortEntries(ushortEntries);
  builder_.add_shortEntries(shortEntries);
  builder_.add_boolEntries(boolEntries);
  builder_.add_byteEntries(byteEntries);
  builder_.add_ubyteEntries(ubyteEntries);
  return builder_.Finish();
}

inline flatbuffers::Offset<MasterDict> CreateMasterDictDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<UByteEntry>> *ubyteEntries = nullptr,
    const std::vector<flatbuffers::Offset<ByteEntry>> *byteEntries = nullptr,
    const std::vector<flatbuffers::Offset<BoolEntry>> *boolEntries = nullptr,
    const std::vector<flatbuffers::Offset<ShortEntry>> *shortEntries = nullptr,
    const std::vector<flatbuffers::Offset<UShortEntry>> *ushortEntries = nullptr,
    const std::vector<flatbuffers::Offset<IntEntry>> *intEntries = nullptr,
    const std::vector<flatbuffers::Offset<UIntEntry>> *uintEntries = nullptr,
    const std::vector<flatbuffers::Offset<FloatEntry>> *floatEntries = nullptr,
    const std::vector<flatbuffers::Offset<LongEntry>> *longEntries = nullptr,
    const std::vector<flatbuffers::Offset<ULongEntry>> *ulongEntries = nullptr,
    const std::vector<flatbuffers::Offset<DoubleEntry>> *doubleEntries = nullptr,
    const std::vector<flatbuffers::Offset<StringEntry>> *stringEntries = nullptr) {
  return CreateMasterDict(_fbb, ubyteEntries ? _fbb.CreateVector<flatbuffers::Offset<UByteEntry>>(*ubyteEntries) : 0, byteEntries ? _fbb.CreateVector<flatbuffers::Offset<ByteEntry>>(*byteEntries) : 0, boolEntries ? _fbb.CreateVector<flatbuffers::Offset<BoolEntry>>(*boolEntries) : 0, shortEntries ? _fbb.CreateVector<flatbuffers::Offset<ShortEntry>>(*shortEntries) : 0, ushortEntries ? _fbb.CreateVector<flatbuffers::Offset<UShortEntry>>(*ushortEntries) : 0, intEntries ? _fbb.CreateVector<flatbuffers::Offset<IntEntry>>(*intEntries) : 0, uintEntries ? _fbb.CreateVector<flatbuffers::Offset<UIntEntry>>(*uintEntries) : 0, floatEntries ? _fbb.CreateVector<flatbuffers::Offset<FloatEntry>>(*floatEntries) : 0, longEntries ? _fbb.CreateVector<flatbuffers::Offset<LongEntry>>(*longEntries) : 0, ulongEntries ? _fbb.CreateVector<flatbuffers::Offset<ULongEntry>>(*ulongEntries) : 0, doubleEntries ? _fbb.CreateVector<flatbuffers::Offset<DoubleEntry>>(*doubleEntries) : 0, stringEntries ? _fbb.CreateVector<flatbuffers::Offset<StringEntry>>(*stringEntries) : 0);
}

struct UByteEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  uint8_t key() const { return GetField<uint8_t>(VT_KEY, 0); }
  bool mutate_key(uint8_t _key) { return SetField(VT_KEY, _key); }
  bool KeyCompareLessThan(const UByteEntry *o) const { return key() < o->key(); }
  int KeyCompareWithValue(uint8_t val) const { return key() < val ? -1 : key() > val; }
  uint8_t value() const { return GetField<uint8_t>(VT_VALUE, 255); }
  bool mutate_value(uint8_t _value) { return SetField(VT_VALUE, _value); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEY) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct UByteEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(uint8_t key) { fbb_.AddElement<uint8_t>(UByteEntry::VT_KEY, key, 0); }
  void add_value(uint8_t value) { fbb_.AddElement<uint8_t>(UByteEntry::VT_VALUE, value, 255); }
  UByteEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  UByteEntryBuilder &operator=(const UByteEntryBuilder &);
  flatbuffers::Offset<UByteEntry> Finish() {
    auto o = flatbuffers::Offset<UByteEntry>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<UByteEntry> CreateUByteEntry(flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t key = 0,
    uint8_t value = 255) {
  UByteEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct ByteEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  int8_t key() const { return GetField<int8_t>(VT_KEY, 0); }
  bool mutate_key(int8_t _key) { return SetField(VT_KEY, _key); }
  bool KeyCompareLessThan(const ByteEntry *o) const { return key() < o->key(); }
  int KeyCompareWithValue(int8_t val) const { return key() < val ? -1 : key() > val; }
  int8_t value() const { return GetField<int8_t>(VT_VALUE, -128); }
  bool mutate_value(int8_t _value) { return SetField(VT_VALUE, _value); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_KEY) &&
           VerifyField<int8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ByteEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(int8_t key) { fbb_.AddElement<int8_t>(ByteEntry::VT_KEY, key, 0); }
  void add_value(int8_t value) { fbb_.AddElement<int8_t>(ByteEntry::VT_VALUE, value, -128); }
  ByteEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ByteEntryBuilder &operator=(const ByteEntryBuilder &);
  flatbuffers::Offset<ByteEntry> Finish() {
    auto o = flatbuffers::Offset<ByteEntry>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<ByteEntry> CreateByteEntry(flatbuffers::FlatBufferBuilder &_fbb,
    int8_t key = 0,
    int8_t value = -128) {
  ByteEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct BoolEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  bool key() const { return GetField<uint8_t>(VT_KEY, 0) != 0; }
  bool mutate_key(bool _key) { return SetField(VT_KEY, static_cast<uint8_t>(_key)); }
  bool KeyCompareLessThan(const BoolEntry *o) const { return key() < o->key(); }
  int KeyCompareWithValue(uint8_t val) const { return key() < val ? -1 : key() > val; }
  bool value() const { return GetField<uint8_t>(VT_VALUE, 1) != 0; }
  bool mutate_value(bool _value) { return SetField(VT_VALUE, static_cast<uint8_t>(_value)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEY) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct BoolEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(bool key) { fbb_.AddElement<uint8_t>(BoolEntry::VT_KEY, static_cast<uint8_t>(key), 0); }
  void add_value(bool value) { fbb_.AddElement<uint8_t>(BoolEntry::VT_VALUE, static_cast<uint8_t>(value), 1); }
  BoolEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BoolEntryBuilder &operator=(const BoolEntryBuilder &);
  flatbuffers::Offset<BoolEntry> Finish() {
    auto o = flatbuffers::Offset<BoolEntry>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<BoolEntry> CreateBoolEntry(flatbuffers::FlatBufferBuilder &_fbb,
    bool key = false,
    bool value = true) {
  BoolEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct ShortEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  int16_t key() const { return GetField<int16_t>(VT_KEY, 0); }
  bool mutate_key(int16_t _key) { return SetField(VT_KEY, _key); }
  bool KeyCompareLessThan(const ShortEntry *o) const { return key() < o->key(); }
  int KeyCompareWithValue(int16_t val) const { return key() < val ? -1 : key() > val; }
  int16_t value() const { return GetField<int16_t>(VT_VALUE, -32768); }
  bool mutate_value(int16_t _value) { return SetField(VT_VALUE, _value); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_KEY) &&
           VerifyField<int16_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ShortEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(int16_t key) { fbb_.AddElement<int16_t>(ShortEntry::VT_KEY, key, 0); }
  void add_value(int16_t value) { fbb_.AddElement<int16_t>(ShortEntry::VT_VALUE, value, -32768); }
  ShortEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ShortEntryBuilder &operator=(const ShortEntryBuilder &);
  flatbuffers::Offset<ShortEntry> Finish() {
    auto o = flatbuffers::Offset<ShortEntry>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<ShortEntry> CreateShortEntry(flatbuffers::FlatBufferBuilder &_fbb,
    int16_t key = 0,
    int16_t value = -32768) {
  ShortEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct UShortEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  uint16_t key() const { return GetField<uint16_t>(VT_KEY, 0); }
  bool mutate_key(uint16_t _key) { return SetField(VT_KEY, _key); }
  bool KeyCompareLessThan(const UShortEntry *o) const { return key() < o->key(); }
  int KeyCompareWithValue(uint16_t val) const { return key() < val ? -1 : key() > val; }
  uint16_t value() const { return GetField<uint16_t>(VT_VALUE, 65535); }
  bool mutate_value(uint16_t _value) { return SetField(VT_VALUE, _value); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_KEY) &&
           VerifyField<uint16_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct UShortEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(uint16_t key) { fbb_.AddElement<uint16_t>(UShortEntry::VT_KEY, key, 0); }
  void add_value(uint16_t value) { fbb_.AddElement<uint16_t>(UShortEntry::VT_VALUE, value, 65535); }
  UShortEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  UShortEntryBuilder &operator=(const UShortEntryBuilder &);
  flatbuffers::Offset<UShortEntry> Finish() {
    auto o = flatbuffers::Offset<UShortEntry>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<UShortEntry> CreateUShortEntry(flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t key = 0,
    uint16_t value = 65535) {
  UShortEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct IntEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  int32_t key() const { return GetField<int32_t>(VT_KEY, 0); }
  bool mutate_key(int32_t _key) { return SetField(VT_KEY, _key); }
  bool KeyCompareLessThan(const IntEntry *o) const { return key() < o->key(); }
  int KeyCompareWithValue(int32_t val) const { return key() < val ? -1 : key() > val; }
  int32_t value() const { return GetField<int32_t>(VT_VALUE, -2147483648); }
  bool mutate_value(int32_t _value) { return SetField(VT_VALUE, _value); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KEY) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct IntEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(int32_t key) { fbb_.AddElement<int32_t>(IntEntry::VT_KEY, key, 0); }
  void add_value(int32_t value) { fbb_.AddElement<int32_t>(IntEntry::VT_VALUE, value, -2147483648); }
  IntEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  IntEntryBuilder &operator=(const IntEntryBuilder &);
  flatbuffers::Offset<IntEntry> Finish() {
    auto o = flatbuffers::Offset<IntEntry>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<IntEntry> CreateIntEntry(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t key = 0,
    int32_t value = -2147483648) {
  IntEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct UIntEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  uint32_t key() const { return GetField<uint32_t>(VT_KEY, 0); }
  bool mutate_key(uint32_t _key) { return SetField(VT_KEY, _key); }
  bool KeyCompareLessThan(const UIntEntry *o) const { return key() < o->key(); }
  int KeyCompareWithValue(uint32_t val) const { return key() < val ? -1 : key() > val; }
  uint32_t value() const { return GetField<uint32_t>(VT_VALUE, 4294967295); }
  bool mutate_value(uint32_t _value) { return SetField(VT_VALUE, _value); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_KEY) &&
           VerifyField<uint32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct UIntEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(uint32_t key) { fbb_.AddElement<uint32_t>(UIntEntry::VT_KEY, key, 0); }
  void add_value(uint32_t value) { fbb_.AddElement<uint32_t>(UIntEntry::VT_VALUE, value, 4294967295); }
  UIntEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  UIntEntryBuilder &operator=(const UIntEntryBuilder &);
  flatbuffers::Offset<UIntEntry> Finish() {
    auto o = flatbuffers::Offset<UIntEntry>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<UIntEntry> CreateUIntEntry(flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t key = 0,
    uint32_t value = 4294967295) {
  UIntEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct FloatEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  float key() const { return GetField<float>(VT_KEY, 0.0f); }
  bool mutate_key(float _key) { return SetField(VT_KEY, _key); }
  bool KeyCompareLessThan(const FloatEntry *o) const { return key() < o->key(); }
  int KeyCompareWithValue(float val) const { return key() < val ? -1 : key() > val; }
  float value() const { return GetField<float>(VT_VALUE, 1234.0f); }
  bool mutate_value(float _value) { return SetField(VT_VALUE, _value); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_KEY) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct FloatEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(float key) { fbb_.AddElement<float>(FloatEntry::VT_KEY, key, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(FloatEntry::VT_VALUE, value, 1234.0f); }
  FloatEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FloatEntryBuilder &operator=(const FloatEntryBuilder &);
  flatbuffers::Offset<FloatEntry> Finish() {
    auto o = flatbuffers::Offset<FloatEntry>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<FloatEntry> CreateFloatEntry(flatbuffers::FlatBufferBuilder &_fbb,
    float key = 0.0f,
    float value = 1234.0f) {
  FloatEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct LongEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  int64_t key() const { return GetField<int64_t>(VT_KEY, 0); }
  bool mutate_key(int64_t _key) { return SetField(VT_KEY, _key); }
  bool KeyCompareLessThan(const LongEntry *o) const { return key() < o->key(); }
  int KeyCompareWithValue(int64_t val) const { return key() < val ? -1 : key() > val; }
  int64_t value() const { return GetField<int64_t>(VT_VALUE, -9223372036854775808); }
  bool mutate_value(int64_t _value) { return SetField(VT_VALUE, _value); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_KEY) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct LongEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(int64_t key) { fbb_.AddElement<int64_t>(LongEntry::VT_KEY, key, 0); }
  void add_value(int64_t value) { fbb_.AddElement<int64_t>(LongEntry::VT_VALUE, value, -9223372036854775808); }
  LongEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LongEntryBuilder &operator=(const LongEntryBuilder &);
  flatbuffers::Offset<LongEntry> Finish() {
    auto o = flatbuffers::Offset<LongEntry>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<LongEntry> CreateLongEntry(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t key = 0,
    int64_t value = -9223372036854775808) {
  LongEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct ULongEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  uint64_t key() const { return GetField<uint64_t>(VT_KEY, 0); }
  bool mutate_key(uint64_t _key) { return SetField(VT_KEY, _key); }
  bool KeyCompareLessThan(const ULongEntry *o) const { return key() < o->key(); }
  int KeyCompareWithValue(uint64_t val) const { return key() < val ? -1 : key() > val; }
  uint64_t value() const { return GetField<uint64_t>(VT_VALUE, 9223372036854775807); }
  bool mutate_value(uint64_t _value) { return SetField(VT_VALUE, _value); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_KEY) &&
           VerifyField<uint64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ULongEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(uint64_t key) { fbb_.AddElement<uint64_t>(ULongEntry::VT_KEY, key, 0); }
  void add_value(uint64_t value) { fbb_.AddElement<uint64_t>(ULongEntry::VT_VALUE, value, 9223372036854775807); }
  ULongEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ULongEntryBuilder &operator=(const ULongEntryBuilder &);
  flatbuffers::Offset<ULongEntry> Finish() {
    auto o = flatbuffers::Offset<ULongEntry>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<ULongEntry> CreateULongEntry(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t key = 0,
    uint64_t value = 9223372036854775807) {
  ULongEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct DoubleEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  double key() const { return GetField<double>(VT_KEY, 0.0); }
  bool mutate_key(double _key) { return SetField(VT_KEY, _key); }
  bool KeyCompareLessThan(const DoubleEntry *o) const { return key() < o->key(); }
  int KeyCompareWithValue(double val) const { return key() < val ? -1 : key() > val; }
  double value() const { return GetField<double>(VT_VALUE, 4567.0); }
  bool mutate_value(double _value) { return SetField(VT_VALUE, _value); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_KEY) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DoubleEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(double key) { fbb_.AddElement<double>(DoubleEntry::VT_KEY, key, 0.0); }
  void add_value(double value) { fbb_.AddElement<double>(DoubleEntry::VT_VALUE, value, 4567.0); }
  DoubleEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DoubleEntryBuilder &operator=(const DoubleEntryBuilder &);
  flatbuffers::Offset<DoubleEntry> Finish() {
    auto o = flatbuffers::Offset<DoubleEntry>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<DoubleEntry> CreateDoubleEntry(flatbuffers::FlatBufferBuilder &_fbb,
    double key = 0.0,
    double value = 4567.0) {
  DoubleEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct StringEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const { return GetPointer<const flatbuffers::String *>(VT_KEY); }
  flatbuffers::String *mutable_key() { return GetPointer<flatbuffers::String *>(VT_KEY); }
  bool KeyCompareLessThan(const StringEntry *o) const { return *key() < *o->key(); }
  int KeyCompareWithValue(const char *val) const { return strcmp(key()->c_str(), val); }
  int32_t value() const { return GetField<int32_t>(VT_VALUE, 7890); }
  bool mutate_value(int32_t _value) { return SetField(VT_VALUE, _value); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_KEY) &&
           verifier.Verify(key()) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct StringEntryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) { fbb_.AddOffset(StringEntry::VT_KEY, key); }
  void add_value(int32_t value) { fbb_.AddElement<int32_t>(StringEntry::VT_VALUE, value, 7890); }
  StringEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  StringEntryBuilder &operator=(const StringEntryBuilder &);
  flatbuffers::Offset<StringEntry> Finish() {
    auto o = flatbuffers::Offset<StringEntry>(fbb_.EndTable(start_, 2));
    fbb_.Required(o, StringEntry::VT_KEY);  // key
    return o;
  }
};

inline flatbuffers::Offset<StringEntry> CreateStringEntry(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    int32_t value = 7890) {
  StringEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringEntry> CreateStringEntryDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    int32_t value = 7890) {
  return CreateStringEntry(_fbb, key ? _fbb.CreateString(key) : 0, value);
}

inline const Testing::KeySearch::MasterDict *GetMasterDict(const void *buf) { return flatbuffers::GetRoot<Testing::KeySearch::MasterDict>(buf); }

inline MasterDict *GetMutableMasterDict(void *buf) { return flatbuffers::GetMutableRoot<MasterDict>(buf); }

inline const char *MasterDictIdentifier() { return "FBMD"; }

inline bool MasterDictBufferHasIdentifier(const void *buf) { return flatbuffers::BufferHasIdentifier(buf, MasterDictIdentifier()); }

inline bool VerifyMasterDictBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<Testing::KeySearch::MasterDict>(MasterDictIdentifier()); }

inline const char *MasterDictExtension() { return "mdict"; }

inline void FinishMasterDictBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<Testing::KeySearch::MasterDict> root) { fbb.Finish(root, MasterDictIdentifier()); }

}  // namespace KeySearch
}  // namespace Testing

#endif  // FLATBUFFERS_GENERATED_KEYSEARCHTEST_TESTING_KEYSEARCH_H_
