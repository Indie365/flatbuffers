// automatically generated by the FlatBuffers compiler, do not modify

/**
 * @enum {number}
 */
export enum Character{
  NONE= 0,
  MuLan= 1,
  Rapunzel= 2,
  Belle= 3,
  BookFan= 4,
  Other= 5,
  Unused= 6
};

export type ValidCharacterType = Attacker|BookReader|Rapunzel|string;

export function unionToCharacter(
  type: Character,
  accessor: (obj:ValidCharacterType) => ValidCharacterType|null
): ValidCharacterType|null {
  switch(Character[type]) {
    case 'NONE': return null; 
    case 'MuLan': return accessor(new Attacker())! as Attacker;
    case 'Rapunzel': return accessor(new Rapunzel())! as Rapunzel;
    case 'Belle': return accessor(new BookReader())! as BookReader;
    case 'BookFan': return accessor(new BookReader())! as BookReader;
    case 'Other': return accessor('') as string;
    case 'Unused': return accessor('') as string;
    default: return null;
  }
}

export function unionListToCharacter(
  type: Character, 
  accessor: (index: number, obj:ValidCharacterType) => ValidCharacterType|null, 
  index: number
): ValidCharacterType|null {
  switch(Character[type]) {
    case 'NONE': return null; 
    case 'MuLan': return accessor(index, new Attacker())! as Attacker;
    case 'Rapunzel': return accessor(index, new Rapunzel())! as Rapunzel;
    case 'Belle': return accessor(index, new BookReader())! as BookReader;
    case 'BookFan': return accessor(index, new BookReader())! as BookReader;
    case 'Other': return accessor(index, '') as string;
    case 'Unused': return accessor(index, '') as string;
    default: return null;
  }
}

/**
 * @enum {number}
 */
export enum StringOnlyCharacter{
  NONE= 0,
  Mickey= 1,
  Goofy= 2,
  Pluto= 3
};

export type ValidStringOnlyCharacterType = string;

export function unionToStringOnlyCharacter(
  type: StringOnlyCharacter,
  accessor: (obj:ValidStringOnlyCharacterType) => ValidStringOnlyCharacterType|null
): ValidStringOnlyCharacterType|null {
  switch(StringOnlyCharacter[type]) {
    case 'NONE': return null; 
    case 'Mickey': return accessor('') as string;
    case 'Goofy': return accessor('') as string;
    case 'Pluto': return accessor('') as string;
    default: return null;
  }
}

export function unionListToStringOnlyCharacter(
  type: StringOnlyCharacter, 
  accessor: (index: number, obj:ValidStringOnlyCharacterType) => ValidStringOnlyCharacterType|null, 
  index: number
): ValidStringOnlyCharacterType|null {
  switch(StringOnlyCharacter[type]) {
    case 'NONE': return null; 
    case 'Mickey': return accessor(index, '') as string;
    case 'Goofy': return accessor(index, '') as string;
    case 'Pluto': return accessor(index, '') as string;
    default: return null;
  }
}

/**
 * @constructor
 */
export class Attacker {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Attacker
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Attacker {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Attacker= obj
 * @returns Attacker
 */
static getRootAsAttacker(bb:flatbuffers.ByteBuffer, obj?:Attacker):Attacker {
  return (obj || new Attacker()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Attacker= obj
 * @returns Attacker
 */
static getSizePrefixedRootAsAttacker(bb:flatbuffers.ByteBuffer, obj?:Attacker):Attacker {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Attacker()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @returns number
 */
swordAttackDamage():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * @param number value
 * @returns boolean
 */
mutate_sword_attack_damage(value:number):boolean {
  var offset = this.bb!.__offset(this.bb_pos, 4);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt32(this.bb_pos + offset, value);
  return true;
};

/**
 * @param flatbuffers.Builder builder
 */
static startAttacker(builder:flatbuffers.Builder) {
  builder.startObject(1);
};

/**
 * @param flatbuffers.Builder builder
 * @param number swordAttackDamage
 */
static addSwordAttackDamage(builder:flatbuffers.Builder, swordAttackDamage:number) {
  builder.addFieldInt32(0, swordAttackDamage, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endAttacker(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createAttacker(builder:flatbuffers.Builder, swordAttackDamage:number):flatbuffers.Offset {
  Attacker.startAttacker(builder);
  Attacker.addSwordAttackDamage(builder, swordAttackDamage);
  return Attacker.endAttacker(builder);
}

/**
 * @returns AttackerT
 */
unpack(): AttackerT {
  return new AttackerT(
    this.swordAttackDamage()
  );
};

/**
 * @param AttackerT _o
 */
unpackTo(_o: AttackerT): void {
  _o.swordAttackDamage = this.swordAttackDamage();
};
}

export class AttackerT {
/**
 * @constructor
 * @param number swordAttackDamage
 */
constructor(
  public swordAttackDamage: number = 0
){};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return Attacker.createAttacker(builder,
    this.swordAttackDamage
  );
};
}
/**
 * @constructor
 */
export class Rapunzel {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Rapunzel
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Rapunzel {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @returns number
 */
hairLength():number {
  return this.bb!.readInt32(this.bb_pos);
};

/**
 * @param number value
 * @returns boolean
 */
mutate_hair_length(value:number):boolean {
  var offset = this.bb!.__offset(this.bb_pos, 0);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt32(this.bb_pos + offset, value);
  return true;
};

/**
 * @param flatbuffers.Builder builder
 * @param number hair_length
 * @returns flatbuffers.Offset
 */
static createRapunzel(builder:flatbuffers.Builder, hair_length: number):flatbuffers.Offset {
  builder.prep(4, 4);
  builder.writeInt32(hair_length);
  return builder.offset();
};


/**
 * @returns RapunzelT
 */
unpack(): RapunzelT {
  return new RapunzelT(
    this.hairLength()
  );
};

/**
 * @param RapunzelT _o
 */
unpackTo(_o: RapunzelT): void {
  _o.hairLength = this.hairLength();
};
}

export class RapunzelT {
/**
 * @constructor
 * @param number hairLength
 */
constructor(
  public hairLength: number = 0
){};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return Rapunzel.createRapunzel(builder,
    this.hairLength
  );
};
}
/**
 * @constructor
 */
export class BookReader {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns BookReader
 */
__init(i:number, bb:flatbuffers.ByteBuffer):BookReader {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @returns number
 */
booksRead():number {
  return this.bb!.readInt32(this.bb_pos);
};

/**
 * @param number value
 * @returns boolean
 */
mutate_books_read(value:number):boolean {
  var offset = this.bb!.__offset(this.bb_pos, 0);

  if (offset === 0) {
    return false;
  }

  this.bb!.writeInt32(this.bb_pos + offset, value);
  return true;
};

/**
 * @param flatbuffers.Builder builder
 * @param number books_read
 * @returns flatbuffers.Offset
 */
static createBookReader(builder:flatbuffers.Builder, books_read: number):flatbuffers.Offset {
  builder.prep(4, 4);
  builder.writeInt32(books_read);
  return builder.offset();
};


/**
 * @returns BookReaderT
 */
unpack(): BookReaderT {
  return new BookReaderT(
    this.booksRead()
  );
};

/**
 * @param BookReaderT _o
 */
unpackTo(_o: BookReaderT): void {
  _o.booksRead = this.booksRead();
};
}

export class BookReaderT {
/**
 * @constructor
 * @param number booksRead
 */
constructor(
  public booksRead: number = 0
){};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  return BookReader.createBookReader(builder,
    this.booksRead
  );
};
}
/**
 * @constructor
 */
export class Movie {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Movie
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Movie {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Movie= obj
 * @returns Movie
 */
static getRootAsMovie(bb:flatbuffers.ByteBuffer, obj?:Movie):Movie {
  return (obj || new Movie()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Movie= obj
 * @returns Movie
 */
static getSizePrefixedRootAsMovie(bb:flatbuffers.ByteBuffer, obj?:Movie):Movie {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Movie()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @returns boolean
 */
static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('MOVI');
};

/**
 * @returns Character
 */
mainCharacterType():Character {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? /**  */ (this.bb!.readUint8(this.bb_pos + offset)) : Character.NONE;
};

/**
 * @param flatbuffers.Table obj
 * @returns ?flatbuffers.Table
 */
mainCharacter<T extends flatbuffers.Table>(obj:T|string):T|string|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__union_with_string(obj, this.bb_pos + offset) : null;
};

/**
 * @param number index
 * @returns Character
 */
charactersType(index: number):Character|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? /**  */ (this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index)) : /**  */ (0);
};

/**
 * @returns number
 */
charactersTypeLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Uint8Array
 */
charactersTypeArray():Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param number index
 * @param flatbuffers.Table= obj
 * @returns ?flatbuffers.Table
 */
characters<T extends flatbuffers.Table>(index: number, obj:T|string):T|string|null {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__union_with_string(obj, this.bb!.__vector(this.bb_pos + offset) + index * 4) : null;
};

/**
 * @returns number
 */
charactersLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @param number index
 * @returns StringOnlyCharacter
 */
stringOnlyCharactersType(index: number):StringOnlyCharacter|null {
  var offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? /**  */ (this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index)) : /**  */ (0);
};

/**
 * @returns number
 */
stringOnlyCharactersTypeLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Uint8Array
 */
stringOnlyCharactersTypeArray():Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? new Uint8Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param number index
 * @param flatbuffers.Table= obj
 * @returns ?flatbuffers.Table
 */
stringOnlyCharacters(index: number, obj:string):string|null {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__union_with_string(obj, this.bb!.__vector(this.bb_pos + offset) + index * 4) : null;
};

/**
 * @returns number
 */
stringOnlyCharactersLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startMovie(builder:flatbuffers.Builder) {
  builder.startObject(6);
};

/**
 * @param flatbuffers.Builder builder
 * @param Character mainCharacterType
 */
static addMainCharacterType(builder:flatbuffers.Builder, mainCharacterType:Character) {
  builder.addFieldInt8(0, mainCharacterType, Character.NONE);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset mainCharacterOffset
 */
static addMainCharacter(builder:flatbuffers.Builder, mainCharacterOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, mainCharacterOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset charactersTypeOffset
 */
static addCharactersType(builder:flatbuffers.Builder, charactersTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, charactersTypeOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<Character> data
 * @returns flatbuffers.Offset
 */
static createCharactersTypeVector(builder:flatbuffers.Builder, data:Character[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startCharactersTypeVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset charactersOffset
 */
static addCharacters(builder:flatbuffers.Builder, charactersOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, charactersOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createCharactersVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startCharactersVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset stringOnlyCharactersTypeOffset
 */
static addStringOnlyCharactersType(builder:flatbuffers.Builder, stringOnlyCharactersTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, stringOnlyCharactersTypeOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<StringOnlyCharacter> data
 * @returns flatbuffers.Offset
 */
static createStringOnlyCharactersTypeVector(builder:flatbuffers.Builder, data:StringOnlyCharacter[]):flatbuffers.Offset {
  builder.startVector(1, data.length, 1);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt8(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startStringOnlyCharactersTypeVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(1, numElems, 1);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset stringOnlyCharactersOffset
 */
static addStringOnlyCharacters(builder:flatbuffers.Builder, stringOnlyCharactersOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, stringOnlyCharactersOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createStringOnlyCharactersVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startStringOnlyCharactersVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endMovie(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset offset
 */
static finishMovieBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'MOVI');
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset offset
 */
static finishSizePrefixedMovieBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'MOVI', true);
};

static createMovie(builder:flatbuffers.Builder, mainCharacterType:Character, mainCharacterOffset:flatbuffers.Offset, charactersTypeOffset:flatbuffers.Offset, charactersOffset:flatbuffers.Offset, stringOnlyCharactersTypeOffset:flatbuffers.Offset, stringOnlyCharactersOffset:flatbuffers.Offset):flatbuffers.Offset {
  Movie.startMovie(builder);
  Movie.addMainCharacterType(builder, mainCharacterType);
  Movie.addMainCharacter(builder, mainCharacterOffset);
  Movie.addCharactersType(builder, charactersTypeOffset);
  Movie.addCharacters(builder, charactersOffset);
  Movie.addStringOnlyCharactersType(builder, stringOnlyCharactersTypeOffset);
  Movie.addStringOnlyCharacters(builder, stringOnlyCharactersOffset);
  return Movie.endMovie(builder);
}

/**
 * @returns MovieT
 */
unpack(): MovieT {
  return new MovieT(
    this.mainCharacterType(),
    (() => {
      let temp = unionToCharacter(this.mainCharacterType(), this.mainCharacter.bind(this));
      if(temp === null) { return null; }
      if(typeof temp === 'string') { return temp; }
      return temp.unpack()
  })(),
    this.bb!.createScalarList(this.charactersType.bind(this), this.charactersTypeLength()),
    (() => {
    let ret = [];
    for(let targetEnumIndex = 0; targetEnumIndex < this.charactersTypeLength(); ++targetEnumIndex) {
      let targetEnum = this.charactersType(targetEnumIndex);
      if(targetEnum === null || Character[targetEnum!] === 'NONE') { continue; }

      let temp = unionListToCharacter(targetEnum, this.characters.bind(this), targetEnumIndex);
      if(temp === null) { continue; }
      if(typeof temp === 'string') { ret.push(temp); continue; }
      ret.push(temp.unpack());
    }
    return ret;
  })(),
    this.bb!.createScalarList(this.stringOnlyCharactersType.bind(this), this.stringOnlyCharactersTypeLength()),
    (() => {
    let ret = [];
    for(let targetEnumIndex = 0; targetEnumIndex < this.stringOnlyCharactersTypeLength(); ++targetEnumIndex) {
      let targetEnum = this.stringOnlyCharactersType(targetEnumIndex);
      if(targetEnum === null || StringOnlyCharacter[targetEnum!] === 'NONE') { continue; }

      let temp = unionListToStringOnlyCharacter(targetEnum, this.stringOnlyCharacters.bind(this), targetEnumIndex);
      if(temp === null) { continue; }
      ret.push(temp);    }
    return ret;
  })()
  );
};

/**
 * @param MovieT _o
 */
unpackTo(_o: MovieT): void {
  _o.mainCharacterType = this.mainCharacterType();
  _o.mainCharacter = (() => {
      let temp = unionToCharacter(this.mainCharacterType(), this.mainCharacter.bind(this));
      if(temp === null) { return null; }
      if(typeof temp === 'string') { return temp; }
      return temp.unpack()
  })();
  _o.charactersType = this.bb!.createScalarList(this.charactersType.bind(this), this.charactersTypeLength());
  _o.characters = (() => {
    let ret = [];
    for(let targetEnumIndex = 0; targetEnumIndex < this.charactersTypeLength(); ++targetEnumIndex) {
      let targetEnum = this.charactersType(targetEnumIndex);
      if(targetEnum === null || Character[targetEnum!] === 'NONE') { continue; }

      let temp = unionListToCharacter(targetEnum, this.characters.bind(this), targetEnumIndex);
      if(temp === null) { continue; }
      if(typeof temp === 'string') { ret.push(temp); continue; }
      ret.push(temp.unpack());
    }
    return ret;
  })();
  _o.stringOnlyCharactersType = this.bb!.createScalarList(this.stringOnlyCharactersType.bind(this), this.stringOnlyCharactersTypeLength());
  _o.stringOnlyCharacters = (() => {
    let ret = [];
    for(let targetEnumIndex = 0; targetEnumIndex < this.stringOnlyCharactersTypeLength(); ++targetEnumIndex) {
      let targetEnum = this.stringOnlyCharactersType(targetEnumIndex);
      if(targetEnum === null || StringOnlyCharacter[targetEnum!] === 'NONE') { continue; }

      let temp = unionListToStringOnlyCharacter(targetEnum, this.stringOnlyCharacters.bind(this), targetEnumIndex);
      if(temp === null) { continue; }
      ret.push(temp);    }
    return ret;
  })();
};
}

export class MovieT {
/**
 * @constructor
 * @param Character mainCharacterType
 * @param AttackerT|BookReaderT|RapunzelT|string|null mainCharacter
 * @param (Character)[] charactersType
 * @param (AttackerT|BookReaderT|RapunzelT|string|null)[] characters
 * @param (StringOnlyCharacter)[] stringOnlyCharactersType
 * @param (string|null)[] stringOnlyCharacters
 */
constructor(
  public mainCharacterType: Character = Character.NONE,
  public mainCharacter: AttackerT|BookReaderT|RapunzelT|string|null = null,
  public charactersType: (Character)[] = [],
  public characters: (AttackerT|BookReaderT|RapunzelT|string|null)[] = [],
  public stringOnlyCharactersType: (StringOnlyCharacter)[] = [],
  public stringOnlyCharacters: (string|null)[] = []
){};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const mainCharacter = builder.createObjectOffset(this.mainCharacter);
  const charactersType = Movie.createCharactersTypeVector(builder, this.charactersType);
  const characters = Movie.createCharactersVector(builder, builder.createObjectOffsetList(this.characters));
  const stringOnlyCharactersType = Movie.createStringOnlyCharactersTypeVector(builder, this.stringOnlyCharactersType);
  const stringOnlyCharacters = Movie.createStringOnlyCharactersVector(builder, builder.createObjectOffsetList(this.stringOnlyCharacters));

  return Movie.createMovie(builder,
    this.mainCharacterType,
    mainCharacter,
    charactersType,
    characters,
    stringOnlyCharactersType,
    stringOnlyCharacters
  );
};
}
