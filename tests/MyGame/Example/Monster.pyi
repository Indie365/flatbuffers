from __future__ import annotations

import flatbuffers
import numpy as np

import typing
from MyGame.Example.Ability import Ability, AbilityT
from MyGame.Example.Monster import Monster, MonsterT
from MyGame.Example.Referrable import Referrable, ReferrableT
from MyGame.Example.Stat import Stat, StatT
from MyGame.Example.Test import Test, TestT
from MyGame.Example.TestSimpleTableWithEnum import TestSimpleTableWithEnumT
from MyGame.Example.Vec3 import Vec3, Vec3T
from MyGame.Example2.Monster import MonsterT
from MyGame.InParentNamespace import InParentNamespace, InParentNamespaceT
from flatbuffers import table

class Monster(object):
  @classmethod
  def GetRootAs(cls, buf: bytes, offset: int) -> Monster: ...
  @classmethod
  def GetRootAsMonster(cls, buf: bytes, offset: int) -> Monster: ...
  @classmethod
  def MonsterBufferHasIdentifier(cls, buf: bytes, offset: int, size_prefixed: bool) -> bool: ...
  def Init(self, buf: bytes, pos: int) -> None: ...
  def Pos(self) -> typing.Optional[Vec3]: ...
  def Mana(self) -> int: ...
  def Hp(self) -> int: ...
  def Name(self) -> typing.Optional[str]: ...
  def Inventory(self, i: int) -> int: ...
  def InventoryAsNumpy(self) -> np.ndarray: ...
  def InventoryLength(self) -> int: ...
  def InventoryIsNone(self) -> bool: ...
  def Color(self) -> int: ...
  def TestType(self) -> int: ...
  def Test(self) -> typing.Optional[table.Table]: ...
  def Test4(self, i: int) -> typing.Optional[Test]: ...
  def Test4Length(self) -> int: ...
  def Test4IsNone(self) -> bool: ...
  def Testarrayofstring(self, i: int) -> str: ...
  def TestarrayofstringLength(self) -> int: ...
  def TestarrayofstringIsNone(self) -> bool: ...
  def Testarrayoftables(self, i: int) -> typing.Optional[Monster]: ...
  def TestarrayoftablesLength(self) -> int: ...
  def TestarrayoftablesIsNone(self) -> bool: ...
  def Enemy(self) -> typing.Optional[Monster]: ...
  def Testnestedflatbuffer(self, i: int) -> int: ...
  def TestnestedflatbufferAsNumpy(self) -> np.ndarray: ...
  def TestnestedflatbufferNestedRoot(self) -> typing.Optional[Monster]: ...
  def TestnestedflatbufferLength(self) -> int: ...
  def TestnestedflatbufferIsNone(self) -> bool: ...
  def Testempty(self) -> typing.Optional[Stat]: ...
  def Testbool(self) -> bool: ...
  def Testhashs32Fnv1(self) -> int: ...
  def Testhashu32Fnv1(self) -> int: ...
  def Testhashs64Fnv1(self) -> int: ...
  def Testhashu64Fnv1(self) -> int: ...
  def Testhashs32Fnv1a(self) -> int: ...
  def Testhashu32Fnv1a(self) -> int: ...
  def Testhashs64Fnv1a(self) -> int: ...
  def Testhashu64Fnv1a(self) -> int: ...
  def Testarrayofbools(self, i: int) -> bool: ...
  def TestarrayofboolsAsNumpy(self) -> np.ndarray: ...
  def TestarrayofboolsLength(self) -> int: ...
  def TestarrayofboolsIsNone(self) -> bool: ...
  def Testf(self) -> float: ...
  def Testf2(self) -> float: ...
  def Testf3(self) -> float: ...
  def Testarrayofstring2(self, i: int) -> str: ...
  def Testarrayofstring2Length(self) -> int: ...
  def Testarrayofstring2IsNone(self) -> bool: ...
  def Testarrayofsortedstruct(self, i: int) -> typing.Optional[Ability]: ...
  def TestarrayofsortedstructLength(self) -> int: ...
  def TestarrayofsortedstructIsNone(self) -> bool: ...
  def Flex(self, i: int) -> int: ...
  def FlexAsNumpy(self) -> np.ndarray: ...
  def FlexLength(self) -> int: ...
  def FlexIsNone(self) -> bool: ...
  def Test5(self, i: int) -> typing.Optional[Test]: ...
  def Test5Length(self) -> int: ...
  def Test5IsNone(self) -> bool: ...
  def VectorOfLongs(self, i: int) -> int: ...
  def VectorOfLongsAsNumpy(self) -> np.ndarray: ...
  def VectorOfLongsLength(self) -> int: ...
  def VectorOfLongsIsNone(self) -> bool: ...
  def VectorOfDoubles(self, i: int) -> float: ...
  def VectorOfDoublesAsNumpy(self) -> np.ndarray: ...
  def VectorOfDoublesLength(self) -> int: ...
  def VectorOfDoublesIsNone(self) -> bool: ...
  def ParentNamespaceTest(self) -> typing.Optional[InParentNamespace]: ...
  def VectorOfReferrables(self, i: int) -> typing.Optional[Referrable]: ...
  def VectorOfReferrablesLength(self) -> int: ...
  def VectorOfReferrablesIsNone(self) -> bool: ...
  def SingleWeakReference(self) -> int: ...
  def VectorOfWeakReferences(self, i: int) -> int: ...
  def VectorOfWeakReferencesAsNumpy(self) -> np.ndarray: ...
  def VectorOfWeakReferencesLength(self) -> int: ...
  def VectorOfWeakReferencesIsNone(self) -> bool: ...
  def VectorOfStrongReferrables(self, i: int) -> typing.Optional[Referrable]: ...
  def VectorOfStrongReferrablesLength(self) -> int: ...
  def VectorOfStrongReferrablesIsNone(self) -> bool: ...
  def CoOwningReference(self) -> int: ...
  def VectorOfCoOwningReferences(self, i: int) -> int: ...
  def VectorOfCoOwningReferencesAsNumpy(self) -> np.ndarray: ...
  def VectorOfCoOwningReferencesLength(self) -> int: ...
  def VectorOfCoOwningReferencesIsNone(self) -> bool: ...
  def NonOwningReference(self) -> int: ...
  def VectorOfNonOwningReferences(self, i: int) -> int: ...
  def VectorOfNonOwningReferencesAsNumpy(self) -> np.ndarray: ...
  def VectorOfNonOwningReferencesLength(self) -> int: ...
  def VectorOfNonOwningReferencesIsNone(self) -> bool: ...
  def AnyUniqueType(self) -> int: ...
  def AnyUnique(self) -> typing.Optional[table.Table]: ...
  def AnyAmbiguousType(self) -> int: ...
  def AnyAmbiguous(self) -> typing.Optional[table.Table]: ...
  def VectorOfEnums(self, i: int) -> int: ...
  def VectorOfEnumsAsNumpy(self) -> np.ndarray: ...
  def VectorOfEnumsLength(self) -> int: ...
  def VectorOfEnumsIsNone(self) -> bool: ...
  def SignedEnum(self) -> int: ...
  def Testrequirednestedflatbuffer(self, i: int) -> int: ...
  def TestrequirednestedflatbufferAsNumpy(self) -> np.ndarray: ...
  def TestrequirednestedflatbufferNestedRoot(self) -> typing.Optional[Monster]: ...
  def TestrequirednestedflatbufferLength(self) -> int: ...
  def TestrequirednestedflatbufferIsNone(self) -> bool: ...
  def ScalarKeySortedTables(self, i: int) -> typing.Optional[Stat]: ...
  def ScalarKeySortedTablesLength(self) -> int: ...
  def ScalarKeySortedTablesIsNone(self) -> bool: ...
  def NativeInline(self) -> typing.Optional[Test]: ...
  def LongEnumNonEnumDefault(self) -> int: ...
  def LongEnumNormalDefault(self) -> int: ...
  def NanDefault(self) -> float: ...
  def InfDefault(self) -> float: ...
  def PositiveInfDefault(self) -> float: ...
  def InfinityDefault(self) -> float: ...
  def PositiveInfinityDefault(self) -> float: ...
  def NegativeInfDefault(self) -> float: ...
  def NegativeInfinityDefault(self) -> float: ...
  def DoubleInfDefault(self) -> float: ...
class MonsterT(object):
  pos: typing.Optional[Vec3T]
  mana: int
  hp: int
  name: typing.Optional[str]
  inventory: typing.List[int]
  color: int
  testType: int
  typing.Union[None, MonsterT, TestSimpleTableWithEnumT, MonsterT]
  test4: typing.List[TestT]
  testarrayofstring: typing.List[str]
  testarrayoftables: typing.List[MonsterT]
  enemy: typing.Optional[MonsterT]
  testnestedflatbuffer: typing.List[int]
  testempty: typing.Optional[StatT]
  testbool: bool
  testhashs32Fnv1: int
  testhashu32Fnv1: int
  testhashs64Fnv1: int
  testhashu64Fnv1: int
  testhashs32Fnv1a: int
  testhashu32Fnv1a: int
  testhashs64Fnv1a: int
  testhashu64Fnv1a: int
  testarrayofbools: typing.List[bool]
  testf: float
  testf2: float
  testf3: float
  testarrayofstring2: typing.List[str]
  testarrayofsortedstruct: typing.List[AbilityT]
  flex: typing.List[int]
  test5: typing.List[TestT]
  vectorOfLongs: typing.List[int]
  vectorOfDoubles: typing.List[float]
  parentNamespaceTest: typing.Optional[InParentNamespaceT]
  vectorOfReferrables: typing.List[ReferrableT]
  singleWeakReference: int
  vectorOfWeakReferences: typing.List[int]
  vectorOfStrongReferrables: typing.List[ReferrableT]
  coOwningReference: int
  vectorOfCoOwningReferences: typing.List[int]
  nonOwningReference: int
  vectorOfNonOwningReferences: typing.List[int]
  anyUniqueType: int
  typing.Union[None, MonsterT, TestSimpleTableWithEnumT, MonsterT]
  anyAmbiguousType: int
  typing.Union[None, MonsterT, MonsterT, MonsterT]
  vectorOfEnums: typing.List[int]
  signedEnum: int
  testrequirednestedflatbuffer: typing.List[int]
  scalarKeySortedTables: typing.List[StatT]
  nativeInline: typing.Optional[TestT]
  longEnumNonEnumDefault: int
  longEnumNormalDefault: int
  nanDefault: float
  infDefault: float
  positiveInfDefault: float
  infinityDefault: float
  positiveInfinityDefault: float
  negativeInfDefault: float
  negativeInfinityDefault: float
  doubleInfDefault: float
  @classmethod
  def InitFromBuf(cls, buf: bytes, pos: int) -> MonsterT: ...
  @classmethod
  def InitFromPackedBuf(cls, buf: bytes, pos: int = 0) -> MonsterT: ...
  @classmethod
  def InitFromObj(cls, monster: Monster) -> MonsterT: ...
  def _UnPack(self, monster: Monster) -> None: ...
  def Pack(self, builder: flatbuffers.Builder) -> None: ...

