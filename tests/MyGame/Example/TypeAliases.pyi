from __future__ import annotations

import flatbuffers
import numpy as np

import typing
from MyGame.Example.TypeAliases import TypeAliases

class TypeAliases(object):
  @classmethod
  def GetRootAs(cls, buf: bytes, offset: int) -> TypeAliases: ...
  @classmethod
  def GetRootAsTypeAliases(cls, buf: bytes, offset: int) -> TypeAliases: ...
  @classmethod
  def TypeAliasesBufferHasIdentifier(cls, buf: bytes, offset: int, size_prefixed: bool) -> bool: ...
  def Init(self, buf: bytes, pos: int) -> None: ...
  def I8(self) -> int: ...
  def U8(self) -> int: ...
  def I16(self) -> int: ...
  def U16(self) -> int: ...
  def I32(self) -> int: ...
  def U32(self) -> int: ...
  def I64(self) -> int: ...
  def U64(self) -> int: ...
  def F32(self) -> float: ...
  def F64(self) -> float: ...
  def V8(self, i: int) -> int: ...
  def V8AsNumpy(self) -> np.ndarray: ...
  def V8Length(self) -> int: ...
  def V8IsNone(self) -> bool: ...
  def Vf64(self, i: int) -> float: ...
  def Vf64AsNumpy(self) -> np.ndarray: ...
  def Vf64Length(self) -> int: ...
  def Vf64IsNone(self) -> bool: ...
class TypeAliasesT(object):
  i8: int
  u8: int
  i16: int
  u16: int
  i32: int
  u32: int
  i64: int
  u64: int
  f32: float
  f64: float
  v8: typing.List[int]
  vf64: typing.List[float]
  @classmethod
  def InitFromBuf(cls, buf: bytes, pos: int) -> TypeAliasesT: ...
  @classmethod
  def InitFromPackedBuf(cls, buf: bytes, pos: int = 0) -> TypeAliasesT: ...
  @classmethod
  def InitFromObj(cls, typeAliases: TypeAliases) -> TypeAliasesT: ...
  def _UnPack(self, typeAliases: TypeAliases) -> None: ...
  def Pack(self, builder: flatbuffers.Builder) -> None: ...

