# automatically generated by the FlatBuffers compiler, do not modify

import flatbuffers
import enum
import operator
import struct

# localize performance sensitive globals
_getitem = operator.getitem
_tuple = tuple
_Enum = enum.Enum


class FromInclude(_Enum):
    IncludeVal = 0


def read_FromInclude(view, offset):
    return FromInclude(flatbuffers.read_long(view, offset))


class Color(_Enum):
    Red = 1
    Green = 2
    Blue = 8


def read_Color(view, offset):
    return Color(flatbuffers.read_byte(view, offset))


class Any(_Enum):
    NONE = 0
    Monster = 1


def read_Any(view, offset):
    return Any(flatbuffers.read_ubyte(view, offset))


class Test(flatbuffers.Struct):
    _format = struct.Struct("hbx")

    def __new__(cls, buf, offset):
        return tuple.__new__(cls, cls._format.unpack_from(buf, offset))

    @property
    def a(self):
        return _getitem(self, 0)

    @property
    def b(self):
        return _getitem(self, 1)


class Vec3(flatbuffers.Struct):
    _format = struct.Struct("fff4xdbxhbx2x")

    def __new__(cls, buf, offset):
        return tuple.__new__(cls, cls._format.unpack_from(buf, offset))

    @property
    def x(self):
        return _getitem(self, 0)

    @property
    def y(self):
        return _getitem(self, 1)

    @property
    def z(self):
        return _getitem(self, 2)

    @property
    def test1(self):
        return _getitem(self, 3)

    @property
    def test2(self):
        return Color(_getitem(self, 4))

    @property
    def test3(self):
        return _tuple.__new__(Test, _getitem(self, slice(5, 7)))


class Stat(flatbuffers.Table):
    @property
    def id(self):
        return self._read_field(0, flatbuffers.indirect(flatbuffers.read_unicode))

    @property
    def val(self):
        return self._read_field(1, flatbuffers.read_long, default=0)


class Monster(flatbuffers.Table):
    @property
    def pos(self):
        return self._read_field(0, Vec3)

    @property
    def mana(self):
        return self._read_field(1, flatbuffers.read_short, default=150)

    @property
    def hp(self):
        return self._read_field(2, flatbuffers.read_short, default=100)

    @property
    def name(self):
        return self._read_field(3, flatbuffers.indirect(flatbuffers.read_unicode))

    @property
    def inventory(self):
        return self._read_field(5, flatbuffers.indirect(flatbuffers.read_ubyte_vector))

    @property
    def color(self):
        return self._read_field(6, read_Color, default=8)

    @property
    def test_type(self):
        return self._read_field(7, read_Any, default=0)

    @property
    def test(self):
        tpe = self.test_type
        if tpe == Any.NONE:
            return None
        if tpe == Any.Monster:
            target = Monster
        return self._read_field(8, flatbuffers.indirect(target))

    @property
    def test4(self):
        return self._read_field(9, flatbuffers.indirect(flatbuffers.vector(Test, 4)))

    @property
    def testarrayofstring(self):
        return self._read_field(10, flatbuffers.indirect(flatbuffers.vector(flatbuffers.indirect(flatbuffers.read_unicode))))

    @property
    def testarrayoftables(self):
        """
         an example documentation comment: this will end up in the generated code
         multiline too
        """

        return self._read_field(11, flatbuffers.indirect(flatbuffers.vector(flatbuffers.indirect(Monster))))

    @property
    def enemy(self):
        return self._read_field(12, flatbuffers.indirect(Monster))

    @property
    def testnestedflatbuffer(self):
        return self._read_field(13, flatbuffers.indirect(flatbuffers.read_ubyte_vector))

    @property
    def testempty(self):
        return self._read_field(14, flatbuffers.indirect(Stat))


def get_root_as_Monster(source):
    return Monster(source, flatbuffers.read_uint(source, 0))
