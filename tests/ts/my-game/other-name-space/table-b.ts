// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';

import { TableA, tableAVerify, TableAT } from '../../table-a.js';


export class TableB implements flatbuffers.IUnpackableObject<TableBT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):TableB {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsTableB(bb:flatbuffers.ByteBuffer, obj?:TableB):TableB {
  return (obj || new TableB()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsTableB(bb:flatbuffers.ByteBuffer, obj?:TableB):TableB {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new TableB()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

a(obj?:TableA):TableA|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? (obj || new TableA()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

static getFullyQualifiedName():string {
  return 'MyGame.OtherNameSpace.TableB';
}

static startTableB(builder:flatbuffers.Builder) {
  builder.startObject(1);
}

static addA(builder:flatbuffers.Builder, aOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, aOffset, 0);
}

static endTableB(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createTableB(builder:flatbuffers.Builder, aOffset:flatbuffers.Offset):flatbuffers.Offset {
  TableB.startTableB(builder);
  TableB.addA(builder, aOffset);
  return TableB.endTableB(builder);
}

serialize():Uint8Array {
  return this.bb!.bytes();
}

static deserialize(buffer: Uint8Array):TableB {
  return TableB.getRootAsTableB(new flatbuffers.ByteBuffer(buffer))
}

unpack(): TableBT {
  return new TableBT(
    (this.a() !== null ? this.a()!.unpack() : null)
  );
}


unpackTo(_o: TableBT): void {
  _o.a = (this.a() !== null ? this.a()!.unpack() : null);
}
}

export class TableBT implements flatbuffers.IGeneratedObject {
constructor(
  public a: TableAT|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const a = (this.a !== null ? this.a!.pack(builder) : 0);

  return TableB.createTableB(builder,
    a
  );
}
}

// Verification function for 'TableB' table.
export function tableBVerify(verifier: flatbuffers.Verifier, tablePos: flatbuffers.UOffset): boolean {
  let result = true;
  result = result && verifier.verifyTableStart(tablePos);
  result = result && verifier.verifyTable(tablePos, 4 /*A*/, tableAVerify, false);
  result = result && verifier.verifyTableEnd(tablePos);
  return result;
}
