// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package Example

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type ArrayStruct struct {
	_tab flatbuffers.Struct
}

func (rcv *ArrayStruct) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ArrayStruct) Table() flatbuffers.Table {
	return rcv._tab.Table
}

func (rcv *ArrayStruct) A() float32 {
	return rcv._tab.GetFloat32(rcv._tab.Pos + flatbuffers.UOffsetT(0))
}
func (rcv *ArrayStruct) MutateA(n float32) bool {
	return rcv._tab.MutateFloat32(rcv._tab.Pos+flatbuffers.UOffsetT(0), n)
}

func (rcv *ArrayStruct) B(j int) int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *ArrayStruct) C() int8 {
	return rcv._tab.GetInt8(rcv._tab.Pos + flatbuffers.UOffsetT(64))
}
func (rcv *ArrayStruct) MutateC(n int8) bool {
	return rcv._tab.MutateInt8(rcv._tab.Pos+flatbuffers.UOffsetT(64), n)
}

func (rcv *ArrayStruct) D(obj **flatbuffers.Table, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 32
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ArrayStruct) E() int32 {
	return rcv._tab.GetInt32(rcv._tab.Pos + flatbuffers.UOffsetT(136))
}
func (rcv *ArrayStruct) MutateE(n int32) bool {
	return rcv._tab.MutateInt32(rcv._tab.Pos+flatbuffers.UOffsetT(136), n)
}

func (rcv *ArrayStruct) F(j int) int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(144))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func CreateArrayStruct(builder *flatbuffers.Builder, a float32, b []int32, c int8, d []NestedStruct, e int32, f []int64) flatbuffers.UOffsetT {
	builder.Prep(8, 160)
	for i := 2; i >= 0; i-- {
		if len(f) < i+1 {
			builder.PlaceInt64(0)
		} else {
			builder.PlaceInt64(data[i])
		}
	}
	builder.Pad(4)
	builder.PrependInt32(e)
	for i := 2; i >= 0; i-- {
		if len(d) < i+1 {
			builder.PlaceInt(0)
		} else {
			builder.PlaceInt(data[i])
		}
	}
	builder.Pad(7)
	builder.PrependInt8(c)
	for i := 15; i >= 0; i-- {
		if len(b) < i+1 {
			builder.PlaceInt32(0)
		} else {
			builder.PlaceInt32(data[i])
		}
	}
	builder.PrependFloat32(a)
	return builder.Offset()
}
