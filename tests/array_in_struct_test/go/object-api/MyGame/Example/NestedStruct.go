// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package Example

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type NestedStructT struct {
	A []int32 `json:"a"`
	B TestEnum `json:"b"`
	C []TestEnum `json:"c"`
	D []int64 `json:"d"`
}

func (t *NestedStructT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	return CreateNestedStruct(builder, t.A, t.B, t.C, t.D)
}
func (rcv *NestedStruct) UnPackTo(t *NestedStructT) {
	t.A = rcv.A()
	t.B = rcv.B()
	t.C = rcv.C()
	t.D = rcv.D()
}

func (rcv *NestedStruct) UnPack() *NestedStructT {
	if rcv == nil {
		return nil
	}
	t := &NestedStructT{}
	rcv.UnPackTo(t)
	return t
}

type NestedStruct struct {
	_tab flatbuffers.Struct
}

func (rcv *NestedStruct) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *NestedStruct) Table() flatbuffers.Table {
	return rcv._tab.Table
}

func (rcv *NestedStruct) A(j int) int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(0))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *NestedStruct) B() TestEnum {
	return TestEnum(rcv._tab.GetInt8(rcv._tab.Pos + flatbuffers.UOffsetT(8)))
}
func (rcv *NestedStruct) MutateB(n TestEnum) bool {
	return rcv._tab.MutateInt8(rcv._tab.Pos+flatbuffers.UOffsetT(8), int8(n))
}

func (rcv *NestedStruct) C(j int) TestEnum {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(9))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return TestEnum(rcv._tab.GetInt8(a + flatbuffers.UOffsetT(j*1)))
	}
	return 0
}

func (rcv *NestedStruct) D(j int) int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func CreateNestedStruct(builder *flatbuffers.Builder, a []int32, b TestEnum, c []TestEnum, d []int64) flatbuffers.UOffsetT {
	builder.Prep(8, 32)
	for i := 2; i >= 0; i-- {
		if len(d) < i+1 {
			builder.PlaceInt64(0)
		} else {
			builder.PlaceInt64(data[i])
		}
	}
	builder.Pad(5)
	for i := 2; i >= 0; i-- {
		if len(c) < i+1 {
			builder.PlaceInt8(0)
		} else {
			builder.PlaceInt8(data[i])
		}
	}
	builder.PrependInt8(int8(b))
	for i := 2; i >= 0; i-- {
		if len(a) < i+1 {
			builder.PlaceInt32(0)
		} else {
			builder.PlaceInt32(data[i])
		}
	}
	return builder.Offset()
}
