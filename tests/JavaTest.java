/*
 * Copyright 2014 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.io.*;
import java.nio.ByteBuffer;
import MyGame.Example.*;
import NamespaceA.*;
import NamespaceA.NamespaceB.*;
import com.google.flatbuffers.Unsigneds;
import com.google.flatbuffers.Floats;
import com.google.flatbuffers.FlatBufferBuilder;

class JavaTest {
    public static void main(String[] args) {

        TestComparators();

        // First, let's test reading a FlatBuffer generated by C++ code:
        // This file was generated from monsterdata_test.json

        byte[] data = null;
        File file = new File("monsterdata_test.mon");
        RandomAccessFile f = null;
        try {
            f = new RandomAccessFile(file, "r");
            data = new byte[(int)f.length()];
            f.readFully(data);
            f.close();
        } catch(java.io.IOException e) {
            System.out.println("FlatBuffers test: couldn't read file");
            return;
        }

        // Now test it:

        ByteBuffer bb = ByteBuffer.wrap(data);
        TestBuffer(bb);

        // Second, let's create a FlatBuffer from scratch in Java, and test it also.
        // We use an initial size of 1 to exercise the reallocation algorithm,
        // normally a size larger than the typical FlatBuffer you generate would be
        // better for performance.
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);

        int[] names = {fbb.createString("Frodo"), fbb.createString("Barney"), fbb.createString("Wilma")};
        int[] off = new int[3];
        Monster.startMonster(fbb);
        Monster.addName(fbb, names[0]);
        off[0] = Monster.endMonster(fbb);
        Monster.startMonster(fbb);
        Monster.addName(fbb, names[1]);
        off[1] = Monster.endMonster(fbb);
        Monster.startMonster(fbb);
        Monster.addName(fbb, names[2]);
        off[2] = Monster.endMonster(fbb);
        int sortMons = fbb.createSortedVectorOfTables(new Monster(), off);
		
        // We set up the same values as monsterdata.json:

        int str = fbb.createString("MyMonster");

        int inv = Monster.createInventoryVector(fbb, new byte[] { 0, 1, 2, 3, 4 });

        int fred = fbb.createString("Fred");
        Monster.startMonster(fbb);
        Monster.addName(fbb, fred);
        int mon2 = Monster.endMonster(fbb);

        Monster.startTest4Vector(fbb, 2);
        Test.createTest(fbb, (short)10, (byte)20);
        Test.createTest(fbb, (short)30, (byte)40);
        int test4 = fbb.endVector();

        int testArrayOfString = Monster.createTestarrayofstringVector(fbb, new int[] {
            fbb.createString("test1"),
            fbb.createString("test2")
        });

        Monster.startMonster(fbb);
        Monster.addPos(fbb, Vec3.createVec3(fbb, 1.0f, 2.0f, 3.0f, 3.0,
                                                 Color.Green, (short)5, (byte)6));
        Monster.addHp(fbb, (short)80);
        Monster.addName(fbb, str);
        Monster.addInventory(fbb, inv);
        Monster.addTestType(fbb, (byte)Any.Monster);
        Monster.addTest(fbb, mon2);
        Monster.addTest4(fbb, test4);
        Monster.addTestarrayofstring(fbb, testArrayOfString);
        Monster.addTestbool(fbb, false);
        Monster.addTesthashu32Fnv1(fbb, Integer.MAX_VALUE + 1L);
        Monster.addTestarrayoftables(fbb, sortMons);
        int mon = Monster.endMonster(fbb);

        Monster.finishMonsterBuffer(fbb, mon);

        // Write the result to a file for debugging purposes:
        // Note that the binaries are not necessarily identical, since the JSON
        // parser may serialize in a slightly different order than the above
        // Java code. They are functionally equivalent though.

        try {
            DataOutputStream os = new DataOutputStream(new FileOutputStream(
                                           "monsterdata_java_wire.mon"));
            os.write(fbb.dataBuffer().array(), fbb.dataBuffer().position(), fbb.offset());
            os.close();
        } catch(java.io.IOException e) {
            System.out.println("FlatBuffers test: couldn't write file");
            System.exit(1);
        }

        // Test it:
        TestExtendedBuffer(fbb.dataBuffer());

        // Make sure it also works with read only ByteBuffers. This is slower,
        // since creating strings incurs an additional copy
        // (see Table.__string).
        TestExtendedBuffer(fbb.dataBuffer().asReadOnlyBuffer());

        TestEnums();

        //Attempt to mutate Monster fields and check whether the buffer has been mutated properly
        // revert to original values after testing
        Monster monster = Monster.getRootAsMonster(fbb.dataBuffer());

        // mana is optional and does not exist in the buffer so the mutation should fail
        // the mana field should retain its default value
        TestEq(monster.mutateMana((short)10), false);
        TestEq(monster.mana(), (short)150);
		
		// Accessing a vector of sorted by the key tables
        TestEq(monster.testarrayoftables(0).name(), "Barney");
        TestEq(monster.testarrayoftables(1).name(), "Frodo");
        TestEq(monster.testarrayoftables(2).name(), "Wilma");

        // Example of searching for a table by the key
        TestEq(TestNotNull(monster.testarrayoftablesByKey("Frodo")).name(), "Frodo");
        TestEq(TestNotNull(monster.testarrayoftablesByKey("Barney")).name(), "Barney");
        TestEq(TestNotNull(monster.testarrayoftablesByKey("Wilma")).name(), "Wilma");

        // testType is an existing field and mutating it should succeed
        TestEq(monster.testType(), (byte)Any.Monster);
        TestEq(monster.mutateTestType(Any.NONE), true);
        TestEq(monster.testType(), (byte)Any.NONE);
        TestEq(monster.mutateTestType(Any.Monster), true);
        TestEq(monster.testType(), (byte)Any.Monster);

        //mutate the inventory vector
        TestEq(monster.mutateInventory(0, 1), true);
        TestEq(monster.mutateInventory(1, 2), true);
        TestEq(monster.mutateInventory(2, 3), true);
        TestEq(monster.mutateInventory(3, 4), true);
        TestEq(monster.mutateInventory(4, 5), true);

        for (int i = 0; i < monster.inventoryLength(); i++) {
            TestEq(monster.inventory(i), i + 1);
        }

        //reverse mutation
        TestEq(monster.mutateInventory(0, 0), true);
        TestEq(monster.mutateInventory(1, 1), true);
        TestEq(monster.mutateInventory(2, 2), true);
        TestEq(monster.mutateInventory(3, 3), true);
        TestEq(monster.mutateInventory(4, 4), true);

        // get a struct field and edit one of its fields
        Vec3 pos = monster.pos();
        TestEq(pos.x(), 1.0f);
        pos.mutateX(55.0f);
        TestEq(pos.x(), 55.0f);
        pos.mutateX(1.0f);
        TestEq(pos.x(), 1.0f);

        TestExtendedBuffer(fbb.dataBuffer().asReadOnlyBuffer());

        TestNamespaceNesting();

        TestNestedFlatBuffer();

        TestCreateByteVector();

        TestCreateUninitializedVector();

        System.out.println("FlatBuffers test: completed successfully");
    }

    static void TestEnums() {
      TestEq(Color.name(Color.Red), "Red");
      TestEq(Color.name(Color.Blue), "Blue");
      TestEq(Any.name(Any.NONE), "NONE");
      TestEq(Any.name(Any.Monster), "Monster");
    }

    static void TestBuffer(ByteBuffer bb) {
        TestEq(Monster.MonsterBufferHasIdentifier(bb), true);
        
        Monster monster = Monster.getRootAsMonster(bb);

        TestEq(monster.hp(), (short)80);
        TestEq(monster.mana(), (short)150);  // default

        TestEq(monster.name(), "MyMonster");
        // monster.friendly() // can't access, deprecated

        Vec3 pos = monster.pos();
        TestEq(pos.x(), 1.0f);
        TestEq(pos.y(), 2.0f);
        TestEq(pos.z(), 3.0f);
        TestEq(pos.test1(), 3.0);
        TestEq(pos.test2(), Color.Green);
        Test t = pos.test3();
        TestEq(t.a(), (short)5);
        TestEq(t.b(), (byte)6);

        TestEq(monster.testType(), (byte)Any.Monster);
        Monster monster2 = new Monster();
        TestEq(monster.test(monster2) != null, true);
        TestEq(monster2.name(), "Fred");

        TestEq(monster.inventoryLength(), 5);
        int invsum = 0;
        for (int i = 0; i < monster.inventoryLength(); i++)
            invsum += monster.inventory(i);
        TestEq(invsum, 10);

        // Alternative way of accessing a vector:
        ByteBuffer ibb = monster.inventoryAsByteBuffer();
        invsum = 0;
        while (ibb.position() < ibb.limit())
            invsum += ibb.get();
        TestEq(invsum, 10);

        Test test_0 = monster.test4(0);
        Test test_1 = monster.test4(1);
        TestEq(monster.test4Length(), 2);
        TestEq(test_0.a() + test_0.b() + test_1.a() + test_1.b(), 100);

        TestEq(monster.testarrayofstringLength(), 2);
        TestEq(monster.testarrayofstring(0),"test1");
        TestEq(monster.testarrayofstring(1),"test2");

        TestEq(monster.testbool(), false);
    }

    // this method checks additional fields not present in the binary buffer read from file
    // these new tests are performed on top of the regular tests
    static void TestExtendedBuffer(ByteBuffer bb) {
        TestBuffer(bb);

        Monster monster = Monster.getRootAsMonster(bb);

        TestEq(monster.testhashu32Fnv1(), Integer.MAX_VALUE + 1L);
    }
    
    static void TestNamespaceNesting() {
        // reference / manipulate these to verify compilation
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        
        TableInNestedNS.startTableInNestedNS(fbb);
        TableInNestedNS.addFoo(fbb, 1234);
        int nestedTableOff = TableInNestedNS.endTableInNestedNS(fbb);
        
        TableInFirstNS.startTableInFirstNS(fbb);      
        TableInFirstNS.addFooTable(fbb, nestedTableOff);
        int off = TableInFirstNS.endTableInFirstNS(fbb);
    }
    
    static void TestNestedFlatBuffer() {
        final String nestedMonsterName = "NestedMonsterName";
        final short nestedMonsterHp = 600;
        final short nestedMonsterMana = 1024;
        
        FlatBufferBuilder fbb1 = new FlatBufferBuilder(16);
        int str1 = fbb1.createString(nestedMonsterName);
        Monster.startMonster(fbb1);
        Monster.addName(fbb1, str1);
        Monster.addHp(fbb1, nestedMonsterHp);
        Monster.addMana(fbb1, nestedMonsterMana);
        int monster1 = Monster.endMonster(fbb1);
        Monster.finishMonsterBuffer(fbb1, monster1);
        byte[] fbb1Bytes = fbb1.sizedByteArray();
        fbb1 = null;
        
        FlatBufferBuilder fbb2 = new FlatBufferBuilder(16);        
        int str2 = fbb2.createString("My Monster");
        int nestedBuffer = Monster.createTestnestedflatbufferVector(fbb2, fbb1Bytes);
        Monster.startMonster(fbb2);
        Monster.addName(fbb2, str2);
        Monster.addHp(fbb2, (short)50);
        Monster.addMana(fbb2, (short)32);
        Monster.addTestnestedflatbuffer(fbb2, nestedBuffer);
        int monster = Monster.endMonster(fbb2);
        Monster.finishMonsterBuffer(fbb2, monster);
        
        // Now test the data extracted from the nested buffer
        Monster mons = Monster.getRootAsMonster(fbb2.dataBuffer());
        Monster nestedMonster = mons.testnestedflatbufferAsMonster();

        TestEq(nestedMonsterMana, nestedMonster.mana());
        TestEq(nestedMonsterHp, nestedMonster.hp());
        TestEq(nestedMonsterName, nestedMonster.name());
    }

    static void TestCreateByteVector() {
        FlatBufferBuilder fbb = new FlatBufferBuilder(16);
        int str = fbb.createString("MyMonster");
        byte[] inventory = new byte[] { 0, 1, 2, 3, 4 };
        int vec = fbb.createByteVector(inventory);
        Monster.startMonster(fbb);
        Monster.addInventory(fbb, vec);
        Monster.addName(fbb, str);
        int monster1 = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, monster1);
        Monster monsterObject = Monster.getRootAsMonster(fbb.dataBuffer());

        TestEq(monsterObject.inventory(1), (int)inventory[1]);
        TestEq(monsterObject.inventoryLength(), inventory.length);
        TestEq(ByteBuffer.wrap(inventory), monsterObject.inventoryAsByteBuffer());
    }

    static void TestCreateUninitializedVector() {
        FlatBufferBuilder fbb = new FlatBufferBuilder(16);
        int str = fbb.createString("MyMonster");
        byte[] inventory = new byte[] { 0, 1, 2, 3, 4 };
        ByteBuffer bb = fbb.createUnintializedVector(1, inventory.length, 1);
        for (byte i:inventory) {
            bb.put(i);
        }
        int vec = fbb.endVector();
        Monster.startMonster(fbb);
        Monster.addInventory(fbb, vec);
        Monster.addName(fbb, str);
        int monster1 = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, monster1);
        Monster monsterObject = Monster.getRootAsMonster(fbb.dataBuffer());

        TestEq(monsterObject.inventory(1), (int)inventory[1]);
        TestEq(monsterObject.inventoryLength(), inventory.length);
        TestEq(ByteBuffer.wrap(inventory), monsterObject.inventoryAsByteBuffer());
    }

    private static void TestComparators() {
        // ulong
        TestTrue(Unsigneds.asComparable(0xff00123400000000L) > Unsigneds.asComparable( 0xf500123400000000L));
        TestTrue(Unsigneds.asComparable(0xff00123400000000L) > Unsigneds.asComparable(0x0500123400000000L));
        TestTrue(Unsigneds.asComparable(0x0a00123400000000L) < Unsigneds.asComparable(0x6500123400000000L));
        TestTrue(Unsigneds.asComparable(0xf500123400000000L) < Unsigneds.asComparable(0xff00123400000000L));
        TestTrue(Unsigneds.asComparable(0x0a00123400000000L) < Unsigneds.asComparable(0xf500123400000000L));
        TestEq(Unsigneds.asComparable(0x0123456701234567L), Unsigneds.asComparable(0x0123456701234567L));
        TestEq(Unsigneds.asComparable(0xf123456701234567L), Unsigneds.asComparable(0xf123456701234567L));
        // uint
        TestTrue(Unsigneds.asComparable(0xff001234) > Unsigneds.asComparable(0xf5001234));
        TestTrue(Unsigneds.asComparable(0xff001234) > Unsigneds.asComparable(0x05001234));
        TestTrue(Unsigneds.asComparable(0x0a001234) < Unsigneds.asComparable(0x65001234));
        TestTrue(Unsigneds.asComparable(0x0a001234) < Unsigneds.asComparable(0xf5001234));
        TestTrue(Unsigneds.asComparable(0xf5001234) < Unsigneds.asComparable(0xff001234));
        TestEq(Unsigneds.asComparable(0x1000), Unsigneds.asComparable(0x1000));
        // ushort
        TestTrue(Unsigneds.asComparable((short)0xff00) > Unsigneds.asComparable((short)0xf500));
        TestTrue(Unsigneds.asComparable((short)0xff00) > Unsigneds.asComparable((short)0x0500));
        TestTrue(Unsigneds.asComparable((short)0x0a00) < Unsigneds.asComparable((short)0x6500));
        TestTrue(Unsigneds.asComparable((short)0x0a00) < Unsigneds.asComparable((short)0xf500));
        TestTrue(Unsigneds.asComparable((short)0xf500) < Unsigneds.asComparable((short)0xff00));
        TestEq(Unsigneds.asComparable((short)0x1000), Unsigneds.asComparable((short)0x1000));
        // ubyte
        TestTrue(Unsigneds.asComparable((byte)0xff) > Unsigneds.asComparable((byte)0xf5));
        TestTrue(Unsigneds.asComparable((byte)0xff) > Unsigneds.asComparable((byte)0x05));
        TestTrue(Unsigneds.asComparable((byte)0x0a) < Unsigneds.asComparable((byte)0x65));
        TestTrue(Unsigneds.asComparable((byte)0xff) > Unsigneds.asComparable((byte)0xf5));
        TestTrue(Unsigneds.asComparable((byte)0x0a) < Unsigneds.asComparable((byte)0xf5));
        TestTrue(Unsigneds.asComparable((byte)0xf5) < Unsigneds.asComparable((byte)0xff));
        TestEq(Unsigneds.asComparable((byte)0x10), Unsigneds.asComparable((byte)0x10));
        // float & double
        // Test data below have all variations on negative/positive, value and exponent, with
        // different mantissa for same power of 2 exponent/sign
        double[] f64Values = new double[] {
            -913.88277946998f, -451.55849548266906f, -398.9521369878568f, -373.1765063331935f, -349.3138378754971f, -184.18935713288406f, -169.57508149009269f,
            -148.07223565561353f, -50.20992402546123f, -49.41469156939033f, -29.134367317783585f, -24.401894896412273f, -21.46612177313856f, -12.498319437521953f,
            -8.58930619971298f, -3.466330535131341f, -3.1080751919609453f, -3.0245343426321796f, -1.784629717172594f, -1.591247034141098f, -1.439258636521176f,
            -1.3462257335880672f, -1.0132803312183236f, -1.0098087891515546f, -0.4708026162812924f, -0.38744782910638065f, -0.3832956879364384f, -0.3749908770124166f,
            -0.3492245622196551f, -0.34634179856647407f, -0.30482498036849404f, -0.1368991481421844f, -0.11837451052752274f, -0.10566143130832681f, -0.07751350017123013f,
            -0.06447926225536124f, -0.027720353976012607f, -0.02443775459083128f, -0.021890331572514847f, -0.01947543644067332f, -0.017247436844635033f, -0.01275427587400662f,
            -0.012131854036105606f, -0.01126198616071089f, -0.0076233224024578146f, -0.007072284770235004f, -0.001989196446518921f, -0.0018909344879741172f, -0.0016460521734114326f,
            -0.0013542969881433517f, -0.0007553131433575775f, -0.00044177158874807426f, -6.49238841063999e-05f, 0.0007211288654730435f, 0.0009581583203711188f, 0.0011629296521412202f,
            0.0017168901314592222f, 0.0018234681814673168f, 0.0026332221897273724f, 0.0035546338652287304f, 0.004511320288117727f, 0.005088613511290224f, 0.0052509046077288905f,
            0.005898869208240446f, 0.012032855535384994f, 0.02384963185119851f, 0.025681296807422455f, 0.0316136013536846f, 0.03577457470923317f, 0.05429123238833541f,
            0.060753118346393575f, 0.06507962071852325f, 0.07842859757126497f, 0.13224961374184566f, 0.15951639254440586f, 0.1971926737216028f, 0.6127031319516282f,
            1.3856424070714808f, 1.4783998923448256f, 1.47936206980526f, 1.727831997305124f, 1.8105494593641227f, 1.8467236027767595f, 3.000351638443712f,
            3.1444677592591646f, 4.094429136276359f, 4.632271870555126f, 11.079715026233352f, 13.421088449489883f, 17.094075195066434f, 29.359074609342198f,
            48.85323182746203f, 49.98646118746959f, 59.904217264332715f, 95.87134913466534f, 100.09166909951568f, 193.36221068721352f, 241.10532700069035f,
            342.3426093748108f, 812.6542175104108f
        };
        for ( int index=1; index < f64Values.length; ++index ) {
            double doubleValue = f64Values[index];
            double prevDoubleValue = f64Values[index-1];
            assert prevDoubleValue < doubleValue;
            TestTrue( Floats.asComparable(prevDoubleValue) < Floats.asComparable(doubleValue) );
            TestTrue( Floats.asComparable((float)(prevDoubleValue)) < Floats.asComparable((float)doubleValue));
        }
    }


    static void TestTrue(boolean a) {
        if (!a) {
            System.out.println("FlatBuffers test FAILED: expected true");
            assert false; // Run test with -ea VM options to get callstack
            System.exit(1);
        }
    }

    static <T> void TestEq(T a, T b) {
        if (!a.equals(b)) {
            System.out.println("" + a.getClass().getName() + " " + b.getClass().getName());
            System.out.println("FlatBuffers test FAILED: \'" + a + "\' != \'" + b + "\'");
            assert false; // Run test with -ea VM options to get callstack
            System.exit(1);
        }
    }

    static <T> T TestNotNull(T a) {
        if (a == null) {
            System.out.println("FlatBuffers test FAILED: unexpected null reference");
            assert false; // Run test with -ea VM options to get callstack
            System.exit(1);
        }
        return a;
    }

    static <T> void TestIsNull(T a) {
        if (a != null) {
            System.out.println("FlatBuffers test FAILED: expected null but got '" + a + "'");
            assert false; // Run test with -ea VM options to get callstack
            System.exit(1);
        }
    }
}
