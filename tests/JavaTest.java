/*
 * Copyright 2014 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.io.*;
import java.nio.ByteBuffer;
import MyGame.Example.*;
import NamespaceA.*;
import NamespaceA.NamespaceB.*;
import Testing.KeySearch.*;
import com.google.flatbuffers.*;
import com.google.flatbuffers.reflection.*;
import com.google.flatbuffers.reflection.Object;

class JavaTest {
    private static final boolean ENABLE_KEYBUG = true;

    public static void main(String[] args) {

        TestComparators();

        // First, let's test reading a FlatBuffer generated by C++ code:
        // This file was generated from monsterdata_test.json

        byte[] data = loadBinaryFile("monsterdata_test.mon");

        // Now test it:

        ByteBuffer bb = ByteBuffer.wrap(data);
        TestBuffer(bb);

        // Second, let's create a FlatBuffer from scratch in Java, and test it also.
        // We use an initial size of 1 to exercise the reallocation algorithm,
        // normally a size larger than the typical FlatBuffer you generate would be
        // better for performance.
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);

        int[] names = {fbb.createString("Frodo"), fbb.createString("Barney"), fbb.createString("Wilma")};
        int[] off = new int[3];
        Monster.startMonster(fbb);
        Monster.addName(fbb, names[0]);
        off[0] = Monster.endMonster(fbb);
        Monster.startMonster(fbb);
        Monster.addName(fbb, names[1]);
        off[1] = Monster.endMonster(fbb);
        Monster.startMonster(fbb);
        Monster.addName(fbb, names[2]);
        off[2] = Monster.endMonster(fbb);
        int sortMons = fbb.createSortedVectorOfTables(new Monster(), off);

        // We set up the same values as monsterdata.json:

        int str = fbb.createString("MyMonster");

        int inv = Monster.createInventoryVector(fbb, new byte[] { 0, 1, 2, 3, 4 });

        int fred = fbb.createString("Fred");
        Monster.startMonster(fbb);
        Monster.addName(fbb, fred);
        int mon2 = Monster.endMonster(fbb);

        Monster.startTest4Vector(fbb, 2);
        Test.createTest(fbb, (short)10, (byte)20);
        Test.createTest(fbb, (short)30, (byte)40);
        int test4 = fbb.endVector();

        int testArrayOfString = Monster.createTestarrayofstringVector(fbb, new int[] {
            fbb.createString("test1"),
            fbb.createString("test2")
        });

        Monster.startMonster(fbb);
        Monster.addPos(fbb, Vec3.createVec3(fbb, 1.0f, 2.0f, 3.0f, 3.0,
                                                 Color.Green, (short)5, (byte)6));
        Monster.addHp(fbb, (short)80);
        Monster.addName(fbb, str);
        Monster.addInventory(fbb, inv);
        Monster.addTestType(fbb, (byte)Any.Monster);
        Monster.addTest(fbb, mon2);
        Monster.addTest4(fbb, test4);
        Monster.addTestarrayofstring(fbb, testArrayOfString);
        Monster.addTestbool(fbb, false);
        Monster.addTesthashu32Fnv1(fbb, Integer.MAX_VALUE + 1L);
        Monster.addTestarrayoftables(fbb, sortMons);
        int mon = Monster.endMonster(fbb);

        Monster.finishMonsterBuffer(fbb, mon);

        // Write the result to a file for debugging purposes:
        // Note that the binaries are not necessarily identical, since the JSON
        // parser may serialize in a slightly different order than the above
        // Java code. They are functionally equivalent though.

        try {
            DataOutputStream os = new DataOutputStream(new FileOutputStream(
                    "monsterdata_java_wire.mon"));
            os.write(fbb.dataBuffer().array(), fbb.dataBuffer().position(), fbb.offset());
            os.close();
        } catch(IOException e) {
            System.out.println("FlatBuffers test: couldn't write file");
            System.exit(1);
        }

        // Test it:
        TestExtendedBuffer(fbb.dataBuffer());

        // Make sure it also works with read only ByteBuffers. This is slower,
        // since creating strings incurs an additional copy
        // (see Table.__string).
        TestExtendedBuffer(fbb.dataBuffer().asReadOnlyBuffer());

        TestEnums();

        //Attempt to mutate Monster fields and check whether the buffer has been mutated properly
        // revert to original values after testing
        Monster monster = Monster.getRootAsMonster(fbb.dataBuffer());

        // mana is optional and does not exist in the buffer so the mutation should fail
        // the mana field should retain its default value
        TestEq(monster.mutateMana((short)10), false);
        TestEq(monster.mana(), (short)150);

		// Accessing a vector of sorted by the key tables
        TestEq(monster.testarrayoftables(0).name(), "Barney");
        TestEq(monster.testarrayoftables(1).name(), "Frodo");
        TestEq(monster.testarrayoftables(2).name(), "Wilma");

        // Example of searching for a table by the key
        TestEq(TestNotNull(monster.testarrayoftablesByKey("Frodo")).name(), "Frodo");
        TestEq(TestNotNull(monster.testarrayoftablesByKey("Barney")).name(), "Barney");
        TestEq(TestNotNull(monster.testarrayoftablesByKey("Wilma")).name(), "Wilma");

        // testType is an existing field and mutating it should succeed
        TestEq(monster.testType(), (byte)Any.Monster);
        TestEq(monster.mutateTestType(Any.NONE), true);
        TestEq(monster.testType(), (byte)Any.NONE);
        TestEq(monster.mutateTestType(Any.Monster), true);
        TestEq(monster.testType(), (byte)Any.Monster);

        //mutate the inventory vector
        TestEq(monster.mutateInventory(0, 1), true);
        TestEq(monster.mutateInventory(1, 2), true);
        TestEq(monster.mutateInventory(2, 3), true);
        TestEq(monster.mutateInventory(3, 4), true);
        TestEq(monster.mutateInventory(4, 5), true);

        for (int i = 0; i < monster.inventoryLength(); i++) {
            TestEq(monster.inventory(i), i + 1);
        }

        //reverse mutation
        TestEq(monster.mutateInventory(0, 0), true);
        TestEq(monster.mutateInventory(1, 1), true);
        TestEq(monster.mutateInventory(2, 2), true);
        TestEq(monster.mutateInventory(3, 3), true);
        TestEq(monster.mutateInventory(4, 4), true);

        // get a struct field and edit one of its fields
        Vec3 pos = monster.pos();
        TestEq(pos.x(), 1.0f);
        pos.mutateX(55.0f);
        TestEq(pos.x(), 55.0f);
        pos.mutateX(1.0f);
        TestEq(pos.x(), 1.0f);

        TestExtendedBuffer(fbb.dataBuffer().asReadOnlyBuffer());

        TestNamespaceNesting();

        TestNestedFlatBuffer();

        TestCreateByteVector();

        TestCreateUninitializedVector();

        TestKeySearchAllMissing();
        TestKeySearchEmpty();
        TestKeySearchOneEntry();
        TestKeySearchManyEntries();

        TestReflection();

        System.out.println("FlatBuffers test: completed successfully");
    }

    private static byte[] loadBinaryFile(String path) {
        byte[] data = null;
        File file = new File(path);
        RandomAccessFile f = null;
        try {
            f = new RandomAccessFile(file, "r");
            data = new byte[(int)f.length()];
            f.readFully(data);
            f.close();
        } catch(IOException e) {
            System.out.println("FlatBuffers test: couldn't read file " + path);
            System.exit(1);
        }
        return data;
    }

    static void TestEnums() {
      TestEq(Color.name(Color.Red), "Red");
      TestEq(Color.name(Color.Blue), "Blue");
      TestEq(Any.name(Any.NONE), "NONE");
      TestEq(Any.name(Any.Monster), "Monster");
    }

    static void TestBuffer(ByteBuffer bb) {
        TestEq(Monster.MonsterBufferHasIdentifier(bb), true);

        Monster monster = Monster.getRootAsMonster(bb);

        TestEq(monster.hp(), (short)80);
        TestEq(monster.mana(), (short)150);  // default

        TestEq(monster.name(), "MyMonster");
        // monster.friendly() // can't access, deprecated

        Vec3 pos = monster.pos();
        TestEq(pos.x(), 1.0f);
        TestEq(pos.y(), 2.0f);
        TestEq(pos.z(), 3.0f);
        TestEq(pos.test1(), 3.0);
        TestEq(pos.test2(), Color.Green);
        Test t = pos.test3();
        TestEq(t.a(), (short)5);
        TestEq(t.b(), (byte)6);

        TestEq(monster.testType(), (byte)Any.Monster);
        Monster monster2 = new Monster();
        TestEq(monster.test(monster2) != null, true);
        TestEq(monster2.name(), "Fred");

        TestEq(monster.inventoryLength(), 5);
        int invsum = 0;
        for (int i = 0; i < monster.inventoryLength(); i++)
            invsum += monster.inventory(i);
        TestEq(invsum, 10);

        // Alternative way of accessing a vector:
        ByteBuffer ibb = monster.inventoryAsByteBuffer();
        invsum = 0;
        while (ibb.position() < ibb.limit())
            invsum += ibb.get();
        TestEq(invsum, 10);

        Test test_0 = monster.test4(0);
        Test test_1 = monster.test4(1);
        TestEq(monster.test4Length(), 2);
        TestEq(test_0.a() + test_0.b() + test_1.a() + test_1.b(), 100);

        TestEq(monster.testarrayofstringLength(), 2);
        TestEq(monster.testarrayofstring(0),"test1");
        TestEq(monster.testarrayofstring(1),"test2");

        TestEq(monster.testbool(), false);
    }

    // this method checks additional fields not present in the binary buffer read from file
    // these new tests are performed on top of the regular tests
    static void TestExtendedBuffer(ByteBuffer bb) {
        TestBuffer(bb);

        Monster monster = Monster.getRootAsMonster(bb);

        TestEq(monster.testhashu32Fnv1(), Integer.MAX_VALUE + 1L);
    }

    static void TestNamespaceNesting() {
        // reference / manipulate these to verify compilation
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);

        TableInNestedNS.startTableInNestedNS(fbb);
        TableInNestedNS.addFoo(fbb, 1234);
        int nestedTableOff = TableInNestedNS.endTableInNestedNS(fbb);

        TableInFirstNS.startTableInFirstNS(fbb);
        TableInFirstNS.addFooTable(fbb, nestedTableOff);
        int off = TableInFirstNS.endTableInFirstNS(fbb);
    }

    static void TestNestedFlatBuffer() {
        final String nestedMonsterName = "NestedMonsterName";
        final short nestedMonsterHp = 600;
        final short nestedMonsterMana = 1024;

        FlatBufferBuilder fbb1 = new FlatBufferBuilder(16);
        int str1 = fbb1.createString(nestedMonsterName);
        Monster.startMonster(fbb1);
        Monster.addName(fbb1, str1);
        Monster.addHp(fbb1, nestedMonsterHp);
        Monster.addMana(fbb1, nestedMonsterMana);
        int monster1 = Monster.endMonster(fbb1);
        Monster.finishMonsterBuffer(fbb1, monster1);
        byte[] fbb1Bytes = fbb1.sizedByteArray();
        fbb1 = null;

        FlatBufferBuilder fbb2 = new FlatBufferBuilder(16);
        int str2 = fbb2.createString("My Monster");
        int nestedBuffer = Monster.createTestnestedflatbufferVector(fbb2, fbb1Bytes);
        Monster.startMonster(fbb2);
        Monster.addName(fbb2, str2);
        Monster.addHp(fbb2, (short)50);
        Monster.addMana(fbb2, (short)32);
        Monster.addTestnestedflatbuffer(fbb2, nestedBuffer);
        int monster = Monster.endMonster(fbb2);
        Monster.finishMonsterBuffer(fbb2, monster);

        // Now test the data extracted from the nested buffer
        Monster mons = Monster.getRootAsMonster(fbb2.dataBuffer());
        Monster nestedMonster = mons.testnestedflatbufferAsMonster();

        TestEq(nestedMonsterMana, nestedMonster.mana());
        TestEq(nestedMonsterHp, nestedMonster.hp());
        TestEq(nestedMonsterName, nestedMonster.name());
    }

    static void TestCreateByteVector() {
        FlatBufferBuilder fbb = new FlatBufferBuilder(16);
        int str = fbb.createString("MyMonster");
        byte[] inventory = new byte[] { 0, 1, 2, 3, 4 };
        int vec = fbb.createByteVector(inventory);
        Monster.startMonster(fbb);
        Monster.addInventory(fbb, vec);
        Monster.addName(fbb, str);
        int monster1 = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, monster1);
        Monster monsterObject = Monster.getRootAsMonster(fbb.dataBuffer());

        TestEq(monsterObject.inventory(1), (int)inventory[1]);
        TestEq(monsterObject.inventoryLength(), inventory.length);
        TestEq(ByteBuffer.wrap(inventory), monsterObject.inventoryAsByteBuffer());
    }

    static void TestCreateUninitializedVector() {
        FlatBufferBuilder fbb = new FlatBufferBuilder(16);
        int str = fbb.createString("MyMonster");
        byte[] inventory = new byte[] { 0, 1, 2, 3, 4 };
        ByteBuffer bb = fbb.createUnintializedVector(1, inventory.length, 1);
        for (byte i:inventory) {
            bb.put(i);
        }
        int vec = fbb.endVector();
        Monster.startMonster(fbb);
        Monster.addInventory(fbb, vec);
        Monster.addName(fbb, str);
        int monster1 = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, monster1);
        Monster monsterObject = Monster.getRootAsMonster(fbb.dataBuffer());

        TestEq(monsterObject.inventory(1), (int)inventory[1]);
        TestEq(monsterObject.inventoryLength(), inventory.length);
        TestEq(ByteBuffer.wrap(inventory), monsterObject.inventoryAsByteBuffer());
    }

    static void TestReflection() {
        byte[] data = null;
        File file = new File("monster_test.bfbs");
        RandomAccessFile f = null;
        try {
            f = new RandomAccessFile(file, "r");
            data = new byte[(int)f.length()];
            f.readFully(data);
            f.close();
        } catch(IOException e) {
            System.err.println("FlatBuffers test: couldn't read binary schema file");
            return;
        } finally {
            if (f != null) {
                try {
                    f.close();
                } catch (IOException e) {
                    //ignored
                }
            }
        }

        // Now test it:
        ByteBuffer bb = ByteBuffer.wrap(data);
        Schema schema = Schema.getRootAsSchema(bb);
        com.google.flatbuffers.reflection.Object rootTable = schema.rootTable();
        TestEq(rootTable.name(), "MyGame.Example.Monster");
        TestEq(rootTable.fieldsLength(), 41);
        Field hpField = rootTable.fieldsByKey("hp");
        TestEq(hpField.name(), "hp");
        TestEq(hpField.id(), 2);
        // Now use it to dynamically access a buffer.

        TestReflectionBool(rootTable);
        TestReflectionBools(rootTable);
        TestReflectionByte(rootTable);
        TestReflectionBytes(rootTable);
        TestReflectionUByte(rootTable);
        TestReflectionUBytes(rootTable);
        TestReflectionShort(rootTable);
        TestReflectionShorts(rootTable);
        TestReflectionUShort(schema);
        TestReflectionUShorts(rootTable);
        TestReflectionInt(rootTable);
        TestReflectionInts(rootTable);
        TestReflectionUInt(rootTable);
        TestReflectionUInts(rootTable);
        TestReflectionLong(rootTable);
        TestReflectionLongs(rootTable);
        TestReflectionULong(rootTable);
        TestReflectionULongs(rootTable);
        TestReflectionFloat(rootTable);
        TestReflectionFloats(rootTable);
        TestReflectionDouble(rootTable);
        TestReflectionDoubles(rootTable);
        TestReflectionString(schema);
        TestReflectionStrings(rootTable);
        TestReflectionObj(rootTable);
        TestReflectionObjs(rootTable);
    }

    static void TestReflectionBool(com.google.flatbuffers.reflection.Object rootTable) {
        // Now use it to dynamically access a buffer.
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test-short");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());

        Field nameField = rootTable.fieldsByKey("name");

        //test not valued boolean
        Field testboolField = rootTable.fieldsByKey("testbool");
        boolean hasTestbool = Reflection.isFieldPresent(root, testboolField);
        TestEq(hasTestbool, false);
        boolean testbool = Reflection.getBoolField(root, testboolField);
        TestEq(testbool, false);
        testbool = Reflection.getBoolField(root, testboolField, true);
        TestEq(testbool, true);
        TestEq(Reflection.setBoolField(root, testboolField, true), false);
        testbool = Reflection.getBoolField(root, testboolField);
        TestEq(testbool, false);
        // test valued boolean
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test-bool");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestbool(fbb, true);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer());
        hasTestbool = Reflection.isFieldPresent(root, testboolField);
        TestEq(hasTestbool, true);
        testbool = Reflection.getBoolField(root, testboolField);
        TestEq(testbool, true);
        testbool = Reflection.getBoolField(root, testboolField, false);
        TestEq(testbool, true);
        TestEq(Reflection.setBoolField(root, testboolField, false), true);
        testbool = Reflection.getBoolField(root, testboolField);
        TestEq(testbool, false);
        // test wrong type access
        try {
            Reflection.getBoolField(root, nameField);
            throw new AssertionError("Expected IllegalArgumentException when access a field of wrong type");
        } catch (IllegalArgumentException ex) {
            // expected exception
        }
    }

    static void TestReflectionBools(com.google.flatbuffers.reflection.Object rootTable) {
        Field field = rootTable.fieldsByKey("testarrayofbools");
        // test not valued
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());
        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        int vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 0);
        boolean vectorElement = Reflection.getBoolsField(root, field, 10);
        TestEq(vectorElement, false);
        vectorElement = Reflection.getBoolsField(root, field, true, 10);
        TestEq(vectorElement, true);
        // test valued
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        int inv = Monster.createTestarrayofboolsVector(fbb, new boolean[] { true, false, true, false, true});
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestarrayofbools(fbb, inv);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);
        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 5);
        vectorElement = Reflection.getBoolsField(root, field, 0);
        TestEq(vectorElement, true);
        vectorElement = Reflection.getBoolsField(root, field, 1);
        TestEq(vectorElement, false);
        vectorElement = Reflection.getBoolsField(root, field, 2);
        TestEq(vectorElement, true);
        vectorElement = Reflection.getBoolsField(root, field, false, 2);
        TestEq(vectorElement, true);
        TestEq(Reflection.setBoolsField(root, field, true, 1), true);
        vectorElement = Reflection.getBoolsField(root, field, 1);
        TestEq(vectorElement, true);
    }

    static void TestReflectionByte(com.google.flatbuffers.reflection.Object rootTable) {
        // not valuated
        Field field = rootTable.fieldsByKey("testbyte");

        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());

        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        byte fieldValue = Reflection.getByteField(root, field);
        TestEq(fieldValue, (byte)0);
        fieldValue = Reflection.getByteField(root, field, (byte)42);
        TestEq(fieldValue, (byte)42);
        TestEq(Reflection.setByteField(root, field, (byte)42), false);
        fieldValue = Reflection.getByteField(root, field);
        TestEq(fieldValue, (byte)0);

        // valuated
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestbyte(fbb, (byte)42);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);

        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        fieldValue = Reflection.getByteField(root, field);
        TestEq(fieldValue, (byte)42);
        fieldValue = Reflection.getByteField(root, field, (byte)0);
        TestEq(fieldValue, (byte)42);
        TestEq(Reflection.setByteField(root, field, (byte)1), true);
        fieldValue = Reflection.getByteField(root, field);
        TestEq(fieldValue, (byte)1);
        // test wrong type access
        try {
            Reflection.getByteField(root, rootTable.fieldsByKey("name"));
            throw new AssertionError("Expected IllegalArgumentException when access a field of wrong type");
        } catch (IllegalArgumentException ex) {
            // expected exception
        }
    }

    static void TestReflectionBytes(com.google.flatbuffers.reflection.Object rootTable) {
        Field field = rootTable.fieldsByKey("testarrayofbytes");
        // test not valued
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());
        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        int vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 0);
        int vectorElement = Reflection.getBytesField(root, field, 10);
        TestEq(vectorElement, 0);
        vectorElement = Reflection.getBytesField(root, field, (byte) 42, 10);
        TestEq(vectorElement, 42);
        // test valued
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        int inv = Monster.createTestarrayofbytesVector(fbb, new byte[] { 0, 1, 2, 3, 4});
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestarrayofbytes(fbb, inv);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);
        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 5);
        vectorElement = Reflection.getBytesField(root, field, 0);
        TestEq(vectorElement, 0);
        vectorElement = Reflection.getBytesField(root, field, 1);
        TestEq(vectorElement, 1);
        vectorElement = Reflection.getBytesField(root, field, 2);
        TestEq(vectorElement, 2);
        vectorElement = Reflection.getBytesField(root, field, (byte) 42, 2);
        TestEq(vectorElement, 2);
    }

    static void TestReflectionUByte(com.google.flatbuffers.reflection.Object rootTable) {
        // not valuated
        Field field = rootTable.fieldsByKey("testubyte");

        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());

        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        int fieldValue = Reflection.getUByteField(root, field);
        TestEq(fieldValue, 0);
        fieldValue = Reflection.getUByteField(root, field, 42);
        TestEq(fieldValue, 42);
        TestEq(Reflection.setUByteField(root, field, 42), false);
        fieldValue = Reflection.getUByteField(root, field);
        TestEq(fieldValue, 0);

        // valuated
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestubyte(fbb, 42);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);

        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        fieldValue = Reflection.getUByteField(root, field);
        TestEq(fieldValue, 42);
        fieldValue = Reflection.getUByteField(root, field, 0);
        TestEq(fieldValue, 42);
        TestEq(Reflection.setUByteField(root, field, 1), true);
        fieldValue = Reflection.getUByteField(root, field);
        TestEq(fieldValue, 1);
        // test wrong type access
        try {
            Reflection.getByteField(root, rootTable.fieldsByKey("name"));
            throw new AssertionError("Expected IllegalArgumentException when access a field of wrong type");
        } catch (IllegalArgumentException ex) {
            // expected exception
        }
    }

    static void TestReflectionUBytes(com.google.flatbuffers.reflection.Object rootTable) {
        Field field = rootTable.fieldsByKey("inventory");
        // test not valued
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());
        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        int vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 0);
        int vectorElement = Reflection.getUBytesField(root, field, 10);
        TestEq(vectorElement, 0);
        vectorElement = Reflection.getUBytesField(root, field, 42, 10);
        TestEq(vectorElement, 42);
        // test valued
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        int inv = Monster.createInventoryVector(fbb, new byte[] { 0, 1, 2, 3, 4});
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addInventory(fbb, inv);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);
        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 5);
        vectorElement = Reflection.getUBytesField(root, field, 0);
        TestEq(vectorElement, 0);
        vectorElement = Reflection.getUBytesField(root, field, 1);
        TestEq(vectorElement, 1);
        vectorElement = Reflection.getUBytesField(root, field, 2);
        TestEq(vectorElement, 2);
        vectorElement = Reflection.getUBytesField(root, field, 42, 2);
        TestEq(vectorElement, 2);
    }

    static void TestReflectionShort(com.google.flatbuffers.reflection.Object rootTable) {
        // Now use it to dynamically access a buffer.
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test-short");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addHp(fbb, (short) 80);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());

        Field hpField = rootTable.fieldsByKey("hp");
        Field nameField = rootTable.fieldsByKey("name");

        // test valued short
        boolean hasHp = Reflection.isFieldPresent(root, hpField);
        TestEq(hasHp, true);
        short shortHp = Reflection.getShortField(root, hpField);
        TestEq(shortHp, (short) 80);
        TestEq(Reflection.setShortField(root, hpField, (short) 200), true);
        shortHp = Reflection.getShortField(root, hpField); //<- maybe provide a way to specify your default
        TestEq(shortHp, (short) 200);
        // Reset it, for further tests.
        TestEq(Reflection.setShortField(root, hpField, (short) hpField.defaultInteger()), true);
        // test not valued short
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test-short");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);

        Field manaField = rootTable.fieldsByKey("mana");
        boolean hasMana = Reflection.isFieldPresent(root, manaField);
        TestEq(hasMana, false);
        short shortMana = Reflection.getShortField(root, manaField);
        TestEq(shortMana, (short) 150);
        shortMana = Reflection.getShortField(root, manaField, (short) 42);
        TestEq(shortMana, (short) 42);
        TestEq(Reflection.setShortField(root, manaField, (short) 42), false);
        shortMana = Reflection.getShortField(root, manaField);
        TestEq(shortMana, (short) 150);

        // test wrong type access
        try {
            Reflection.getShortField(root, nameField);
            throw new AssertionError("Expected IllegalArgumentException when access a field of wrong type");
        } catch (IllegalArgumentException ex) {
            // expected exception
        }
    }

    private static void TestReflectionShorts(Object rootTable) {
        Field field = rootTable.fieldsByKey("testarrayofshort");
        // test not valued
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());
        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        int vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 0);
        int vectorElement = Reflection.getShortsField(root, field, 10);
        TestEq(vectorElement, 0);
        vectorElement = Reflection.getShortsField(root, field, (short) 42, 10);
        TestEq(vectorElement, 42);
        // test valued
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        int inv = Monster.createTestarrayofshortVector(fbb, new short[] { 0, 1, 2, 3, 4});
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestarrayofshort(fbb, inv);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);
        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 5);
        vectorElement = Reflection.getShortsField(root, field, 0);
        TestEq(vectorElement, 0);
        vectorElement = Reflection.getShortsField(root, field, 1);
        TestEq(vectorElement, 1);
        vectorElement = Reflection.getShortsField(root, field, 2);
        TestEq(vectorElement, 2);
        vectorElement = Reflection.getShortsField(root, field, (short) 42, 2);
        TestEq(vectorElement, 2);
    }

    static void TestReflectionUShort(Schema schema) {
        // not valuated
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        Stat.startStat(fbb);
        int mon = Stat.endStat(fbb);
        fbb.finish(mon, "STAT");
        com.google.flatbuffers.reflection.Object rootTable = schema.objectsByKey("MyGame.Example.Stat");
        Table root = Reflection.getRootTable(fbb.dataBuffer());
        Field field = rootTable.fieldsByKey("count");
        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        int fieldValue = Reflection.getUShortField(root, field);
        TestEq(fieldValue, 0);
        fieldValue = Reflection.getUShortField(root, field, 42);
        TestEq(fieldValue, 42);
        TestEq(Reflection.setUShortField(root, field, 42), false);
        fieldValue = Reflection.getUShortField(root, field);
        TestEq(fieldValue, 0);

        // valuated
        fbb = new FlatBufferBuilder(1);
        Stat.startStat(fbb);
        Stat.addCount(fbb, Short.MAX_VALUE + 1);
        mon = Stat.endStat(fbb);
        fbb.finish(mon, "STAT");
        root = Reflection.getRootTable(fbb.dataBuffer(), root);

        field = rootTable.fieldsByKey("count");
        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        fieldValue = Reflection.getUShortField(root, field);
        TestEq(fieldValue, Short.MAX_VALUE + 1);
        fieldValue = Reflection.getUShortField(root, field, Short.MAX_VALUE + 2);
        TestEq(fieldValue, Short.MAX_VALUE + 1);
        TestEq(Reflection.setUShortField(root, field, Short.MAX_VALUE + 2), true);
        fieldValue = Reflection.getUShortField(root, field);
        TestEq(fieldValue, Short.MAX_VALUE + 2);
        // test wrong type access
        try {
            Reflection.getUShortField(root, rootTable.fieldsByKey("id"));
            throw new AssertionError("Expected IllegalArgumentException when access a field of wrong type");
        } catch (IllegalArgumentException ex) {
            // expected exception
        }

    }

    private static void TestReflectionUShorts(Object rootTable) {
        Field field = rootTable.fieldsByKey("testarrayofushort");
        // test not valued
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());
        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        int vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 0);
        int vectorElement = Reflection.getUShortsField(root, field, 10);
        TestEq(vectorElement, 0);
        vectorElement = Reflection.getUShortsField(root, field, 42, 10);
        TestEq(vectorElement, 42);
        // test valued
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        int inv = Monster.createTestarrayofushortVector(fbb, new short[] { 0, 10, 20, 30, 40});
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestarrayofushort(fbb, inv);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);
        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 5);
        vectorElement = Reflection.getUShortsField(root, field, 0);
        TestEq(vectorElement, 0);
        vectorElement = Reflection.getUShortsField(root, field, 1);
        TestEq(vectorElement, 10);
        vectorElement = Reflection.getUShortsField(root, field, 2);
        TestEq(vectorElement, 20);
        vectorElement = Reflection.getUShortsField(root, field, 42, 2);
        TestEq(vectorElement, 20);
    }

    static void TestReflectionInt(com.google.flatbuffers.reflection.Object rootTable) {
        // not valuated
        Field field = rootTable.fieldsByKey("testhashs32_fnv1");

        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());

        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        int fieldValue = Reflection.getIntField(root, field);
        TestEq(fieldValue, 0);
        fieldValue = Reflection.getIntField(root, field, 42);
        TestEq(fieldValue, 42);
        TestEq(Reflection.setIntField(root, field, 42), false);
        fieldValue = Reflection.getIntField(root, field);
        TestEq(fieldValue, 0);

        // valuated
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTesthashs32Fnv1(fbb, 42);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);

        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        fieldValue = Reflection.getIntField(root, field);
        TestEq(fieldValue, 42);
        fieldValue = Reflection.getIntField(root, field, 0);
        TestEq(fieldValue, 42);
        TestEq(Reflection.setIntField(root, field, 1), true);
        fieldValue = Reflection.getIntField(root, field);
        TestEq(fieldValue, 1);
        // test wrong type access
        try {
            Reflection.getIntField(root, rootTable.fieldsByKey("hp"));
            throw new AssertionError("Expected IllegalArgumentException when access a field of wrong type");
        } catch (IllegalArgumentException ex) {
            // expected exception
        }
    }

    private static void TestReflectionInts(Object rootTable) {
        Field field = rootTable.fieldsByKey("testarrayofint");
        // test not valued
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());
        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        int vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 0);
        int vectorElement = Reflection.getIntsField(root, field, 10);
        TestEq(vectorElement, 0);
        vectorElement = Reflection.getIntsField(root, field, 42, 10);
        TestEq(vectorElement, 42);
        // test valued
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        int inv = Monster.createTestarrayofintVector(fbb, new int[] { 0, 10, 20, 30, 40});
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestarrayofint(fbb, inv);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);
        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 5);
        vectorElement = Reflection.getIntsField(root, field, 0);
        TestEq(vectorElement, 0);
        vectorElement = Reflection.getIntsField(root, field, 1);
        TestEq(vectorElement, 10);
        vectorElement = Reflection.getIntsField(root, field, 2);
        TestEq(vectorElement, 20);
        vectorElement = Reflection.getIntsField(root, field, 42, 2);
        TestEq(vectorElement, 20);
    }


    static void TestReflectionUInt(com.google.flatbuffers.reflection.Object rootTable) {
        // not valuated
        Field field = rootTable.fieldsByKey("testhashu32_fnv1");

        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());

        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        long fieldValue = Reflection.getUIntField(root, field);
        TestEq(fieldValue, 0L);
        fieldValue = Reflection.getUIntField(root, field, Integer.MAX_VALUE + 1L);
        TestEq(fieldValue, Integer.MAX_VALUE + 1L);
        TestEq(Reflection.setUIntField(root, field, Integer.MAX_VALUE + 1L), false);
        fieldValue = Reflection.getUIntField(root, field);
        TestEq(fieldValue, 0L);

        // valuated
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTesthashu32Fnv1(fbb, Integer.MAX_VALUE + 1L);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);

        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        fieldValue = Reflection.getUIntField(root, field);
        TestEq(fieldValue, Integer.MAX_VALUE + 1L);
        fieldValue = Reflection.getUIntField(root, field, Integer.MAX_VALUE + 1L);
        TestEq(fieldValue, Integer.MAX_VALUE + 1L);
        TestEq(Reflection.setUIntField(root, field, 1L), true);
        fieldValue = Reflection.getUIntField(root, field);
        TestEq(fieldValue, 1L);
        // test wrong type access
        try {
            Reflection.getUIntField(root, rootTable.fieldsByKey("hp"));
            throw new AssertionError("Expected IllegalArgumentException when access a field of wrong type");
        } catch (IllegalArgumentException ex) {
            // expected exception
        }
    }

    private static void TestReflectionUInts(Object rootTable) {
        Field field = rootTable.fieldsByKey("testarrayofuint");
        // test not valued
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());
        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        int vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 0);
        long vectorElement = Reflection.getUIntsField(root, field, 10);
        TestEq(vectorElement, 0L);
        vectorElement = Reflection.getUIntsField(root, field, 42L, 10);
        TestEq(vectorElement, 42L);
        // test valued
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        int inv = Monster.createTestarrayofuintVector(fbb, new int[] { 0, 10, 20, 30, 40});
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestarrayofuint(fbb, inv);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);
        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 5);
        vectorElement = Reflection.getUIntsField(root, field, 0);
        TestEq(vectorElement, 0L);
        vectorElement = Reflection.getUIntsField(root, field, 1);
        TestEq(vectorElement, 10L);
        vectorElement = Reflection.getUIntsField(root, field, 2);
        TestEq(vectorElement, 20L);
        vectorElement = Reflection.getUIntsField(root, field, 42, 2);
        TestEq(vectorElement, 20L);
    }

    static void TestReflectionLong(com.google.flatbuffers.reflection.Object rootTable) {
        // not valuated
        Field field = rootTable.fieldsByKey("testhashs64_fnv1");

        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());

        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        long fieldValue = Reflection.getLongField(root, field);
        TestEq(fieldValue, 0L);
        fieldValue = Reflection.getLongField(root, field, 42);
        TestEq(fieldValue, 42L);
        TestEq(Reflection.setLongField(root, field, 42), false);
        fieldValue = Reflection.getLongField(root, field);
        TestEq(fieldValue, 0L);

        // valuated
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTesthashs64Fnv1(fbb, 42);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);

        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        fieldValue = Reflection.getLongField(root, field);
        TestEq(fieldValue, 42L);
        fieldValue = Reflection.getLongField(root, field, 0);
        TestEq(fieldValue, 42L);
        TestEq(Reflection.setLongField(root, field, 1), true);
        fieldValue = Reflection.getLongField(root, field);
        TestEq(fieldValue, 1L);
        // test wrong type access
        try {
            Reflection.getIntField(root, rootTable.fieldsByKey("hp"));
            throw new AssertionError("Expected IllegalArgumentException when access a field of wrong type");
        } catch (IllegalArgumentException ex) {
            // expected exception
        }
    }

    private static void TestReflectionLongs(Object rootTable) {
        Field field = rootTable.fieldsByKey("testarrayoflong");
        // test not valued
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());
        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        int vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 0);
        long vectorElement = Reflection.getLongsField(root, field, 10);
        TestEq(vectorElement, 0L);
        vectorElement = Reflection.getLongsField(root, field, 42L, 10);
        TestEq(vectorElement, 42L);
        // test valued
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        int inv = Monster.createTestarrayoflongVector(fbb, new long[] { 0L, 10L, 20L, 30L, 40L});
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestarrayoflong(fbb, inv);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);
        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 5);
        vectorElement = Reflection.getLongsField(root, field, 0);
        TestEq(vectorElement, 0L);
        vectorElement = Reflection.getLongsField(root, field, 1);
        TestEq(vectorElement, 10L);
        vectorElement = Reflection.getLongsField(root, field, 2);
        TestEq(vectorElement, 20L);
        vectorElement = Reflection.getLongsField(root, field, 42, 2);
        TestEq(vectorElement, 20L);
    }

    static void TestReflectionULong(com.google.flatbuffers.reflection.Object rootTable) {
        // not valuated
        Field field = rootTable.fieldsByKey("testhashu64_fnv1");

        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());

        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        long fieldValue = Reflection.getULongField(root, field);
        TestEq(fieldValue, 0L);
        fieldValue = Reflection.getULongField(root, field, Long.MAX_VALUE + 1L);
        TestEq(fieldValue, Long.MAX_VALUE + 1L);
        TestEq(Reflection.setULongField(root, field, Long.MAX_VALUE + 1L), false);
        fieldValue = Reflection.getULongField(root, field);
        TestEq(fieldValue, 0L);

        // valuated
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTesthashu64Fnv1(fbb, Long.MAX_VALUE + 1L);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);

        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        fieldValue = Reflection.getULongField(root, field);
        TestEq(fieldValue, Long.MAX_VALUE + 1L);
        fieldValue = Reflection.getULongField(root, field, Long.MAX_VALUE + 1L);
        TestEq(fieldValue, Long.MAX_VALUE + 1L);
        TestEq(Reflection.setULongField(root, field, 1L), true);
        fieldValue = Reflection.getULongField(root, field);
        TestEq(fieldValue, 1L);
        // test wrong type access
        try {
            Reflection.getULongField(root, rootTable.fieldsByKey("hp"));
            throw new AssertionError("Expected IllegalArgumentException when access a field of wrong type");
        } catch (IllegalArgumentException ex) {
            // expected exception
        }
    }

    private static void TestReflectionULongs(Object rootTable) {
        Field field = rootTable.fieldsByKey("testarrayofulong");
        // test not valued
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());
        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        int vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 0);
        long vectorElement = Reflection.getULongsField(root, field, 10);
        TestEq(vectorElement, 0L);
        vectorElement = Reflection.getULongsField(root, field, 42L, 10);
        TestEq(vectorElement, 42L);
        // test valued
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        int inv = Monster.createTestarrayoflongVector(fbb, new long[] { 0L, 10L, 20L, 30L, 40L});
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestarrayofulong(fbb, inv);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);
        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 5);
        vectorElement = Reflection.getULongsField(root, field, 0);
        TestEq(vectorElement, 0L);
        vectorElement = Reflection.getULongsField(root, field, 1);
        TestEq(vectorElement, 10L);
        vectorElement = Reflection.getULongsField(root, field, 2);
        TestEq(vectorElement, 20L);
        vectorElement = Reflection.getULongsField(root, field, 42, 2);
        TestEq(vectorElement, 20L);
    }

    static void TestReflectionFloat(com.google.flatbuffers.reflection.Object rootTable) {
        // not valuated
        Field field = rootTable.fieldsByKey("testf3");

        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());

        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        float fieldValue = Reflection.getFloatField(root, field);
        TestEq(fieldValue, 0F);
        fieldValue = Reflection.getFloatField(root, field, 42);
        TestEq(fieldValue, 42F);
        TestEq(Reflection.setFloatField(root, field, 42), false);
        fieldValue = Reflection.getFloatField(root, field);
        TestEq(fieldValue, 0F);

        // valuated
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestf3(fbb, 42);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);

        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        fieldValue = Reflection.getFloatField(root, field);
        TestEq(fieldValue, 42F);
        fieldValue = Reflection.getFloatField(root, field, 0);
        TestEq(fieldValue, 42F);
        TestEq(Reflection.setFloatField(root, field, 1.1F), true);
        fieldValue = Reflection.getFloatField(root, field);
        TestEq(fieldValue, 1.1F);
        // test wrong type access
        try {
            Reflection.getFloatField(root, rootTable.fieldsByKey("hp"));
            throw new AssertionError("Expected IllegalArgumentException when access a field of wrong type");
        } catch (IllegalArgumentException ex) {
            // expected exception
        }
    }

    private static void TestReflectionFloats(Object rootTable) {
        Field field = rootTable.fieldsByKey("testarrayoffloat");
        // test not valued
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());
        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        int vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 0);
        float vectorElement = Reflection.getFloatsField(root, field, 10);
        TestEq(vectorElement, 0F);
        vectorElement = Reflection.getFloatsField(root, field, 42F, 10);
        TestEq(vectorElement, 42F);
        // test valued
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        int inv = Monster.createTestarrayoffloatVector(fbb, new float[] { 0F, 10F, 20F, 30F, 40F});
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestarrayoffloat(fbb, inv);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);
        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 5);
        vectorElement = Reflection.getFloatsField(root, field, 0);
        TestEq(vectorElement, 0F);
        vectorElement = Reflection.getFloatsField(root, field, 1);
        TestEq(vectorElement, 10F);
        vectorElement = Reflection.getFloatsField(root, field, 2);
        TestEq(vectorElement, 20F);
        vectorElement = Reflection.getFloatsField(root, field, 42F, 2);
        TestEq(vectorElement, 20F);
    }

    static void TestReflectionDouble(Object rootTable) {
        // not valuated
        Field field = rootTable.fieldsByKey("testdouble");

        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());

        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        double fieldValue = Reflection.getDoubleField(root, field);
        TestEq(fieldValue, 0D);
        fieldValue = Reflection.getDoubleField(root, field, 42D);
        TestEq(fieldValue, 42D);
        TestEq(Reflection.setDoubleField(root, field, 42D), false);
        fieldValue = Reflection.getDoubleField(root, field);
        TestEq(fieldValue, 0D);

        // valuated
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestdouble(fbb, 42);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);

        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        fieldValue = Reflection.getDoubleField(root, field);
        TestEq(fieldValue, 42D);
        fieldValue = Reflection.getDoubleField(root, field, 0);
        TestEq(fieldValue, 42D);
        TestEq(Reflection.setDoubleField(root, field, 1.1D), true);
        fieldValue = Reflection.getDoubleField(root, field);
        TestEq(fieldValue, 1.1D);
        // test wrong type access
        try {
            Reflection.getDoubleField(root, rootTable.fieldsByKey("hp"));
            throw new AssertionError("Expected IllegalArgumentException when access a field of wrong type");
        } catch (IllegalArgumentException ex) {
            // expected exception
        }
    }

    static void TestReflectionDoubles(Object rootTable) {
        Field field = rootTable.fieldsByKey("testarrayofdouble");
        // test not valued
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());
        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        int vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 0);
        double vectorElement = Reflection.getDoublesField(root, field, 10);
        TestEq(vectorElement, 0D);
        vectorElement = Reflection.getDoublesField(root, field, 42D, 10);
        TestEq(vectorElement, 42D);
        // test valued
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        int inv = Monster.createTestarrayofdoubleVector(fbb, new double[] { 0D, 10D, 20D, 30D, 40D});
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestarrayofdouble(fbb, inv);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);
        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 5);
        vectorElement = Reflection.getDoublesField(root, field, 0);
        TestEq(vectorElement, 0D);
        vectorElement = Reflection.getDoublesField(root, field, 1);
        TestEq(vectorElement, 10D);
        vectorElement = Reflection.getDoublesField(root, field, 2);
        TestEq(vectorElement, 20D);
        vectorElement = Reflection.getDoublesField(root, field, 42D, 2);
        TestEq(vectorElement, 20D);
    }

    static void TestReflectionString(Schema schema) {
        // not valuated
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        Stat.startStat(fbb);
        int mon = Stat.endStat(fbb);
        fbb.finish(mon, "STAT");
        com.google.flatbuffers.reflection.Object rootTable = schema.objectsByKey("MyGame.Example.Stat");
        Table root = Reflection.getRootTable(fbb.dataBuffer());
        Field field = rootTable.fieldsByKey("id");

        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        String fieldValue = Reflection.getStringField(root, field);
        TestEq(fieldValue == null, true);
        fieldValue = Reflection.getStringField(root, field, "42");
        TestEq(fieldValue, "42");

        // valuated
        fbb = new FlatBufferBuilder(1);
        int idPos = fbb.createString("test");
        Stat.startStat(fbb);
        Stat.addId(fbb, idPos);
        mon = Stat.endStat(fbb);
        fbb.finish(mon, "STAT");
        rootTable = schema.objectsByKey(rootTable, "MyGame.Example.Stat");
        root = Reflection.getRootTable(fbb.dataBuffer(), root);

        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        fieldValue = Reflection.getStringField(root, field);
        TestEq(fieldValue, "test");
        fieldValue = Reflection.getStringField(root, field, null);
        TestEq(fieldValue, "test");
        // test wrong type access
        try {
            Reflection.getIntField(root, rootTable.fieldsByKey("count"));
            throw new AssertionError("Expected IllegalArgumentException when access a field of wrong type");
        } catch (IllegalArgumentException ex) {
            // expected exception
        }
    }

    static void TestReflectionStrings(com.google.flatbuffers.reflection.Object rootTable) {
        Field field = rootTable.fieldsByKey("testarrayofstring");
        // test not valued
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());
        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        int vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 0);
        String vectorElement = Reflection.getStringsField(root, field, 10);
        TestEq(vectorElement == null, true);
        vectorElement = Reflection.getStringsField(root, field, vectorElement, 10);
        TestEq(vectorElement == null, true);
        vectorElement = Reflection.getStringsField(root, field, "test", 10);
        TestEq(vectorElement, "test");
        // test valued
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        int vectorPos = Monster.createTestarrayofstringVector(fbb, new int[]{fbb.createString("Frodo"), fbb.createString("Barney"), fbb.createString("Wilma")});
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestarrayofstring(fbb, vectorPos);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);
        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 3);
        vectorElement = Reflection.getStringsField(root, field, 0);
        TestEq(vectorElement, "Frodo");
        vectorElement = Reflection.getStringsField(root, field, 1);
        TestEq(vectorElement, "Barney");
        vectorElement = Reflection.getStringsField(root, field, 2);
        TestEq(vectorElement, "Wilma");
        vectorElement = Reflection.getStringsField(root, field, "default", 2);
        TestEq(vectorElement, "Wilma");
    }


    static void TestReflectionObj(com.google.flatbuffers.reflection.Object rootTable) {
        // not valuated obj
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test-obj");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());

        Field field = rootTable.fieldsByKey("testempty");
        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        Table childTable = Reflection.getObjField(root, field);
        TestEq(childTable == null, true);
        Table toReuse = new Table();
        childTable = Reflection.getObjField(root, field, toReuse);
        TestEq(childTable == null, true);

        // valuated obj
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test-obj");
        Stat.startStat(fbb);
        int i = Stat.endStat(fbb);
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestempty(fbb, i);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);

        field = rootTable.fieldsByKey("testempty");
        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        childTable = Reflection.getObjField(root, field);
        TestEq(childTable != null, true);
        toReuse = new Table();
        childTable = Reflection.getObjField(root, field, toReuse);
        //memory equality check
        TestEq(childTable == toReuse, true);
    }

    static void TestReflectionObjs(com.google.flatbuffers.reflection.Object rootTable) {
        Field field = rootTable.fieldsByKey("testarrayoftables");
        // test not valued
        FlatBufferBuilder fbb = new FlatBufferBuilder(1);
        int namePos = fbb.createString("test");
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        int mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        Table root = Reflection.getRootTable(fbb.dataBuffer());
        boolean hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, false);
        int vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 0);
        Table vectorElement = Reflection.getObjsField(root, field, 10);
        TestEq(vectorElement == null, true);
        vectorElement = Reflection.getObjsField(root, field, vectorElement, 10);
        TestEq(vectorElement == null, true);
        // test valued
        fbb = new FlatBufferBuilder(1);
        namePos = fbb.createString("test");
        int[] names = {fbb.createString("Frodo"), fbb.createString("Barney"), fbb.createString("Wilma")};
        int[] off = new int[3];
        Monster.startMonster(fbb);
        Monster.addName(fbb, names[0]);
        off[0] = Monster.endMonster(fbb);
        Monster.startMonster(fbb);
        Monster.addName(fbb, names[1]);
        off[1] = Monster.endMonster(fbb);
        Monster.startMonster(fbb);
        Monster.addName(fbb, names[2]);
        off[2] = Monster.endMonster(fbb);
        int sortMons = fbb.createSortedVectorOfTables(new Monster(), off);
        Monster.startMonster(fbb);
        Monster.addName(fbb, namePos);
        Monster.addTestarrayoftables(fbb, sortMons);
        mon = Monster.endMonster(fbb);
        Monster.finishMonsterBuffer(fbb, mon);
        root = Reflection.getRootTable(fbb.dataBuffer(), root);
        hasValue = Reflection.isFieldPresent(root, field);
        TestEq(hasValue, true);
        vectorLength = Reflection.getVectorLength(root, field);
        TestEq(vectorLength, 3);
        vectorElement = Reflection.getObjsField(root, field, 0);
        TestEq(vectorElement != null, true);
        TestEq(Reflection.getStringField(vectorElement, rootTable.fieldsByKey("name")) , "Barney");
        vectorElement = Reflection.getObjsField(root, field, 1);
        TestEq(vectorElement != null, true);
        TestEq(Reflection.getStringField(vectorElement, rootTable.fieldsByKey("name")) , "Frodo");
        vectorElement = Reflection.getObjsField(root, field, 2);
        TestEq(vectorElement != null, true);
        TestEq(Reflection.getStringField(vectorElement, rootTable.fieldsByKey("name")), "Wilma");
        Table toReuse = new Table();
        vectorElement = Reflection.getObjsField(root, field, toReuse, 2);
        TestEq(vectorElement == toReuse, true);

    }

    private static MasterDict loadMasterDict(String path) {
        byte data[] = loadBinaryFile(path);
        ByteBuffer bb = ByteBuffer.wrap(data);
        TestEq(MasterDict.MasterDictBufferHasIdentifier(bb), true);
        return MasterDict.getRootAsMasterDict(bb);
    }

    private static void TestKeySearchAllMissing() {
        MasterDict mdict = loadMasterDict("keysearch_test/keysearch_test_all_missing.mdict");
        checkMasterDictEntriesSize(mdict, 0);
        // check non existing entry
        checkNonExistingEntries(mdict);
    }

    private static void TestKeySearchEmpty() {
        MasterDict mdict = loadMasterDict("keysearch_test/keysearch_test_empty_arrays.mdict");
        checkMasterDictEntriesSize(mdict, 0);
        // check non existing entry
        checkNonExistingEntries(mdict);
    }

    private static void checkMasterDictEntriesSize(MasterDict mdict, int expectedSize) {
        TestEq( mdict.boolEntriesLength(), expectedSize);
        TestEq( mdict.byteEntriesLength(), expectedSize);
        TestEq( mdict.ubyteEntriesLength(), expectedSize);
        TestEq( mdict.shortEntriesLength(), expectedSize);
        TestEq( mdict.ushortEntriesLength(), expectedSize);
        TestEq( mdict.intEntriesLength(), expectedSize);
        TestEq( mdict.uintEntriesLength(), expectedSize);
        TestEq( mdict.longEntriesLength(), expectedSize);
        TestEq( mdict.ulongEntriesLength(), expectedSize);
        TestEq( mdict.stringEntriesLength(), expectedSize);
        TestEq( mdict.floatEntriesLength(), expectedSize);
        TestEq( mdict.doubleEntriesLength(), expectedSize);
        // check non existing entry
        checkNonExistingEntries(mdict);
    }

    private static void TestKeySearchOneEntry() {
        MasterDict mdict = loadMasterDict("keysearch_test/keysearch_test_1entry.mdict");
        checkMasterDictEntriesSize(mdict, 1);
        // check existing entry
        TestEq( TestNotNull( mdict.boolEntriesByKey(true) ).value(), true );

        TestEq( TestNotNull( mdict.byteEntriesByKey((byte)-212) ).value(), (byte)-128 );
        TestEq( TestNotNull( mdict.shortEntriesByKey((short)-16123) ).value(), (short)-32768 );
        TestEq( TestNotNull( mdict.intEntriesByKey(-2123456789) ).value(), -2147483648 );
        TestEq( TestNotNull( mdict.longEntriesByKey(-41234567890L) ).value(), -9223372036854775808L );

        TestEq( TestNotNull( mdict.ubyteEntriesByKey(212) ).value(), 255 );
        TestEq( TestNotNull( mdict.ushortEntriesByKey(61234) ).value(), 65535 );
        TestEq( TestNotNull( mdict.uintEntriesByKey(4123456789L) ).value(), 4294967295L );
        TestEq( TestNotNull( mdict.ulongEntriesByKey(41234567890L) ).value(), 9223372036854775807L );

        TestEq( TestNotNull( mdict.floatEntriesByKey(12345.5f) ).value(), 1234f );
        TestEq( TestNotNull( mdict.doubleEntriesByKey(1234567890.5) ).value(), 4567.0 );
        TestEq( TestNotNull( mdict.stringEntriesByKey("some key") ).value(), 7890 );
        TestEq( TestNotNull( mdict.enumEntriesByKey(FruitFilter.Apricot) ).value(), 7412 );
        // check non existing entry
        checkNonExistingEntries(mdict);
    }

    private static void checkNonExistingEntries(MasterDict mdict) {
        TestIsNull( mdict.boolEntriesByKey(false) );
        TestIsNull( mdict.byteEntriesByKey((byte)-211) );
        TestIsNull( mdict.shortEntriesByKey((short)-16120) );
        TestIsNull( mdict.intEntriesByKey(-2123456780) );
        TestIsNull( mdict.longEntriesByKey(-41234567891L) );
        TestIsNull( mdict.ubyteEntriesByKey(213) );
        TestIsNull( mdict.ushortEntriesByKey(61230) );
        TestIsNull( mdict.uintEntriesByKey(4123456780L) );
        TestIsNull( mdict.ulongEntriesByKey(41234567891L) );

        TestIsNull( mdict.floatEntriesByKey(12345.0f) );
        TestIsNull( mdict.doubleEntriesByKey(1234567890.0) );
        TestIsNull( mdict.stringEntriesByKey("bad key") );
        TestIsNull( mdict.stringEntriesByKey("not some key") );
        TestIsNull( mdict.stringEntriesByKey("") );
        TestIsNull( mdict.enumEntriesByKey(FruitFilter.Avocado) );
        TestIsNull( mdict.enumEntriesByKey(FruitFilter.Avocado | FruitFilter.Blueberry) );
    }


    static byte[] BYTE_KEYS = { -128, -108, 4, 27, 79, 87, 116, 120, 127 };
    static short[] SHORT_KEYS = { -32768, -23103, -19823, -19569, 10511, 13604, 29116, 32767 };
    static int[] INT_KEYS = { -2147483648, 289956431, 1578841898, 1591161832, 2008070098, 2147483647 };
    static long[] LONG_KEYS = { -9223372036854775808L, -4426181692283497353L, -3867737981674931192L, 3384947750744670649L, 5930023430429340454L, 6446878210185090927L, 7810001276519378488L, 8296697541656081552L, 9223372036854775807L };
    static int[] UBYTE_KEYS = { 0x0, 0x30, 0x47, 0x4b, 0x6f, (byte)0x80, (byte)0x90, (byte)0xff };
    static int[] USHORT_KEYS = { 0x0, 0x730, 0x1fe3, 0x68b1, 0x855f, 0xa1e4, 0xe2a8, 0xf43a, 0xffff };
    static int[] UINT_KEYS = { 0x0, 0x1beb3711, 0x72ae2244, 0x8a5006c1, 0x8c25166a, 0x8d1fd9b7, 0x966e1277, 0xb4e1357d, 0xeece328b, 0xffffffff };
    static long[] ULONG_KEYS = { 0x0L, 0x151665705b7c709aL, 0x19c16a0d0febd845L, 0x1dfc83524562be7fL, 0x38701a14b490b608L, 0x3e37952d30bcab0eL, 0x552116dd2ba4b180L, 0x73581a8146743741L, 0x7c879b741d878f9fL, 0x7fffffffffffffffL };
    static float[] FLOAT_KEYS = { -1048576.0f, -936601.75f, -738210.75f, -664663.75f, -546537.0f, -526621.25f, -257863.25f, 503903.25f, 592275.0f, 1048576.0f };
    static double[] DOUBLE_KEYS = { -1125899906842624.0, -850797801804121.2, -810628627134711.5, -249540797891042.25, 1032376053261822.5, 1125899906842624.0 };
    static String[] STRING_KEYS = { "", "Apple", "Apricot", "Avocado", "Banana", "Blackberry", "Blackcurrant", "Cherimoya", "Cherry", "Coconut", "Currant" };
    static int[] ENUM_KEYS = { 0, 38639505, 96807436, 161631183, 188062643, 234112573, 268435455 };
    static long BYTE_TOTAL = 333;
    static long SHORT_TOTAL = 256;
    static long INT_TOTAL = 132;
    static long LONG_TOTAL = 333;
    static long UBYTE_TOTAL = 288;
    static long USHORT_TOTAL = 369;
    static long UINT_TOTAL = 460;
    static long ULONG_TOTAL = 460;
    static long DOUBLE_TOTAL = 132;
    static long FLOAT_TOTAL = 420;
    static long STRING_TOTAL = 517;
    static long ENUM_TOTAL = 217;


    private static void TestKeySearchManyEntries() {
        MasterDict mdict = loadMasterDict("keysearch_test/keysearch_test_many.mdict");
        TestEq( TestNotNull( mdict.boolEntriesByKey(true) ).value(), false);
        TestEq( TestNotNull( mdict.boolEntriesByKey(false) ).value(), true);

        long sum = 0;
        for ( byte key: BYTE_KEYS ) {
            sum += TestNotNull(mdict.byteEntriesByKey(key)).value();
        }
        TestEq(sum, BYTE_TOTAL);

        sum = 0;
        for ( short key: SHORT_KEYS ) {
            sum += TestNotNull(mdict.shortEntriesByKey(key)).value();
        }
        TestEq(sum, SHORT_TOTAL);

        sum = 0;
        for ( int key: INT_KEYS ) {
            sum += TestNotNull(mdict.intEntriesByKey(key)).value();
        }
        TestEq(sum, INT_TOTAL);

        sum = 0;
        for ( long key: LONG_KEYS ) {
            sum += TestNotNull(mdict.longEntriesByKey(key)).value();
        }
        TestEq(sum, LONG_TOTAL);

        sum = 0;
        for ( int key: UBYTE_KEYS ) {
            sum += TestNotNull(mdict.ubyteEntriesByKey(key)).value();
        }
        TestEq(sum, UBYTE_TOTAL);

        sum = 0;
        for ( int  key: USHORT_KEYS ) {
            sum += TestNotNull(mdict.ushortEntriesByKey(key)).value();
        }
        TestEq(sum, USHORT_TOTAL);

        sum = 0;
        for ( int  key: UINT_KEYS ) {
            sum += TestNotNull(mdict.uintEntriesByKey(key)).value();
        }
        TestEq(sum, UINT_TOTAL);

        sum = 0;
        for ( long key: ULONG_KEYS ) {
            sum += TestNotNull(mdict.ulongEntriesByKey(key)).value();
        }
        TestEq(sum, ULONG_TOTAL);

        sum = 0;
        for ( float key: FLOAT_KEYS ) {
            sum += TestNotNull(mdict.floatEntriesByKey(key)).value();
        }
        TestEq(sum, FLOAT_TOTAL);

        sum = 0;
        for ( double key: DOUBLE_KEYS ) {
            sum += TestNotNull(mdict.doubleEntriesByKey(key)).value();
        }
        TestEq(sum, DOUBLE_TOTAL);

        sum = 0;
        for ( String key: STRING_KEYS ) {
            sum += TestNotNull(mdict.stringEntriesByKey(key)).value();
        }
        TestEq(sum, STRING_TOTAL);

        sum = 0;
        for ( int key: ENUM_KEYS ) {
            sum += TestNotNull(mdict.enumEntriesByKey(key)).value();
        }
        TestEq(sum, ENUM_TOTAL);
    }

    private static void TestComparators() {
        // ulong
        TestTrue(Unsigneds.asComparable(0xff00123400000000L) > Unsigneds.asComparable( 0xf500123400000000L));
        TestTrue(Unsigneds.asComparable(0xff00123400000000L) > Unsigneds.asComparable(0x0500123400000000L));
        TestTrue(Unsigneds.asComparable(0x0a00123400000000L) < Unsigneds.asComparable(0x6500123400000000L));
        TestTrue(Unsigneds.asComparable(0xf500123400000000L) < Unsigneds.asComparable(0xff00123400000000L));
        TestTrue(Unsigneds.asComparable(0x0a00123400000000L) < Unsigneds.asComparable(0xf500123400000000L));
        TestEq(Unsigneds.asComparable(0x0123456701234567L), Unsigneds.asComparable(0x0123456701234567L));
        TestEq(Unsigneds.asComparable(0xf123456701234567L), Unsigneds.asComparable(0xf123456701234567L));
        // uint
        TestTrue(Unsigneds.asComparable(0xff001234) > Unsigneds.asComparable(0xf5001234));
        TestTrue(Unsigneds.asComparable(0xff001234) > Unsigneds.asComparable(0x05001234));
        TestTrue(Unsigneds.asComparable(0x0a001234) < Unsigneds.asComparable(0x65001234));
        TestTrue(Unsigneds.asComparable(0x0a001234) < Unsigneds.asComparable(0xf5001234));
        TestTrue(Unsigneds.asComparable(0xf5001234) < Unsigneds.asComparable(0xff001234));
        TestEq(Unsigneds.asComparable(0x1000), Unsigneds.asComparable(0x1000));
        // ushort
        TestTrue(Unsigneds.asComparable((short)0xff00) > Unsigneds.asComparable((short)0xf500));
        TestTrue(Unsigneds.asComparable((short)0xff00) > Unsigneds.asComparable((short)0x0500));
        TestTrue(Unsigneds.asComparable((short)0x0a00) < Unsigneds.asComparable((short)0x6500));
        TestTrue(Unsigneds.asComparable((short)0x0a00) < Unsigneds.asComparable((short)0xf500));
        TestTrue(Unsigneds.asComparable((short)0xf500) < Unsigneds.asComparable((short)0xff00));
        TestEq(Unsigneds.asComparable((short)0x1000), Unsigneds.asComparable((short)0x1000));
        // ubyte
        TestTrue(Unsigneds.asComparable((byte)0xff) > Unsigneds.asComparable((byte)0xf5));
        TestTrue(Unsigneds.asComparable((byte)0xff) > Unsigneds.asComparable((byte)0x05));
        TestTrue(Unsigneds.asComparable((byte)0x0a) < Unsigneds.asComparable((byte)0x65));
        TestTrue(Unsigneds.asComparable((byte)0xff) > Unsigneds.asComparable((byte)0xf5));
        TestTrue(Unsigneds.asComparable((byte)0x0a) < Unsigneds.asComparable((byte)0xf5));
        TestTrue(Unsigneds.asComparable((byte)0xf5) < Unsigneds.asComparable((byte)0xff));
        TestEq(Unsigneds.asComparable((byte)0x10), Unsigneds.asComparable((byte)0x10));
        // float & double
        // Test data generated with python
        // (needs combo of negative/positive value/exponent, different mantissa for same power of 2 exponent)
        // ', '.join( [ '%sf' % x for x in sorted( [ random.choice([1,-1]) * random.random() * 2**random.randint(-10,10) for i in range(0,100) ] ) ] )
        double[] f64Values = new double[] {
                -143.663930398, -113.652899568, -57.6674724098, -47.7881615929, -32.8573599523, -25.3757542442, -6.32289731715, -6.31456830901, -5.31070135, -4.34689485017, -3.9683987984, -3.77747831583, -3.21334229205, -1.71951477365, -1.60658948278, -0.952556291191, -0.645880784258, -0.639279500508, -0.490917570716, -0.480758661742, -0.430461368613, -0.393359440669, -0.26171451558, -0.233956194649, -0.215978677013, -0.159699691152, -0.147267049552, -0.12885988167, -0.0863402225314, -0.0605561496802, -0.0293686367562, -0.0218672554299, -0.0196682721456, -0.0190870460972, -0.0185303183367, -0.0175548904648, -0.014187334648, -0.00970443846519, -0.00664061401173, -0.00658451053374, -0.00499531636611, -0.00323883792399, -0.00285543205163, -0.00194430090891, -0.00193135121601, -0.000781460594343, -0.000361581067952, -0.000201375071369, -0.00012577897114, 0.000109667072611, 0.000552367296112, 0.00100503733061, 0.00138013991957, 0.00140720040359, 0.0018676545782, 0.002480821074, 0.00295872659794, 0.00396726462466, 0.00720701306132, 0.00874833806218, 0.0151344506589, 0.0239002544959, 0.0310522281057, 0.0332880414199, 0.0597915280613, 0.0666664780241, 0.0672830280348, 0.09466846402, 0.174067882818, 0.183172618371, 0.271262363864, 0.345374554716, 0.347832783569, 0.353570486712, 0.377268800891, 0.388081857434, 0.405894787835, 0.463490792581, 0.484713561017, 0.881049757562, 1.13443869833, 1.19067039057, 1.46000154319, 1.51508638199, 1.7192321789, 2.34665982514, 3.93027684079, 4.34501229076, 4.43448289424, 5.29645390738, 26.15645063, 40.1630318705, 51.2642056763, 132.516998412, 142.707085881, 186.532929305, 188.476495226, 263.623368372, 507.657674908, 683.475997903
        };
        boolean allGood = true;
        for ( int index=0; index < f64Values.length; ++index ) {
            double doubleValue = f64Values[index];
            float floatValue = (float)doubleValue;
            boolean good = true;
            int comparable = Floats.asComparable(floatValue);
            if ( index > 0 ) {
                double prevDoubleValue = f64Values[index-1];
                assert prevDoubleValue < doubleValue;
                good = Floats.asComparable((float)(prevDoubleValue)) < comparable;
                good = good && Floats.asComparable(prevDoubleValue) < Floats.asComparable(doubleValue);
            }
            String alert = good ? "" : " (not greater than previous comparable!)";
            System.out.printf("%+04.4f \t-> %+011d = %08x  sign:%08x  exp: %02x  without bias: %+04d  mantissa: %08x    %s\n",
                    floatValue, comparable, comparable,
                    Floats.sign(floatValue), Floats.exp(floatValue), Floats.exp(floatValue) - 127, Floats.mantissa(floatValue),
                    alert);
            allGood = allGood && good;
        }
        TestTrue( allGood );
    }


    static void TestTrue(boolean a) {
        if (!a) {
            System.out.println("FlatBuffers test FAILED: expected true");
            assert false; // Run test with -ea VM options to get callstack
            System.exit(1);
        }
    }

    static <T> void TestEq(T a, T b) {
        if (!a.equals(b)) {
            System.out.println("" + a.getClass().getName() + " " + b.getClass().getName());
            System.out.println("FlatBuffers test FAILED: \'" + a + "\' != \'" + b + "\'");
            assert false; // Run test with -ea VM options to get callstack
            System.exit(1);
        }
    }

    static <T> T TestNotNull(T a) {
        if (a == null) {
            System.out.println("FlatBuffers test FAILED: unexpected null reference");
            assert false; // Run test with -ea VM options to get callstack
            System.exit(1);
        }
        return a;
    }

    static <T> void TestIsNull(T a) {
        if (a != null) {
            System.out.println("FlatBuffers test FAILED: expected null but got '" + a + "'");
            assert false; // Run test with -ea VM options to get callstack
            System.exit(1);
        }
    }
}
