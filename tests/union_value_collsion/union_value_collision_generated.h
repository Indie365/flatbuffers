// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_UNIONVALUECOLLISION_UNION_VALUE_COLLSION_H_
#define FLATBUFFERS_GENERATED_UNIONVALUECOLLISION_UNION_VALUE_COLLSION_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 4,
             "Non-compatible flatbuffers version included");

namespace union_value_collsion {

struct IntValue;
struct IntValueBuilder;
struct IntValueT;

struct Collision;
struct CollisionBuilder;
struct CollisionT;

bool operator==(const IntValueT &lhs, const IntValueT &rhs);
bool operator!=(const IntValueT &lhs, const IntValueT &rhs);
bool operator==(const CollisionT &lhs, const CollisionT &rhs);
bool operator!=(const CollisionT &lhs, const CollisionT &rhs);

inline const flatbuffers::TypeTable *IntValueTypeTable();

inline const flatbuffers::TypeTable *CollisionTypeTable();

enum Value : uint8_t {
  Value_NONE = 0,
  Value_IntValue = 1,
  Value_MIN = Value_NONE,
  Value_MAX = Value_IntValue
};

inline const Value (&EnumValuesValue())[2] {
  static const Value values[] = {
    Value_NONE,
    Value_IntValue
  };
  return values;
}

inline const char * const *EnumNamesValue() {
  static const char * const names[3] = {
    "NONE",
    "IntValue",
    nullptr
  };
  return names;
}

inline const char *EnumNameValue(Value e) {
  if (flatbuffers::IsOutRange(e, Value_NONE, Value_IntValue)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValue()[index];
}

template<typename T> struct ValueTraits {
  static const Value enum_value = Value_NONE;
};

template<> struct ValueTraits<union_value_collsion::IntValue> {
  static const Value enum_value = Value_IntValue;
};

template<typename T> struct ValueUnionTraits {
  static const Value enum_value = Value_NONE;
};

template<> struct ValueUnionTraits<union_value_collsion::IntValueT> {
  static const Value enum_value = Value_IntValue;
};

struct ValueUnion {
  Value type;
  void *value;

  ValueUnion() : type(Value_NONE), value(nullptr) {}
  ValueUnion(ValueUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Value_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ValueUnion(const ValueUnion &);
  ValueUnion &operator=(const ValueUnion &u)
    { ValueUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ValueUnion &operator=(ValueUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ValueUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ValueUnionTraits<RT>::enum_value;
    if (type != Value_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, Value type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  union_value_collsion::IntValueT *AsIntValue() {
    return type == Value_IntValue ?
      reinterpret_cast<union_value_collsion::IntValueT *>(value) : nullptr;
  }
  const union_value_collsion::IntValueT *AsIntValue() const {
    return type == Value_IntValue ?
      reinterpret_cast<const union_value_collsion::IntValueT *>(value) : nullptr;
  }
};


inline bool operator==(const ValueUnion &lhs, const ValueUnion &rhs) {
  if (lhs.type != rhs.type) return false;
  switch (lhs.type) {
    case Value_NONE: {
      return true;
    }
    case Value_IntValue: {
      return *(reinterpret_cast<const union_value_collsion::IntValueT *>(lhs.value)) ==
             *(reinterpret_cast<const union_value_collsion::IntValueT *>(rhs.value));
    }
    default: {
      return false;
    }
  }
}

inline bool operator!=(const ValueUnion &lhs, const ValueUnion &rhs) {
    return !(lhs == rhs);
}

bool VerifyValue(flatbuffers::Verifier &verifier, const void *obj, Value type);
bool VerifyValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum Other : uint8_t {
  Other_NONE = 0,
  Other_IntValue = 1,
  Other_MIN = Other_NONE,
  Other_MAX = Other_IntValue
};

inline const Other (&EnumValuesOther())[2] {
  static const Other values[] = {
    Other_NONE,
    Other_IntValue
  };
  return values;
}

inline const char * const *EnumNamesOther() {
  static const char * const names[3] = {
    "NONE",
    "IntValue",
    nullptr
  };
  return names;
}

inline const char *EnumNameOther(Other e) {
  if (flatbuffers::IsOutRange(e, Other_NONE, Other_IntValue)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOther()[index];
}

template<typename T> struct OtherTraits {
  static const Other enum_value = Other_NONE;
};

template<> struct OtherTraits<union_value_collsion::IntValue> {
  static const Other enum_value = Other_IntValue;
};

template<typename T> struct OtherUnionTraits {
  static const Other enum_value = Other_NONE;
};

template<> struct OtherUnionTraits<union_value_collsion::IntValueT> {
  static const Other enum_value = Other_IntValue;
};

struct OtherUnion {
  Other type;
  void *value;

  OtherUnion() : type(Other_NONE), value(nullptr) {}
  OtherUnion(OtherUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Other_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  OtherUnion(const OtherUnion &);
  OtherUnion &operator=(const OtherUnion &u)
    { OtherUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  OtherUnion &operator=(OtherUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~OtherUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = OtherUnionTraits<RT>::enum_value;
    if (type != Other_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, Other type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  union_value_collsion::IntValueT *AsIntValue() {
    return type == Other_IntValue ?
      reinterpret_cast<union_value_collsion::IntValueT *>(value) : nullptr;
  }
  const union_value_collsion::IntValueT *AsIntValue() const {
    return type == Other_IntValue ?
      reinterpret_cast<const union_value_collsion::IntValueT *>(value) : nullptr;
  }
};


inline bool operator==(const OtherUnion &lhs, const OtherUnion &rhs) {
  if (lhs.type != rhs.type) return false;
  switch (lhs.type) {
    case Other_NONE: {
      return true;
    }
    case Other_IntValue: {
      return *(reinterpret_cast<const union_value_collsion::IntValueT *>(lhs.value)) ==
             *(reinterpret_cast<const union_value_collsion::IntValueT *>(rhs.value));
    }
    default: {
      return false;
    }
  }
}

inline bool operator!=(const OtherUnion &lhs, const OtherUnion &rhs) {
    return !(lhs == rhs);
}

bool VerifyOther(flatbuffers::Verifier &verifier, const void *obj, Other type);
bool VerifyOtherVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct IntValueT : public flatbuffers::NativeTable {
  typedef IntValue TableType;
  int32_t value = 0;
};

struct IntValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntValueT NativeTableType;
  typedef IntValueBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return IntValueTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool mutate_value(int32_t _value = 0) {
    return SetField<int32_t>(VT_VALUE, _value, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
  IntValueT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IntValueT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IntValue> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IntValueT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IntValueBuilder {
  typedef IntValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(IntValue::VT_VALUE, value, 0);
  }
  explicit IntValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IntValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntValue> CreateIntValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  IntValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<IntValue> CreateIntValue(flatbuffers::FlatBufferBuilder &_fbb, const IntValueT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CollisionT : public flatbuffers::NativeTable {
  typedef Collision TableType;
  union_value_collsion::ValueUnion some_value{};
  union_value_collsion::OtherUnion value{};
};

struct Collision FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CollisionT NativeTableType;
  typedef CollisionBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CollisionTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOME_VALUE_TYPE = 4,
    VT_SOME_VALUE = 6,
    VT_VALUE_TYPE = 8,
    VT_VALUE = 10
  };
  union_value_collsion::Value some_value_type() const {
    return static_cast<union_value_collsion::Value>(GetField<uint8_t>(VT_SOME_VALUE_TYPE, 0));
  }
  const void *some_value() const {
    return GetPointer<const void *>(VT_SOME_VALUE);
  }
  template<typename T> const T *some_value_as() const;
  const union_value_collsion::IntValue *some_value_as_IntValue() const {
    return some_value_type() == union_value_collsion::Value_IntValue ? static_cast<const union_value_collsion::IntValue *>(some_value()) : nullptr;
  }
  void *mutable_some_value() {
    return GetPointer<void *>(VT_SOME_VALUE);
  }
  union_value_collsion::Other value_type() const {
    return static_cast<union_value_collsion::Other>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const union_value_collsion::IntValue *value_as_IntValue() const {
    return value_type() == union_value_collsion::Other_IntValue ? static_cast<const union_value_collsion::IntValue *>(value()) : nullptr;
  }
  void *mutable_value() {
    return GetPointer<void *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SOME_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_SOME_VALUE) &&
           VerifyValue(verifier, some_value(), some_value_type()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyOther(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
  CollisionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CollisionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Collision> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CollisionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const union_value_collsion::IntValue *Collision::some_value_as<union_value_collsion::IntValue>() const {
  return some_value_as_IntValue();
}

template<> inline const union_value_collsion::IntValue *Collision::value_as<union_value_collsion::IntValue>() const {
  return value_as_IntValue();
}

struct CollisionBuilder {
  typedef Collision Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_some_value_type(union_value_collsion::Value some_value_type) {
    fbb_.AddElement<uint8_t>(Collision::VT_SOME_VALUE_TYPE, static_cast<uint8_t>(some_value_type), 0);
  }
  void add_some_value(flatbuffers::Offset<void> some_value) {
    fbb_.AddOffset(Collision::VT_SOME_VALUE, some_value);
  }
  void add_value_type(union_value_collsion::Other value_type) {
    fbb_.AddElement<uint8_t>(Collision::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Collision::VT_VALUE, value);
  }
  explicit CollisionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Collision> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Collision>(end);
    return o;
  }
};

inline flatbuffers::Offset<Collision> CreateCollision(
    flatbuffers::FlatBufferBuilder &_fbb,
    union_value_collsion::Value some_value_type = union_value_collsion::Value_NONE,
    flatbuffers::Offset<void> some_value = 0,
    union_value_collsion::Other value_type = union_value_collsion::Other_NONE,
    flatbuffers::Offset<void> value = 0) {
  CollisionBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_some_value(some_value);
  builder_.add_value_type(value_type);
  builder_.add_some_value_type(some_value_type);
  return builder_.Finish();
}

flatbuffers::Offset<Collision> CreateCollision(flatbuffers::FlatBufferBuilder &_fbb, const CollisionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const IntValueT &lhs, const IntValueT &rhs) {
  return
      (lhs.value == rhs.value);
}

inline bool operator!=(const IntValueT &lhs, const IntValueT &rhs) {
    return !(lhs == rhs);
}


inline IntValueT *IntValue::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<IntValueT>(new IntValueT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IntValue::UnPackTo(IntValueT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<IntValue> IntValue::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IntValueT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIntValue(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IntValue> CreateIntValue(flatbuffers::FlatBufferBuilder &_fbb, const IntValueT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IntValueT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  return union_value_collsion::CreateIntValue(
      _fbb,
      _value);
}


inline bool operator==(const CollisionT &lhs, const CollisionT &rhs) {
  return
      (lhs.some_value == rhs.some_value) &&
      (lhs.value == rhs.value);
}

inline bool operator!=(const CollisionT &lhs, const CollisionT &rhs) {
    return !(lhs == rhs);
}


inline CollisionT *Collision::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CollisionT>(new CollisionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Collision::UnPackTo(CollisionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = some_value_type(); _o->some_value.type = _e; }
  { auto _e = some_value(); if (_e) _o->some_value.value = union_value_collsion::ValueUnion::UnPack(_e, some_value_type(), _resolver); }
  { auto _e = value_type(); _o->value.type = _e; }
  { auto _e = value(); if (_e) _o->value.value = union_value_collsion::OtherUnion::UnPack(_e, value_type(), _resolver); }
}

inline flatbuffers::Offset<Collision> Collision::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CollisionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCollision(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Collision> CreateCollision(flatbuffers::FlatBufferBuilder &_fbb, const CollisionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CollisionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _some_value_type = _o->some_value.type;
  auto _some_value = _o->some_value.Pack(_fbb);
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  return union_value_collsion::CreateCollision(
      _fbb,
      _some_value_type,
      _some_value,
      _value_type,
      _value);
}

inline bool VerifyValue(flatbuffers::Verifier &verifier, const void *obj, Value type) {
  switch (type) {
    case Value_NONE: {
      return true;
    }
    case Value_IntValue: {
      auto ptr = reinterpret_cast<const union_value_collsion::IntValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValue(
        verifier,  values->Get(i), types->GetEnum<Value>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ValueUnion::UnPack(const void *obj, Value type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case Value_IntValue: {
      auto ptr = reinterpret_cast<const union_value_collsion::IntValue *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ValueUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case Value_IntValue: {
      auto ptr = reinterpret_cast<const union_value_collsion::IntValueT *>(value);
      return CreateIntValue(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ValueUnion::ValueUnion(const ValueUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Value_IntValue: {
      value = new union_value_collsion::IntValueT(*reinterpret_cast<union_value_collsion::IntValueT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ValueUnion::Reset() {
  switch (type) {
    case Value_IntValue: {
      auto ptr = reinterpret_cast<union_value_collsion::IntValueT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Value_NONE;
}

inline bool VerifyOther(flatbuffers::Verifier &verifier, const void *obj, Other type) {
  switch (type) {
    case Other_NONE: {
      return true;
    }
    case Other_IntValue: {
      auto ptr = reinterpret_cast<const union_value_collsion::IntValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOtherVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOther(
        verifier,  values->Get(i), types->GetEnum<Other>(i))) {
      return false;
    }
  }
  return true;
}

inline void *OtherUnion::UnPack(const void *obj, Other type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case Other_IntValue: {
      auto ptr = reinterpret_cast<const union_value_collsion::IntValue *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> OtherUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case Other_IntValue: {
      auto ptr = reinterpret_cast<const union_value_collsion::IntValueT *>(value);
      return CreateIntValue(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline OtherUnion::OtherUnion(const OtherUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Other_IntValue: {
      value = new union_value_collsion::IntValueT(*reinterpret_cast<union_value_collsion::IntValueT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void OtherUnion::Reset() {
  switch (type) {
    case Other_IntValue: {
      auto ptr = reinterpret_cast<union_value_collsion::IntValueT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Other_NONE;
}

inline const flatbuffers::TypeTable *ValueTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    union_value_collsion::IntValueTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "IntValue"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OtherTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    union_value_collsion::IntValueTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "IntValue"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *IntValueTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *CollisionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UTYPE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_UTYPE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    union_value_collsion::ValueTypeTable,
    union_value_collsion::OtherTypeTable
  };
  static const char * const names[] = {
    "some_value_type",
    "some_value",
    "value_type",
    "value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const union_value_collsion::Collision *GetCollision(const void *buf) {
  return flatbuffers::GetRoot<union_value_collsion::Collision>(buf);
}

inline const union_value_collsion::Collision *GetSizePrefixedCollision(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<union_value_collsion::Collision>(buf);
}

inline Collision *GetMutableCollision(void *buf) {
  return flatbuffers::GetMutableRoot<Collision>(buf);
}

inline union_value_collsion::Collision *GetMutableSizePrefixedCollision(void *buf) {
  return flatbuffers::GetMutableSizePrefixedRoot<union_value_collsion::Collision>(buf);
}

inline bool VerifyCollisionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<union_value_collsion::Collision>(nullptr);
}

inline bool VerifySizePrefixedCollisionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<union_value_collsion::Collision>(nullptr);
}

inline void FinishCollisionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<union_value_collsion::Collision> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCollisionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<union_value_collsion::Collision> root) {
  fbb.FinishSizePrefixed(root);
}

inline flatbuffers::unique_ptr<union_value_collsion::CollisionT> UnPackCollision(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return flatbuffers::unique_ptr<union_value_collsion::CollisionT>(GetCollision(buf)->UnPack(res));
}

inline flatbuffers::unique_ptr<union_value_collsion::CollisionT> UnPackSizePrefixedCollision(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return flatbuffers::unique_ptr<union_value_collsion::CollisionT>(GetSizePrefixedCollision(buf)->UnPack(res));
}

}  // namespace union_value_collsion

#endif  // FLATBUFFERS_GENERATED_UNIONVALUECOLLISION_UNION_VALUE_COLLSION_H_
