// automatically generated by the FlatBuffers compiler, do not modify


pub mod my_game {
    #![allow(unused_imports, irrefutable_let_patterns, dead_code, unused_mut)]
    use flatbuffers::{
        deserialize::{FromStructField, FromTableField, FromTableFieldUnion, Str, Table, Vector},
        errors::{InvalidFlatbuffer, OutOfBufferSpace, TryFromEnumError},
        serialize::{
            builder::FlatbufferWriter, FlatbufferPrimitive, FlatbufferTable, Offset, RawOffset,
        },
    };
    use core::{
        convert::{TryFrom, TryInto},
        fmt, ptr,
    };
    pub mod example {
        #![allow(unused_imports, irrefutable_let_patterns, dead_code, unused_mut)]
        use flatbuffers::{
            deserialize::{FromStructField, FromTableField, FromTableFieldUnion, Str, Table, Vector},
            errors::{InvalidFlatbuffer, OutOfBufferSpace, TryFromEnumError},
            serialize::{
                builder::FlatbufferWriter, FlatbufferPrimitive, FlatbufferTable, Offset, RawOffset,
            },
        };
        use core::{
            convert::{TryFrom, TryInto},
            fmt, ptr,
        };

        /// Enum for the flatbuffer `Color` enum
        ///
        /// Composite components of Monster color.
        #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
        pub enum Color {
            Red = 1,
            /// \brief color Green
            /// Green is bit_flag with value (1u << 1)
            Green = 2,
            /// \brief color Blue (1u << 3)
            Blue = 8,
        }

        impl From<Color> for u8 {
            #[inline]
            fn from(value: Color) -> u8 {
                value as u8
            }
        }

        impl TryFrom<u8> for Color {
            type Error = TryFromEnumError;
            #[inline]
            fn try_from(value: u8) -> Result<Color, TryFromEnumError> {
                match value {
                    1 => Ok(Color::Red),
                    2 => Ok(Color::Green),
                    8 => Ok(Color::Blue),
                    _ => Err(TryFromEnumError),
                }
            }
        }

        #[doc(hidden)]
        impl<'a> FromTableField<'a> for Color {
            const INLINE_SIZE: usize = 1;

            #[inline]
            fn from_field(buf: &'a [u8], offset: usize) -> Result<Color, InvalidFlatbuffer> {
                u8::from_field(buf, offset)?
                    .try_into()
                    .or(Err(InvalidFlatbuffer))
            }
        }

        #[doc(hidden)]
        unsafe impl<'a> FromStructField<'a> for Color {
            type Input = [u8; 1];

            #[inline]
            fn from_struct_field(buf: &'a Self::Input) -> Result<Color, InvalidFlatbuffer> {
                u8::from_struct_field(buf)?
                    .try_into()
                    .or(Err(InvalidFlatbuffer))
            }
        }

        unsafe impl FlatbufferPrimitive for Color {
            const SIZE: usize = 1;
            const ALIGNMENT: usize = 1;

            #[inline]
            unsafe fn serialize(&self, buffer: *mut u8, offset: RawOffset) {
                FlatbufferPrimitive::serialize(&(*self as u8), buffer, offset)
            }
        }

        /// Enum for the flatbuffer `Race` enum
        ///
        #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
        pub enum Race {
            None = -1,
            Human = 0,
            Dwarf = 1,
            Elf = 2,
        }

        impl From<Race> for i8 {
            #[inline]
            fn from(value: Race) -> i8 {
                value as i8
            }
        }

        impl TryFrom<i8> for Race {
            type Error = TryFromEnumError;
            #[inline]
            fn try_from(value: i8) -> Result<Race, TryFromEnumError> {
                match value {
                    -1 => Ok(Race::None),
                    0 => Ok(Race::Human),
                    1 => Ok(Race::Dwarf),
                    2 => Ok(Race::Elf),
                    _ => Err(TryFromEnumError),
                }
            }
        }

        #[doc(hidden)]
        impl<'a> FromTableField<'a> for Race {
            const INLINE_SIZE: usize = 1;

            #[inline]
            fn from_field(buf: &'a [u8], offset: usize) -> Result<Race, InvalidFlatbuffer> {
                i8::from_field(buf, offset)?
                    .try_into()
                    .or(Err(InvalidFlatbuffer))
            }
        }

        #[doc(hidden)]
        unsafe impl<'a> FromStructField<'a> for Race {
            type Input = [u8; 1];

            #[inline]
            fn from_struct_field(buf: &'a Self::Input) -> Result<Race, InvalidFlatbuffer> {
                i8::from_struct_field(buf)?
                    .try_into()
                    .or(Err(InvalidFlatbuffer))
            }
        }

        unsafe impl FlatbufferPrimitive for Race {
            const SIZE: usize = 1;
            const ALIGNMENT: usize = 1;

            #[inline]
            unsafe fn serialize(&self, buffer: *mut u8, offset: RawOffset) {
                FlatbufferPrimitive::serialize(&(*self as i8), buffer, offset)
            }
        }

        #[derive(Copy, Clone)]
        enum AnyTag {
            NONE = 0,
            Monster = 1,
            TestSimpleTableWithEnum = 2,
            MyGameExample2Monster = 3,
        }

        impl<'a> FromTableField<'a> for AnyTag {
            const INLINE_SIZE: usize = 1;

            #[inline]
            fn from_field(buf: &'a [u8], offset: usize) -> Result<AnyTag, InvalidFlatbuffer> {
                match u8::from_field(buf, offset)? {
                    1 => Ok(AnyTag::Monster),
                    2 => Ok(AnyTag::TestSimpleTableWithEnum),
                    3 => Ok(AnyTag::MyGameExample2Monster),
                    _ => Ok(AnyTag::NONE),
                }
            }
        }

        unsafe impl FlatbufferPrimitive for AnyTag {
            const SIZE: usize = 1;
            const ALIGNMENT: usize = 1;

            #[inline]
            unsafe fn serialize(&self, buffer: *mut u8, offset: RawOffset) {
                FlatbufferPrimitive::serialize(&(*self as u8), buffer, offset)
            }
        }

        /// View of a flatbuffer `Any` object
        ///
        /// This enum is used for deserializing. For serializing see [`Any`](enum.Any.html).
        ///
        #[derive(Copy, Clone, Debug)]
        pub enum AnyView<'a> {
            Monster(MonsterView<'a>),
            TestSimpleTableWithEnum(TestSimpleTableWithEnumView<'a>),
            MyGameExample2Monster(super::example2::MonsterView<'a>),
        }

        #[doc(hidden)]
        impl<'a> FromTableFieldUnion<'a> for AnyView<'a> {
            #[inline]
            fn from_field_union(
                buf: &'a [u8],
                tag_offset: usize,
                value_offset: usize,
            ) -> Result<Option<Self>, InvalidFlatbuffer> {
                match AnyTag::from_field(buf, tag_offset)? {
                    AnyTag::NONE => Ok(None),
                    AnyTag::Monster => Ok(Some(AnyView::Monster(FromTableField::from_field(
                        buf,
                        value_offset,
                    )?))),
                    AnyTag::TestSimpleTableWithEnum => Ok(Some(AnyView::TestSimpleTableWithEnum(FromTableField::from_field(
                        buf,
                        value_offset,
                    )?))),
                    AnyTag::MyGameExample2Monster => Ok(Some(AnyView::MyGameExample2Monster(FromTableField::from_field(
                        buf,
                        value_offset,
                    )?))),
                }
            }
        }

        impl<'a> AnyView<'a> {
            #[inline]
            pub fn as_monster(self) -> Option<MonsterView<'a>> {
                if let AnyView::Monster(inner) = self {
                    Some(inner)
                } else {
                    None
                }
            }

            #[inline]
            pub fn as_test_simple_table_with_enum(self) -> Option<TestSimpleTableWithEnumView<'a>> {
                if let AnyView::TestSimpleTableWithEnum(inner) = self {
                    Some(inner)
                } else {
                    None
                }
            }

            #[inline]
            pub fn as_my_game_example2_monster(self) -> Option<super::example2::MonsterView<'a>> {
                if let AnyView::MyGameExample2Monster(inner) = self {
                    Some(inner)
                } else {
                    None
                }
            }

        }

        /// Builder for a flatbuffer `Any` object
        ///
        /// This enum is used for serializing. For deserializing see [`AnyView`](enum.AnyView.html).
        ///
        #[derive(Copy, Clone, Debug, PartialEq)]
        pub enum Any {
            Monster(Offset<Monster>),
            TestSimpleTableWithEnum(Offset<TestSimpleTableWithEnum>),
            MyGameExample2Monster(Offset<super::example2::Monster>),
        }

        impl Any {
            #[inline]
            fn tag(&self) -> AnyTag {
                match self {
                    Any::Monster(_) => AnyTag::Monster,
                    Any::TestSimpleTableWithEnum(_) => AnyTag::TestSimpleTableWithEnum,
                    Any::MyGameExample2Monster(_) => AnyTag::MyGameExample2Monster,
                }
            }

            #[inline]
            fn offset(&self) -> RawOffset {
                match self {
                    Any::Monster(offset) => offset.raw_offset(),
                    Any::TestSimpleTableWithEnum(offset) => offset.raw_offset(),
                    Any::MyGameExample2Monster(offset) => offset.raw_offset(),
                }
            }
        }

        #[derive(Copy, Clone)]
        enum AnyUniqueAliasesTag {
            NONE = 0,
            M = 1,
            TS = 2,
            M2 = 3,
        }

        impl<'a> FromTableField<'a> for AnyUniqueAliasesTag {
            const INLINE_SIZE: usize = 1;

            #[inline]
            fn from_field(buf: &'a [u8], offset: usize) -> Result<AnyUniqueAliasesTag, InvalidFlatbuffer> {
                match u8::from_field(buf, offset)? {
                    1 => Ok(AnyUniqueAliasesTag::M),
                    2 => Ok(AnyUniqueAliasesTag::TS),
                    3 => Ok(AnyUniqueAliasesTag::M2),
                    _ => Ok(AnyUniqueAliasesTag::NONE),
                }
            }
        }

        unsafe impl FlatbufferPrimitive for AnyUniqueAliasesTag {
            const SIZE: usize = 1;
            const ALIGNMENT: usize = 1;

            #[inline]
            unsafe fn serialize(&self, buffer: *mut u8, offset: RawOffset) {
                FlatbufferPrimitive::serialize(&(*self as u8), buffer, offset)
            }
        }

        /// View of a flatbuffer `AnyUniqueAliases` object
        ///
        /// This enum is used for deserializing. For serializing see [`AnyUniqueAliases`](enum.AnyUniqueAliases.html).
        ///
        #[derive(Copy, Clone, Debug)]
        pub enum AnyUniqueAliasesView<'a> {
            M(MonsterView<'a>),
            TS(TestSimpleTableWithEnumView<'a>),
            M2(super::example2::MonsterView<'a>),
        }

        #[doc(hidden)]
        impl<'a> FromTableFieldUnion<'a> for AnyUniqueAliasesView<'a> {
            #[inline]
            fn from_field_union(
                buf: &'a [u8],
                tag_offset: usize,
                value_offset: usize,
            ) -> Result<Option<Self>, InvalidFlatbuffer> {
                match AnyUniqueAliasesTag::from_field(buf, tag_offset)? {
                    AnyUniqueAliasesTag::NONE => Ok(None),
                    AnyUniqueAliasesTag::M => Ok(Some(AnyUniqueAliasesView::M(FromTableField::from_field(
                        buf,
                        value_offset,
                    )?))),
                    AnyUniqueAliasesTag::TS => Ok(Some(AnyUniqueAliasesView::TS(FromTableField::from_field(
                        buf,
                        value_offset,
                    )?))),
                    AnyUniqueAliasesTag::M2 => Ok(Some(AnyUniqueAliasesView::M2(FromTableField::from_field(
                        buf,
                        value_offset,
                    )?))),
                }
            }
        }

        impl<'a> AnyUniqueAliasesView<'a> {
            #[inline]
            pub fn as_m(self) -> Option<MonsterView<'a>> {
                if let AnyUniqueAliasesView::M(inner) = self {
                    Some(inner)
                } else {
                    None
                }
            }

            #[inline]
            pub fn as_ts(self) -> Option<TestSimpleTableWithEnumView<'a>> {
                if let AnyUniqueAliasesView::TS(inner) = self {
                    Some(inner)
                } else {
                    None
                }
            }

            #[inline]
            pub fn as_m2(self) -> Option<super::example2::MonsterView<'a>> {
                if let AnyUniqueAliasesView::M2(inner) = self {
                    Some(inner)
                } else {
                    None
                }
            }

        }

        /// Builder for a flatbuffer `AnyUniqueAliases` object
        ///
        /// This enum is used for serializing. For deserializing see [`AnyUniqueAliasesView`](enum.AnyUniqueAliasesView.html).
        ///
        #[derive(Copy, Clone, Debug, PartialEq)]
        pub enum AnyUniqueAliases {
            M(Offset<Monster>),
            TS(Offset<TestSimpleTableWithEnum>),
            M2(Offset<super::example2::Monster>),
        }

        impl AnyUniqueAliases {
            #[inline]
            fn tag(&self) -> AnyUniqueAliasesTag {
                match self {
                    AnyUniqueAliases::M(_) => AnyUniqueAliasesTag::M,
                    AnyUniqueAliases::TS(_) => AnyUniqueAliasesTag::TS,
                    AnyUniqueAliases::M2(_) => AnyUniqueAliasesTag::M2,
                }
            }

            #[inline]
            fn offset(&self) -> RawOffset {
                match self {
                    AnyUniqueAliases::M(offset) => offset.raw_offset(),
                    AnyUniqueAliases::TS(offset) => offset.raw_offset(),
                    AnyUniqueAliases::M2(offset) => offset.raw_offset(),
                }
            }
        }

        #[derive(Copy, Clone)]
        enum AnyAmbiguousAliasesTag {
            NONE = 0,
            M1 = 1,
            M2 = 2,
            M3 = 3,
        }

        impl<'a> FromTableField<'a> for AnyAmbiguousAliasesTag {
            const INLINE_SIZE: usize = 1;

            #[inline]
            fn from_field(buf: &'a [u8], offset: usize) -> Result<AnyAmbiguousAliasesTag, InvalidFlatbuffer> {
                match u8::from_field(buf, offset)? {
                    1 => Ok(AnyAmbiguousAliasesTag::M1),
                    2 => Ok(AnyAmbiguousAliasesTag::M2),
                    3 => Ok(AnyAmbiguousAliasesTag::M3),
                    _ => Ok(AnyAmbiguousAliasesTag::NONE),
                }
            }
        }

        unsafe impl FlatbufferPrimitive for AnyAmbiguousAliasesTag {
            const SIZE: usize = 1;
            const ALIGNMENT: usize = 1;

            #[inline]
            unsafe fn serialize(&self, buffer: *mut u8, offset: RawOffset) {
                FlatbufferPrimitive::serialize(&(*self as u8), buffer, offset)
            }
        }

        /// View of a flatbuffer `AnyAmbiguousAliases` object
        ///
        /// This enum is used for deserializing. For serializing see [`AnyAmbiguousAliases`](enum.AnyAmbiguousAliases.html).
        ///
        #[derive(Copy, Clone, Debug)]
        pub enum AnyAmbiguousAliasesView<'a> {
            M1(MonsterView<'a>),
            M2(MonsterView<'a>),
            M3(MonsterView<'a>),
        }

        #[doc(hidden)]
        impl<'a> FromTableFieldUnion<'a> for AnyAmbiguousAliasesView<'a> {
            #[inline]
            fn from_field_union(
                buf: &'a [u8],
                tag_offset: usize,
                value_offset: usize,
            ) -> Result<Option<Self>, InvalidFlatbuffer> {
                match AnyAmbiguousAliasesTag::from_field(buf, tag_offset)? {
                    AnyAmbiguousAliasesTag::NONE => Ok(None),
                    AnyAmbiguousAliasesTag::M1 => Ok(Some(AnyAmbiguousAliasesView::M1(FromTableField::from_field(
                        buf,
                        value_offset,
                    )?))),
                    AnyAmbiguousAliasesTag::M2 => Ok(Some(AnyAmbiguousAliasesView::M2(FromTableField::from_field(
                        buf,
                        value_offset,
                    )?))),
                    AnyAmbiguousAliasesTag::M3 => Ok(Some(AnyAmbiguousAliasesView::M3(FromTableField::from_field(
                        buf,
                        value_offset,
                    )?))),
                }
            }
        }

        impl<'a> AnyAmbiguousAliasesView<'a> {
            #[inline]
            pub fn as_m1(self) -> Option<MonsterView<'a>> {
                if let AnyAmbiguousAliasesView::M1(inner) = self {
                    Some(inner)
                } else {
                    None
                }
            }

            #[inline]
            pub fn as_m2(self) -> Option<MonsterView<'a>> {
                if let AnyAmbiguousAliasesView::M2(inner) = self {
                    Some(inner)
                } else {
                    None
                }
            }

            #[inline]
            pub fn as_m3(self) -> Option<MonsterView<'a>> {
                if let AnyAmbiguousAliasesView::M3(inner) = self {
                    Some(inner)
                } else {
                    None
                }
            }

        }

        /// Builder for a flatbuffer `AnyAmbiguousAliases` object
        ///
        /// This enum is used for serializing. For deserializing see [`AnyAmbiguousAliasesView`](enum.AnyAmbiguousAliasesView.html).
        ///
        #[derive(Copy, Clone, Debug, PartialEq)]
        pub enum AnyAmbiguousAliases {
            M1(Offset<Monster>),
            M2(Offset<Monster>),
            M3(Offset<Monster>),
        }

        impl AnyAmbiguousAliases {
            #[inline]
            fn tag(&self) -> AnyAmbiguousAliasesTag {
                match self {
                    AnyAmbiguousAliases::M1(_) => AnyAmbiguousAliasesTag::M1,
                    AnyAmbiguousAliases::M2(_) => AnyAmbiguousAliasesTag::M2,
                    AnyAmbiguousAliases::M3(_) => AnyAmbiguousAliasesTag::M3,
                }
            }

            #[inline]
            fn offset(&self) -> RawOffset {
                match self {
                    AnyAmbiguousAliases::M1(offset) => offset.raw_offset(),
                    AnyAmbiguousAliases::M2(offset) => offset.raw_offset(),
                    AnyAmbiguousAliases::M3(offset) => offset.raw_offset(),
                }
            }
        }

        /// View of a flatbuffer `Test` object
        ///
        /// This struct is used for deserializing. For serializing see [`Test`](struct.Test.html).
        ///
        #[derive(Copy, Clone)]
        pub struct TestView<'a> {
            slice: &'a [u8; 4],
        }

        #[doc(hidden)]
        impl<'a> FromTableField<'a> for TestView<'a> {
            const INLINE_SIZE: usize = 4;

            #[inline]
            fn from_field(buf: &'a [u8], offset: usize) -> Result<Self, InvalidFlatbuffer> {
                let slice = buf.get(offset..offset + 4).ok_or(InvalidFlatbuffer)?;
                Ok(Self {
                    slice: unsafe { &*(slice.as_ptr() as *const [u8; 4]) },
                })
            }
        }

        #[doc(hidden)]
        unsafe impl<'a> FromStructField<'a> for TestView<'a> {
            type Input = [u8; 4];

            #[inline]
            fn from_struct_field(slice: &'a Self::Input) -> Result<Self, InvalidFlatbuffer> {
                Ok(Self { slice })
            }
        }

        impl<'a> TestView<'a> {
            /// Getter for the `a` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn a(self) -> i16 {
                self.try_get_a().unwrap()
            }

            /// Getter for the `a` field.
            ///
            #[inline]
            pub fn try_get_a(self) -> Result<i16, InvalidFlatbuffer> {
                type SliceType<'a> = <i16 as FromStructField<'a>>::Input;
                const OFFSET: usize = 0;
                const SIZE: usize = core::mem::size_of::<SliceType>();
                let slice = self.slice.get(OFFSET..OFFSET+SIZE).unwrap();
                let slice: &'a SliceType<'a> = unsafe { &*(slice.as_ptr() as *const SliceType<'a>) };
                <i16 as FromStructField<'a>>::from_struct_field(slice)
            }

            /// Getter for the `b` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn b(self) -> i8 {
                self.try_get_b().unwrap()
            }

            /// Getter for the `b` field.
            ///
            #[inline]
            pub fn try_get_b(self) -> Result<i8, InvalidFlatbuffer> {
                type SliceType<'a> = <i8 as FromStructField<'a>>::Input;
                const OFFSET: usize = 2;
                const SIZE: usize = core::mem::size_of::<SliceType>();
                let slice = self.slice.get(OFFSET..OFFSET+SIZE).unwrap();
                let slice: &'a SliceType<'a> = unsafe { &*(slice.as_ptr() as *const SliceType<'a>) };
                <i8 as FromStructField<'a>>::from_struct_field(slice)
            }

        }

        impl<'a> fmt::Debug for TestView<'a> {
            fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
                formatter
                    .debug_struct("TestView")
                    .field("a", &self.try_get_a())
                    .field("b", &self.try_get_b())
                    .finish()
            }
        }

        impl<'a> PartialEq for TestView<'a> {
            #[inline]
            fn eq(&self, other: &Self) -> bool {
                self.slice[..] == other.slice[..]
            }
        }

        /// Builder for a flatbuffer `Test` object
        ///
        /// This struct is used for serializing. For deserializing see [`TestView`](struct.TestView.html).
        ///
        #[derive(Copy, Clone, Debug, PartialEq)]
        pub struct Test {
            pub a: i16,
            pub b: i8,
        }

        unsafe impl FlatbufferPrimitive for Test {
            const SIZE: usize = 4;
            const ALIGNMENT: usize = 2;

            #[inline]
            unsafe fn serialize(&self, buffer: *mut u8, offset: RawOffset) {
                FlatbufferPrimitive::serialize(&self.a, buffer.add(0), offset + 0);
                FlatbufferPrimitive::serialize(&self.b, buffer.add(2), offset + 2);
                ptr::write_bytes(buffer.add(2 + <i8 as FlatbufferPrimitive>::SIZE), 0, 1);
            }
        }

        /// View of a flatbuffer `TestSimpleTableWithEnum` object
        ///
        /// This struct is used for deserializing. For serializing see [`TestSimpleTableWithEnum`](struct.TestSimpleTableWithEnum.html).
        ///
        #[derive(Copy, Clone)]
        pub struct TestSimpleTableWithEnumView<'a> {
            table: Table<'a>,
        }

        #[doc(hidden)]
        impl<'a> FromTableField<'a> for TestSimpleTableWithEnumView<'a> {
            const INLINE_SIZE: usize = Table::INLINE_SIZE;

            #[inline]
            fn from_field(buf: &'a [u8], offset: usize) -> Result<Self, InvalidFlatbuffer> {
                FromTableField::from_field(buf, offset).map(|table| Self { table })
            }
        }

        impl<'a> TestSimpleTableWithEnumView<'a> {
            /// Getter for the `color` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn color(&self) -> Color {
                self.try_get_color().unwrap()
            }

            /// Getter for the `color` field.
            ///
            #[inline]
            pub fn try_get_color(&self) -> Result<Color, InvalidFlatbuffer> {
                self.table.get_field(4).map(|value| value.unwrap_or(Color::Green))
            }

            /// Begin parsing a flatbuffer with a `Weapon` as the root object
            #[inline]
            pub fn from_buffer_as_root(buffer: &'a [u8]) -> Result<Self, InvalidFlatbuffer> {
                FromTableField::from_field(buffer, 0)
            }
        }

        impl<'a> fmt::Debug for TestSimpleTableWithEnumView<'a> {
            fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
                formatter.debug_struct("TestSimpleTableWithEnumView")
                    .field("color", &self.try_get_color())
                    .finish()
            }
        }

        /// Builder for a flatbuffer `TestSimpleTableWithEnum` object
        ///
        /// This struct is used for serializing. For deserializing see [`TestSimpleTableWithEnumView`](struct.TestSimpleTableWithEnumView.html).
        ///
        #[derive(Copy, Clone, Debug, PartialEq)]
        pub struct TestSimpleTableWithEnum {
            pub color: Color,
        }

        impl Default for TestSimpleTableWithEnum {
            #[inline]
            fn default() -> TestSimpleTableWithEnum {
                TestSimpleTableWithEnum {
                    color: Color::Green,
                }
            }
        }

        unsafe impl FlatbufferTable for TestSimpleTableWithEnum {
            #[inline]
            fn validate_required(&self) {
            }

            #[inline]
            fn serialize<F: FlatbufferWriter>(
                &self,
                flatbuffer: &mut F,
            ) -> Result<RawOffset, OutOfBufferSpace> {
                let mut vtable = [0u8; 6];

                let mut size = 0;
                let mut alignment = 4;
                let mut vtable_len = 4;

                if self.color != Color::Green {
                    vtable_len = vtable_len.max(4 + 2);
                    const CUR_ALIGN: usize = <Color as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[4..4+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Color as FlatbufferPrimitive>::SIZE;
                }
                flatbuffer.align_before_write(size, alignment - 1)?;
                if self.color != Color::Green {
                    flatbuffer.write_primitive(&self.color)?;
                }
                flatbuffer.write_vtable_and_offset(&mut vtable[..vtable_len], size + 4)
            }
        }

        /// View of a flatbuffer `Vec3` object
        ///
        /// This struct is used for deserializing. For serializing see [`Vec3`](struct.Vec3.html).
        ///
        #[derive(Copy, Clone)]
        pub struct Vec3View<'a> {
            slice: &'a [u8; 32],
        }

        #[doc(hidden)]
        impl<'a> FromTableField<'a> for Vec3View<'a> {
            const INLINE_SIZE: usize = 32;

            #[inline]
            fn from_field(buf: &'a [u8], offset: usize) -> Result<Self, InvalidFlatbuffer> {
                let slice = buf.get(offset..offset + 32).ok_or(InvalidFlatbuffer)?;
                Ok(Self {
                    slice: unsafe { &*(slice.as_ptr() as *const [u8; 32]) },
                })
            }
        }

        #[doc(hidden)]
        unsafe impl<'a> FromStructField<'a> for Vec3View<'a> {
            type Input = [u8; 32];

            #[inline]
            fn from_struct_field(slice: &'a Self::Input) -> Result<Self, InvalidFlatbuffer> {
                Ok(Self { slice })
            }
        }

        impl<'a> Vec3View<'a> {
            /// Getter for the `x` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn x(self) -> f32 {
                self.try_get_x().unwrap()
            }

            /// Getter for the `x` field.
            ///
            #[inline]
            pub fn try_get_x(self) -> Result<f32, InvalidFlatbuffer> {
                type SliceType<'a> = <f32 as FromStructField<'a>>::Input;
                const OFFSET: usize = 0;
                const SIZE: usize = core::mem::size_of::<SliceType>();
                let slice = self.slice.get(OFFSET..OFFSET+SIZE).unwrap();
                let slice: &'a SliceType<'a> = unsafe { &*(slice.as_ptr() as *const SliceType<'a>) };
                <f32 as FromStructField<'a>>::from_struct_field(slice)
            }

            /// Getter for the `y` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn y(self) -> f32 {
                self.try_get_y().unwrap()
            }

            /// Getter for the `y` field.
            ///
            #[inline]
            pub fn try_get_y(self) -> Result<f32, InvalidFlatbuffer> {
                type SliceType<'a> = <f32 as FromStructField<'a>>::Input;
                const OFFSET: usize = 4;
                const SIZE: usize = core::mem::size_of::<SliceType>();
                let slice = self.slice.get(OFFSET..OFFSET+SIZE).unwrap();
                let slice: &'a SliceType<'a> = unsafe { &*(slice.as_ptr() as *const SliceType<'a>) };
                <f32 as FromStructField<'a>>::from_struct_field(slice)
            }

            /// Getter for the `z` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn z(self) -> f32 {
                self.try_get_z().unwrap()
            }

            /// Getter for the `z` field.
            ///
            #[inline]
            pub fn try_get_z(self) -> Result<f32, InvalidFlatbuffer> {
                type SliceType<'a> = <f32 as FromStructField<'a>>::Input;
                const OFFSET: usize = 8;
                const SIZE: usize = core::mem::size_of::<SliceType>();
                let slice = self.slice.get(OFFSET..OFFSET+SIZE).unwrap();
                let slice: &'a SliceType<'a> = unsafe { &*(slice.as_ptr() as *const SliceType<'a>) };
                <f32 as FromStructField<'a>>::from_struct_field(slice)
            }

            /// Getter for the `test1` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn test1(self) -> f64 {
                self.try_get_test1().unwrap()
            }

            /// Getter for the `test1` field.
            ///
            #[inline]
            pub fn try_get_test1(self) -> Result<f64, InvalidFlatbuffer> {
                type SliceType<'a> = <f64 as FromStructField<'a>>::Input;
                const OFFSET: usize = 16;
                const SIZE: usize = core::mem::size_of::<SliceType>();
                let slice = self.slice.get(OFFSET..OFFSET+SIZE).unwrap();
                let slice: &'a SliceType<'a> = unsafe { &*(slice.as_ptr() as *const SliceType<'a>) };
                <f64 as FromStructField<'a>>::from_struct_field(slice)
            }

            /// Getter for the `test2` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn test2(self) -> Color {
                self.try_get_test2().unwrap()
            }

            /// Getter for the `test2` field.
            ///
            #[inline]
            pub fn try_get_test2(self) -> Result<Color, InvalidFlatbuffer> {
                type SliceType<'a> = <Color as FromStructField<'a>>::Input;
                const OFFSET: usize = 24;
                const SIZE: usize = core::mem::size_of::<SliceType>();
                let slice = self.slice.get(OFFSET..OFFSET+SIZE).unwrap();
                let slice: &'a SliceType<'a> = unsafe { &*(slice.as_ptr() as *const SliceType<'a>) };
                <Color as FromStructField<'a>>::from_struct_field(slice)
            }

            /// Getter for the `test3` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn test3(self) -> TestView<'a> {
                self.try_get_test3().unwrap()
            }

            /// Getter for the `test3` field.
            ///
            #[inline]
            pub fn try_get_test3(self) -> Result<TestView<'a>, InvalidFlatbuffer> {
                type SliceType<'a> = <TestView<'a> as FromStructField<'a>>::Input;
                const OFFSET: usize = 26;
                const SIZE: usize = core::mem::size_of::<SliceType>();
                let slice = self.slice.get(OFFSET..OFFSET+SIZE).unwrap();
                let slice: &'a SliceType<'a> = unsafe { &*(slice.as_ptr() as *const SliceType<'a>) };
                <TestView<'a> as FromStructField<'a>>::from_struct_field(slice)
            }

        }

        impl<'a> fmt::Debug for Vec3View<'a> {
            fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
                formatter
                    .debug_struct("Vec3View")
                    .field("x", &self.try_get_x())
                    .field("y", &self.try_get_y())
                    .field("z", &self.try_get_z())
                    .field("test1", &self.try_get_test1())
                    .field("test2", &self.try_get_test2())
                    .field("test3", &self.try_get_test3())
                    .finish()
            }
        }

        impl<'a> PartialEq for Vec3View<'a> {
            #[inline]
            fn eq(&self, other: &Self) -> bool {
                self.slice[..] == other.slice[..]
            }
        }

        /// Builder for a flatbuffer `Vec3` object
        ///
        /// This struct is used for serializing. For deserializing see [`Vec3View`](struct.Vec3View.html).
        ///
        #[derive(Copy, Clone, Debug, PartialEq)]
        pub struct Vec3 {
            pub x: f32,
            pub y: f32,
            pub z: f32,
            pub test1: f64,
            pub test2: Color,
            pub test3: Test,
        }

        unsafe impl FlatbufferPrimitive for Vec3 {
            const SIZE: usize = 32;
            const ALIGNMENT: usize = 8;

            #[inline]
            unsafe fn serialize(&self, buffer: *mut u8, offset: RawOffset) {
                FlatbufferPrimitive::serialize(&self.x, buffer.add(0), offset + 0);
                FlatbufferPrimitive::serialize(&self.y, buffer.add(4), offset + 4);
                FlatbufferPrimitive::serialize(&self.z, buffer.add(8), offset + 8);
                ptr::write_bytes(buffer.add(8 + <f32 as FlatbufferPrimitive>::SIZE), 0, 4);
                FlatbufferPrimitive::serialize(&self.test1, buffer.add(16), offset + 16);
                FlatbufferPrimitive::serialize(&self.test2, buffer.add(24), offset + 24);
                ptr::write_bytes(buffer.add(24 + <Color as FlatbufferPrimitive>::SIZE), 0, 1);
                FlatbufferPrimitive::serialize(&self.test3, buffer.add(26), offset + 26);
                ptr::write_bytes(buffer.add(26 + <Test as FlatbufferPrimitive>::SIZE), 0, 2);
            }
        }

        /// View of a flatbuffer `Ability` object
        ///
        /// This struct is used for deserializing. For serializing see [`Ability`](struct.Ability.html).
        ///
        #[derive(Copy, Clone)]
        pub struct AbilityView<'a> {
            slice: &'a [u8; 8],
        }

        #[doc(hidden)]
        impl<'a> FromTableField<'a> for AbilityView<'a> {
            const INLINE_SIZE: usize = 8;

            #[inline]
            fn from_field(buf: &'a [u8], offset: usize) -> Result<Self, InvalidFlatbuffer> {
                let slice = buf.get(offset..offset + 8).ok_or(InvalidFlatbuffer)?;
                Ok(Self {
                    slice: unsafe { &*(slice.as_ptr() as *const [u8; 8]) },
                })
            }
        }

        #[doc(hidden)]
        unsafe impl<'a> FromStructField<'a> for AbilityView<'a> {
            type Input = [u8; 8];

            #[inline]
            fn from_struct_field(slice: &'a Self::Input) -> Result<Self, InvalidFlatbuffer> {
                Ok(Self { slice })
            }
        }

        impl<'a> AbilityView<'a> {
            /// Getter for the `id` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn id(self) -> u32 {
                self.try_get_id().unwrap()
            }

            /// Getter for the `id` field.
            ///
            #[inline]
            pub fn try_get_id(self) -> Result<u32, InvalidFlatbuffer> {
                type SliceType<'a> = <u32 as FromStructField<'a>>::Input;
                const OFFSET: usize = 0;
                const SIZE: usize = core::mem::size_of::<SliceType>();
                let slice = self.slice.get(OFFSET..OFFSET+SIZE).unwrap();
                let slice: &'a SliceType<'a> = unsafe { &*(slice.as_ptr() as *const SliceType<'a>) };
                <u32 as FromStructField<'a>>::from_struct_field(slice)
            }

            /// Getter for the `distance` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn distance(self) -> u32 {
                self.try_get_distance().unwrap()
            }

            /// Getter for the `distance` field.
            ///
            #[inline]
            pub fn try_get_distance(self) -> Result<u32, InvalidFlatbuffer> {
                type SliceType<'a> = <u32 as FromStructField<'a>>::Input;
                const OFFSET: usize = 4;
                const SIZE: usize = core::mem::size_of::<SliceType>();
                let slice = self.slice.get(OFFSET..OFFSET+SIZE).unwrap();
                let slice: &'a SliceType<'a> = unsafe { &*(slice.as_ptr() as *const SliceType<'a>) };
                <u32 as FromStructField<'a>>::from_struct_field(slice)
            }

        }

        impl<'a> fmt::Debug for AbilityView<'a> {
            fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
                formatter
                    .debug_struct("AbilityView")
                    .field("id", &self.try_get_id())
                    .field("distance", &self.try_get_distance())
                    .finish()
            }
        }

        impl<'a> PartialEq for AbilityView<'a> {
            #[inline]
            fn eq(&self, other: &Self) -> bool {
                self.slice[..] == other.slice[..]
            }
        }

        /// Builder for a flatbuffer `Ability` object
        ///
        /// This struct is used for serializing. For deserializing see [`AbilityView`](struct.AbilityView.html).
        ///
        #[derive(Copy, Clone, Debug, PartialEq)]
        pub struct Ability {
            pub id: u32,
            pub distance: u32,
        }

        unsafe impl FlatbufferPrimitive for Ability {
            const SIZE: usize = 8;
            const ALIGNMENT: usize = 4;

            #[inline]
            unsafe fn serialize(&self, buffer: *mut u8, offset: RawOffset) {
                FlatbufferPrimitive::serialize(&self.id, buffer.add(0), offset + 0);
                FlatbufferPrimitive::serialize(&self.distance, buffer.add(4), offset + 4);
            }
        }

        /// View of a flatbuffer `Stat` object
        ///
        /// This struct is used for deserializing. For serializing see [`Stat`](struct.Stat.html).
        ///
        #[derive(Copy, Clone)]
        pub struct StatView<'a> {
            table: Table<'a>,
        }

        #[doc(hidden)]
        impl<'a> FromTableField<'a> for StatView<'a> {
            const INLINE_SIZE: usize = Table::INLINE_SIZE;

            #[inline]
            fn from_field(buf: &'a [u8], offset: usize) -> Result<Self, InvalidFlatbuffer> {
                FromTableField::from_field(buf, offset).map(|table| Self { table })
            }
        }

        impl<'a> StatView<'a> {
            /// Getter for the `id` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn id(&self) -> Option<Str<'a>> {
                self.try_get_id().unwrap()
            }

            /// Getter for the `id` field.
            ///
            #[inline]
            pub fn try_get_id(&self) ->  Result<Option<Str<'a>>, InvalidFlatbuffer> {
                self.table.get_field(4)
            }

            /// Getter for the `val` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn val(&self) -> i64 {
                self.try_get_val().unwrap()
            }

            /// Getter for the `val` field.
            ///
            #[inline]
            pub fn try_get_val(&self) -> Result<i64, InvalidFlatbuffer> {
                self.table.get_field(6).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `count` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn count(&self) -> u16 {
                self.try_get_count().unwrap()
            }

            /// Getter for the `count` field.
            ///
            #[inline]
            pub fn try_get_count(&self) -> Result<u16, InvalidFlatbuffer> {
                self.table.get_field(8).map(|value| value.unwrap_or(0))
            }

            /// Begin parsing a flatbuffer with a `Weapon` as the root object
            #[inline]
            pub fn from_buffer_as_root(buffer: &'a [u8]) -> Result<Self, InvalidFlatbuffer> {
                FromTableField::from_field(buffer, 0)
            }
        }

        impl<'a> fmt::Debug for StatView<'a> {
            fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
                formatter.debug_struct("StatView")
                    .field("id", &self.try_get_id())
                    .field("val", &self.try_get_val())
                    .field("count", &self.try_get_count())
                    .finish()
            }
        }

        /// Builder for a flatbuffer `Stat` object
        ///
        /// This struct is used for serializing. For deserializing see [`StatView`](struct.StatView.html).
        ///
        #[derive(Copy, Clone, Debug, PartialEq)]
        pub struct Stat {
            pub id: Option<Offset<str>>,
            pub val: i64,
            pub count: u16,
        }

        impl Default for Stat {
            #[inline]
            fn default() -> Stat {
                Stat {
                    id: None,
                    val: 0,
                    count: 0,
                }
            }
        }

        unsafe impl FlatbufferTable for Stat {
            #[inline]
            fn validate_required(&self) {
            }

            #[inline]
            fn serialize<F: FlatbufferWriter>(
                &self,
                flatbuffer: &mut F,
            ) -> Result<RawOffset, OutOfBufferSpace> {
                let mut vtable = [0u8; 10];

                let mut size = 0;
                let mut alignment = 4;
                let mut vtable_len = 4;

                if self.val != 0 {
                    vtable_len = vtable_len.max(6 + 2);
                    const CUR_ALIGN: usize = <i64 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[6..6+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <i64 as FlatbufferPrimitive>::SIZE;
                }
                if self.id != None {
                    vtable_len = vtable_len.max(4 + 2);
                    const CUR_ALIGN: usize = <Offset<str> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[4..4+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<str> as FlatbufferPrimitive>::SIZE;
                }
                if self.count != 0 {
                    vtable_len = vtable_len.max(8 + 2);
                    const CUR_ALIGN: usize = <u16 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[8..8+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <u16 as FlatbufferPrimitive>::SIZE;
                }
                flatbuffer.align_before_write(size, alignment - 1)?;
                if self.count != 0 {
                    flatbuffer.write_primitive(&self.count)?;
                }
                if let Some(ref value) = self.id {
                    flatbuffer.write_primitive(value)?;
                }
                if self.val != 0 {
                    flatbuffer.write_primitive(&self.val)?;
                }
                flatbuffer.write_vtable_and_offset(&mut vtable[..vtable_len], size + 4)
            }
        }

        /// View of a flatbuffer `Referrable` object
        ///
        /// This struct is used for deserializing. For serializing see [`Referrable`](struct.Referrable.html).
        ///
        #[derive(Copy, Clone)]
        pub struct ReferrableView<'a> {
            table: Table<'a>,
        }

        #[doc(hidden)]
        impl<'a> FromTableField<'a> for ReferrableView<'a> {
            const INLINE_SIZE: usize = Table::INLINE_SIZE;

            #[inline]
            fn from_field(buf: &'a [u8], offset: usize) -> Result<Self, InvalidFlatbuffer> {
                FromTableField::from_field(buf, offset).map(|table| Self { table })
            }
        }

        impl<'a> ReferrableView<'a> {
            /// Getter for the `id` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn id(&self) -> u64 {
                self.try_get_id().unwrap()
            }

            /// Getter for the `id` field.
            ///
            #[inline]
            pub fn try_get_id(&self) -> Result<u64, InvalidFlatbuffer> {
                self.table.get_field(4).map(|value| value.unwrap_or(0))
            }

            /// Begin parsing a flatbuffer with a `Weapon` as the root object
            #[inline]
            pub fn from_buffer_as_root(buffer: &'a [u8]) -> Result<Self, InvalidFlatbuffer> {
                FromTableField::from_field(buffer, 0)
            }
        }

        impl<'a> fmt::Debug for ReferrableView<'a> {
            fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
                formatter.debug_struct("ReferrableView")
                    .field("id", &self.try_get_id())
                    .finish()
            }
        }

        /// Builder for a flatbuffer `Referrable` object
        ///
        /// This struct is used for serializing. For deserializing see [`ReferrableView`](struct.ReferrableView.html).
        ///
        #[derive(Copy, Clone, Debug, PartialEq)]
        pub struct Referrable {
            pub id: u64,
        }

        impl Default for Referrable {
            #[inline]
            fn default() -> Referrable {
                Referrable {
                    id: 0,
                }
            }
        }

        unsafe impl FlatbufferTable for Referrable {
            #[inline]
            fn validate_required(&self) {
            }

            #[inline]
            fn serialize<F: FlatbufferWriter>(
                &self,
                flatbuffer: &mut F,
            ) -> Result<RawOffset, OutOfBufferSpace> {
                let mut vtable = [0u8; 6];

                let mut size = 0;
                let mut alignment = 4;
                let mut vtable_len = 4;

                if self.id != 0 {
                    vtable_len = vtable_len.max(4 + 2);
                    const CUR_ALIGN: usize = <u64 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[4..4+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <u64 as FlatbufferPrimitive>::SIZE;
                }
                flatbuffer.align_before_write(size, alignment - 1)?;
                if self.id != 0 {
                    flatbuffer.write_primitive(&self.id)?;
                }
                flatbuffer.write_vtable_and_offset(&mut vtable[..vtable_len], size + 4)
            }
        }

        /// View of a flatbuffer `Monster` object
        ///
        /// This struct is used for deserializing. For serializing see [`Monster`](struct.Monster.html).
        ///
        /// an example documentation comment: monster object
        #[derive(Copy, Clone)]
        pub struct MonsterView<'a> {
            table: Table<'a>,
        }

        #[doc(hidden)]
        impl<'a> FromTableField<'a> for MonsterView<'a> {
            const INLINE_SIZE: usize = Table::INLINE_SIZE;

            #[inline]
            fn from_field(buf: &'a [u8], offset: usize) -> Result<Self, InvalidFlatbuffer> {
                FromTableField::from_field(buf, offset).map(|table| Self { table })
            }
        }

        impl<'a> MonsterView<'a> {
            /// Getter for the `pos` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn pos(&self) -> Option<Vec3View<'a>> {
                self.try_get_pos().unwrap()
            }

            /// Getter for the `pos` field.
            ///
            #[inline]
            pub fn try_get_pos(&self) ->  Result<Option<Vec3View<'a>>, InvalidFlatbuffer> {
                self.table.get_field(4)
            }

            /// Getter for the `mana` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn mana(&self) -> i16 {
                self.try_get_mana().unwrap()
            }

            /// Getter for the `mana` field.
            ///
            #[inline]
            pub fn try_get_mana(&self) -> Result<i16, InvalidFlatbuffer> {
                self.table.get_field(6).map(|value| value.unwrap_or(150))
            }

            /// Getter for the `hp` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn hp(&self) -> i16 {
                self.try_get_hp().unwrap()
            }

            /// Getter for the `hp` field.
            ///
            #[inline]
            pub fn try_get_hp(&self) -> Result<i16, InvalidFlatbuffer> {
                self.table.get_field(8).map(|value| value.unwrap_or(100))
            }

            /// Getter for the `name` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized or is not present.
            #[inline]
            pub fn name(&self) -> Str<'a> {
                self.try_get_name().unwrap()
            }

            /// Getter for the `name` field.
            ///
            #[inline]
            pub fn try_get_name(&self) -> Result<Str<'a>, InvalidFlatbuffer> {
                self.table.get_field(10).and_then(|value| value.ok_or(InvalidFlatbuffer))
            }

            /// Getter for the `inventory` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn inventory(&self) -> Option<Vector<'a, u8>> {
                self.try_get_inventory().unwrap()
            }

            /// Getter for the `inventory` field.
            ///
            #[inline]
            pub fn try_get_inventory(&self) ->  Result<Option<Vector<'a, u8>>, InvalidFlatbuffer> {
                self.table.get_field(14)
            }

            /// Getter for the `color` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn color(&self) -> Color {
                self.try_get_color().unwrap()
            }

            /// Getter for the `color` field.
            ///
            #[inline]
            pub fn try_get_color(&self) -> Result<Color, InvalidFlatbuffer> {
                self.table.get_field(16).map(|value| value.unwrap_or(Color::Blue))
            }

            /// Getter for the `test` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn test(&self) -> Option<AnyView<'a>> {
                self.try_get_test().unwrap()
            }

            /// Getter for the `test` field.
            ///
            #[inline]
            pub fn try_get_test(&self) ->  Result<Option<AnyView<'a>>, InvalidFlatbuffer> {
                self.table.get_field_union(18, 20)
            }

            /// Getter for the `test4` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn test4(&self) -> Option<Vector<'a, TestView<'a>>> {
                self.try_get_test4().unwrap()
            }

            /// Getter for the `test4` field.
            ///
            #[inline]
            pub fn try_get_test4(&self) ->  Result<Option<Vector<'a, TestView<'a>>>, InvalidFlatbuffer> {
                self.table.get_field(22)
            }

            /// Getter for the `testarrayofstring` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testarrayofstring(&self) -> Option<Vector<'a, Str<'a>>> {
                self.try_get_testarrayofstring().unwrap()
            }

            /// Getter for the `testarrayofstring` field.
            ///
            #[inline]
            pub fn try_get_testarrayofstring(&self) ->  Result<Option<Vector<'a, Str<'a>>>, InvalidFlatbuffer> {
                self.table.get_field(24)
            }

            /// Getter for the `testarrayoftables` field.
            ///
            /// an example documentation comment: this will end up in the generated code
            /// multiline too
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testarrayoftables(&self) -> Option<Vector<'a, MonsterView<'a>>> {
                self.try_get_testarrayoftables().unwrap()
            }

            /// Getter for the `testarrayoftables` field.
            ///
            /// an example documentation comment: this will end up in the generated code
            /// multiline too
            #[inline]
            pub fn try_get_testarrayoftables(&self) ->  Result<Option<Vector<'a, MonsterView<'a>>>, InvalidFlatbuffer> {
                self.table.get_field(26)
            }

            /// Getter for the `enemy` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn enemy(&self) -> Option<MonsterView<'a>> {
                self.try_get_enemy().unwrap()
            }

            /// Getter for the `enemy` field.
            ///
            #[inline]
            pub fn try_get_enemy(&self) ->  Result<Option<MonsterView<'a>>, InvalidFlatbuffer> {
                self.table.get_field(28)
            }

            /// Getter for the `testnestedflatbuffer` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testnestedflatbuffer(&self) -> Option<Vector<'a, u8>> {
                self.try_get_testnestedflatbuffer().unwrap()
            }

            /// Getter for the `testnestedflatbuffer` field.
            ///
            #[inline]
            pub fn try_get_testnestedflatbuffer(&self) ->  Result<Option<Vector<'a, u8>>, InvalidFlatbuffer> {
                self.table.get_field(30)
            }

            /// Getter for the `testempty` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testempty(&self) -> Option<StatView<'a>> {
                self.try_get_testempty().unwrap()
            }

            /// Getter for the `testempty` field.
            ///
            #[inline]
            pub fn try_get_testempty(&self) ->  Result<Option<StatView<'a>>, InvalidFlatbuffer> {
                self.table.get_field(32)
            }

            /// Getter for the `testbool` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testbool(&self) -> bool {
                self.try_get_testbool().unwrap()
            }

            /// Getter for the `testbool` field.
            ///
            #[inline]
            pub fn try_get_testbool(&self) -> Result<bool, InvalidFlatbuffer> {
                self.table.get_field(34).map(|value| value.unwrap_or(false))
            }

            /// Getter for the `testhashs32_fnv1` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testhashs32_fnv1(&self) -> i32 {
                self.try_get_testhashs32_fnv1().unwrap()
            }

            /// Getter for the `testhashs32_fnv1` field.
            ///
            #[inline]
            pub fn try_get_testhashs32_fnv1(&self) -> Result<i32, InvalidFlatbuffer> {
                self.table.get_field(36).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `testhashu32_fnv1` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testhashu32_fnv1(&self) -> u32 {
                self.try_get_testhashu32_fnv1().unwrap()
            }

            /// Getter for the `testhashu32_fnv1` field.
            ///
            #[inline]
            pub fn try_get_testhashu32_fnv1(&self) -> Result<u32, InvalidFlatbuffer> {
                self.table.get_field(38).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `testhashs64_fnv1` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testhashs64_fnv1(&self) -> i64 {
                self.try_get_testhashs64_fnv1().unwrap()
            }

            /// Getter for the `testhashs64_fnv1` field.
            ///
            #[inline]
            pub fn try_get_testhashs64_fnv1(&self) -> Result<i64, InvalidFlatbuffer> {
                self.table.get_field(40).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `testhashu64_fnv1` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testhashu64_fnv1(&self) -> u64 {
                self.try_get_testhashu64_fnv1().unwrap()
            }

            /// Getter for the `testhashu64_fnv1` field.
            ///
            #[inline]
            pub fn try_get_testhashu64_fnv1(&self) -> Result<u64, InvalidFlatbuffer> {
                self.table.get_field(42).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `testhashs32_fnv1a` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testhashs32_fnv1a(&self) -> i32 {
                self.try_get_testhashs32_fnv1a().unwrap()
            }

            /// Getter for the `testhashs32_fnv1a` field.
            ///
            #[inline]
            pub fn try_get_testhashs32_fnv1a(&self) -> Result<i32, InvalidFlatbuffer> {
                self.table.get_field(44).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `testhashu32_fnv1a` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testhashu32_fnv1a(&self) -> u32 {
                self.try_get_testhashu32_fnv1a().unwrap()
            }

            /// Getter for the `testhashu32_fnv1a` field.
            ///
            #[inline]
            pub fn try_get_testhashu32_fnv1a(&self) -> Result<u32, InvalidFlatbuffer> {
                self.table.get_field(46).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `testhashs64_fnv1a` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testhashs64_fnv1a(&self) -> i64 {
                self.try_get_testhashs64_fnv1a().unwrap()
            }

            /// Getter for the `testhashs64_fnv1a` field.
            ///
            #[inline]
            pub fn try_get_testhashs64_fnv1a(&self) -> Result<i64, InvalidFlatbuffer> {
                self.table.get_field(48).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `testhashu64_fnv1a` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testhashu64_fnv1a(&self) -> u64 {
                self.try_get_testhashu64_fnv1a().unwrap()
            }

            /// Getter for the `testhashu64_fnv1a` field.
            ///
            #[inline]
            pub fn try_get_testhashu64_fnv1a(&self) -> Result<u64, InvalidFlatbuffer> {
                self.table.get_field(50).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `testarrayofbools` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testarrayofbools(&self) -> Option<Vector<'a, bool>> {
                self.try_get_testarrayofbools().unwrap()
            }

            /// Getter for the `testarrayofbools` field.
            ///
            #[inline]
            pub fn try_get_testarrayofbools(&self) ->  Result<Option<Vector<'a, bool>>, InvalidFlatbuffer> {
                self.table.get_field(52)
            }

            /// Getter for the `testf` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testf(&self) -> f32 {
                self.try_get_testf().unwrap()
            }

            /// Getter for the `testf` field.
            ///
            #[inline]
            pub fn try_get_testf(&self) -> Result<f32, InvalidFlatbuffer> {
                self.table.get_field(54).map(|value| value.unwrap_or(3.14159))
            }

            /// Getter for the `testf2` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testf2(&self) -> f32 {
                self.try_get_testf2().unwrap()
            }

            /// Getter for the `testf2` field.
            ///
            #[inline]
            pub fn try_get_testf2(&self) -> Result<f32, InvalidFlatbuffer> {
                self.table.get_field(56).map(|value| value.unwrap_or(3.0))
            }

            /// Getter for the `testf3` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testf3(&self) -> f32 {
                self.try_get_testf3().unwrap()
            }

            /// Getter for the `testf3` field.
            ///
            #[inline]
            pub fn try_get_testf3(&self) -> Result<f32, InvalidFlatbuffer> {
                self.table.get_field(58).map(|value| value.unwrap_or(0.0))
            }

            /// Getter for the `testarrayofstring2` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testarrayofstring2(&self) -> Option<Vector<'a, Str<'a>>> {
                self.try_get_testarrayofstring2().unwrap()
            }

            /// Getter for the `testarrayofstring2` field.
            ///
            #[inline]
            pub fn try_get_testarrayofstring2(&self) ->  Result<Option<Vector<'a, Str<'a>>>, InvalidFlatbuffer> {
                self.table.get_field(60)
            }

            /// Getter for the `testarrayofsortedstruct` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn testarrayofsortedstruct(&self) -> Option<Vector<'a, AbilityView<'a>>> {
                self.try_get_testarrayofsortedstruct().unwrap()
            }

            /// Getter for the `testarrayofsortedstruct` field.
            ///
            #[inline]
            pub fn try_get_testarrayofsortedstruct(&self) ->  Result<Option<Vector<'a, AbilityView<'a>>>, InvalidFlatbuffer> {
                self.table.get_field(62)
            }

            /// Getter for the `flex` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn flex(&self) -> Option<Vector<'a, u8>> {
                self.try_get_flex().unwrap()
            }

            /// Getter for the `flex` field.
            ///
            #[inline]
            pub fn try_get_flex(&self) ->  Result<Option<Vector<'a, u8>>, InvalidFlatbuffer> {
                self.table.get_field(64)
            }

            /// Getter for the `test5` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn test5(&self) -> Option<Vector<'a, TestView<'a>>> {
                self.try_get_test5().unwrap()
            }

            /// Getter for the `test5` field.
            ///
            #[inline]
            pub fn try_get_test5(&self) ->  Result<Option<Vector<'a, TestView<'a>>>, InvalidFlatbuffer> {
                self.table.get_field(66)
            }

            /// Getter for the `vector_of_longs` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn vector_of_longs(&self) -> Option<Vector<'a, i64>> {
                self.try_get_vector_of_longs().unwrap()
            }

            /// Getter for the `vector_of_longs` field.
            ///
            #[inline]
            pub fn try_get_vector_of_longs(&self) ->  Result<Option<Vector<'a, i64>>, InvalidFlatbuffer> {
                self.table.get_field(68)
            }

            /// Getter for the `vector_of_doubles` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn vector_of_doubles(&self) -> Option<Vector<'a, f64>> {
                self.try_get_vector_of_doubles().unwrap()
            }

            /// Getter for the `vector_of_doubles` field.
            ///
            #[inline]
            pub fn try_get_vector_of_doubles(&self) ->  Result<Option<Vector<'a, f64>>, InvalidFlatbuffer> {
                self.table.get_field(70)
            }

            /// Getter for the `parent_namespace_test` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn parent_namespace_test(&self) -> Option<super::InParentNamespaceView<'a>> {
                self.try_get_parent_namespace_test().unwrap()
            }

            /// Getter for the `parent_namespace_test` field.
            ///
            #[inline]
            pub fn try_get_parent_namespace_test(&self) ->  Result<Option<super::InParentNamespaceView<'a>>, InvalidFlatbuffer> {
                self.table.get_field(72)
            }

            /// Getter for the `vector_of_referrables` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn vector_of_referrables(&self) -> Option<Vector<'a, ReferrableView<'a>>> {
                self.try_get_vector_of_referrables().unwrap()
            }

            /// Getter for the `vector_of_referrables` field.
            ///
            #[inline]
            pub fn try_get_vector_of_referrables(&self) ->  Result<Option<Vector<'a, ReferrableView<'a>>>, InvalidFlatbuffer> {
                self.table.get_field(74)
            }

            /// Getter for the `single_weak_reference` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn single_weak_reference(&self) -> u64 {
                self.try_get_single_weak_reference().unwrap()
            }

            /// Getter for the `single_weak_reference` field.
            ///
            #[inline]
            pub fn try_get_single_weak_reference(&self) -> Result<u64, InvalidFlatbuffer> {
                self.table.get_field(76).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `vector_of_weak_references` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn vector_of_weak_references(&self) -> Option<Vector<'a, u64>> {
                self.try_get_vector_of_weak_references().unwrap()
            }

            /// Getter for the `vector_of_weak_references` field.
            ///
            #[inline]
            pub fn try_get_vector_of_weak_references(&self) ->  Result<Option<Vector<'a, u64>>, InvalidFlatbuffer> {
                self.table.get_field(78)
            }

            /// Getter for the `vector_of_strong_referrables` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn vector_of_strong_referrables(&self) -> Option<Vector<'a, ReferrableView<'a>>> {
                self.try_get_vector_of_strong_referrables().unwrap()
            }

            /// Getter for the `vector_of_strong_referrables` field.
            ///
            #[inline]
            pub fn try_get_vector_of_strong_referrables(&self) ->  Result<Option<Vector<'a, ReferrableView<'a>>>, InvalidFlatbuffer> {
                self.table.get_field(80)
            }

            /// Getter for the `co_owning_reference` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn co_owning_reference(&self) -> u64 {
                self.try_get_co_owning_reference().unwrap()
            }

            /// Getter for the `co_owning_reference` field.
            ///
            #[inline]
            pub fn try_get_co_owning_reference(&self) -> Result<u64, InvalidFlatbuffer> {
                self.table.get_field(82).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `vector_of_co_owning_references` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn vector_of_co_owning_references(&self) -> Option<Vector<'a, u64>> {
                self.try_get_vector_of_co_owning_references().unwrap()
            }

            /// Getter for the `vector_of_co_owning_references` field.
            ///
            #[inline]
            pub fn try_get_vector_of_co_owning_references(&self) ->  Result<Option<Vector<'a, u64>>, InvalidFlatbuffer> {
                self.table.get_field(84)
            }

            /// Getter for the `non_owning_reference` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn non_owning_reference(&self) -> u64 {
                self.try_get_non_owning_reference().unwrap()
            }

            /// Getter for the `non_owning_reference` field.
            ///
            #[inline]
            pub fn try_get_non_owning_reference(&self) -> Result<u64, InvalidFlatbuffer> {
                self.table.get_field(86).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `vector_of_non_owning_references` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn vector_of_non_owning_references(&self) -> Option<Vector<'a, u64>> {
                self.try_get_vector_of_non_owning_references().unwrap()
            }

            /// Getter for the `vector_of_non_owning_references` field.
            ///
            #[inline]
            pub fn try_get_vector_of_non_owning_references(&self) ->  Result<Option<Vector<'a, u64>>, InvalidFlatbuffer> {
                self.table.get_field(88)
            }

            /// Getter for the `any_unique` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn any_unique(&self) -> Option<AnyUniqueAliasesView<'a>> {
                self.try_get_any_unique().unwrap()
            }

            /// Getter for the `any_unique` field.
            ///
            #[inline]
            pub fn try_get_any_unique(&self) ->  Result<Option<AnyUniqueAliasesView<'a>>, InvalidFlatbuffer> {
                self.table.get_field_union(90, 92)
            }

            /// Getter for the `any_ambiguous` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn any_ambiguous(&self) -> Option<AnyAmbiguousAliasesView<'a>> {
                self.try_get_any_ambiguous().unwrap()
            }

            /// Getter for the `any_ambiguous` field.
            ///
            #[inline]
            pub fn try_get_any_ambiguous(&self) ->  Result<Option<AnyAmbiguousAliasesView<'a>>, InvalidFlatbuffer> {
                self.table.get_field_union(94, 96)
            }

            /// Getter for the `vector_of_enums` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn vector_of_enums(&self) -> Option<Vector<'a, Color>> {
                self.try_get_vector_of_enums().unwrap()
            }

            /// Getter for the `vector_of_enums` field.
            ///
            #[inline]
            pub fn try_get_vector_of_enums(&self) ->  Result<Option<Vector<'a, Color>>, InvalidFlatbuffer> {
                self.table.get_field(98)
            }

            /// Getter for the `signed_enum` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn signed_enum(&self) -> Race {
                self.try_get_signed_enum().unwrap()
            }

            /// Getter for the `signed_enum` field.
            ///
            #[inline]
            pub fn try_get_signed_enum(&self) -> Result<Race, InvalidFlatbuffer> {
                self.table.get_field(100).map(|value| value.unwrap_or(Race::None))
            }

            /// Begin parsing a flatbuffer with a `Weapon` as the root object
            #[inline]
            pub fn from_buffer_as_root(buffer: &'a [u8]) -> Result<Self, InvalidFlatbuffer> {
                FromTableField::from_field(buffer, 0)
            }
        }

        #[inline]
        pub fn get_root_as_monster<'a>(buffer: &'a [u8]) -> Result<MonsterView<'a>, InvalidFlatbuffer> {
            MonsterView::from_buffer_as_root(buffer)
        }

        impl<'a> fmt::Debug for MonsterView<'a> {
            fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
                formatter.debug_struct("MonsterView")
                    .field("pos", &self.try_get_pos())
                    .field("mana", &self.try_get_mana())
                    .field("hp", &self.try_get_hp())
                    .field("name", &self.try_get_name())
                    .field("inventory", &self.try_get_inventory())
                    .field("color", &self.try_get_color())
                    .field("test", &self.try_get_test())
                    .field("test4", &self.try_get_test4())
                    .field("testarrayofstring", &self.try_get_testarrayofstring())
                    .field("testarrayoftables", &self.try_get_testarrayoftables())
                    .field("enemy", &self.try_get_enemy())
                    .field("testnestedflatbuffer", &self.try_get_testnestedflatbuffer())
                    .field("testempty", &self.try_get_testempty())
                    .field("testbool", &self.try_get_testbool())
                    .field("testhashs32_fnv1", &self.try_get_testhashs32_fnv1())
                    .field("testhashu32_fnv1", &self.try_get_testhashu32_fnv1())
                    .field("testhashs64_fnv1", &self.try_get_testhashs64_fnv1())
                    .field("testhashu64_fnv1", &self.try_get_testhashu64_fnv1())
                    .field("testhashs32_fnv1a", &self.try_get_testhashs32_fnv1a())
                    .field("testhashu32_fnv1a", &self.try_get_testhashu32_fnv1a())
                    .field("testhashs64_fnv1a", &self.try_get_testhashs64_fnv1a())
                    .field("testhashu64_fnv1a", &self.try_get_testhashu64_fnv1a())
                    .field("testarrayofbools", &self.try_get_testarrayofbools())
                    .field("testf", &self.try_get_testf())
                    .field("testf2", &self.try_get_testf2())
                    .field("testf3", &self.try_get_testf3())
                    .field("testarrayofstring2", &self.try_get_testarrayofstring2())
                    .field("testarrayofsortedstruct", &self.try_get_testarrayofsortedstruct())
                    .field("flex", &self.try_get_flex())
                    .field("test5", &self.try_get_test5())
                    .field("vector_of_longs", &self.try_get_vector_of_longs())
                    .field("vector_of_doubles", &self.try_get_vector_of_doubles())
                    .field("parent_namespace_test", &self.try_get_parent_namespace_test())
                    .field("vector_of_referrables", &self.try_get_vector_of_referrables())
                    .field("single_weak_reference", &self.try_get_single_weak_reference())
                    .field("vector_of_weak_references", &self.try_get_vector_of_weak_references())
                    .field("vector_of_strong_referrables", &self.try_get_vector_of_strong_referrables())
                    .field("co_owning_reference", &self.try_get_co_owning_reference())
                    .field("vector_of_co_owning_references", &self.try_get_vector_of_co_owning_references())
                    .field("non_owning_reference", &self.try_get_non_owning_reference())
                    .field("vector_of_non_owning_references", &self.try_get_vector_of_non_owning_references())
                    .field("any_unique", &self.try_get_any_unique())
                    .field("any_ambiguous", &self.try_get_any_ambiguous())
                    .field("vector_of_enums", &self.try_get_vector_of_enums())
                    .field("signed_enum", &self.try_get_signed_enum())
                    .finish()
            }
        }

        /// Builder for a flatbuffer `Monster` object
        ///
        /// This struct is used for serializing. For deserializing see [`MonsterView`](struct.MonsterView.html).
        ///
        /// an example documentation comment: monster object
        #[derive(Copy, Clone, Debug, PartialEq)]
        pub struct Monster {
            pub pos: Option<Vec3>,
            pub mana: i16,
            pub hp: i16,
            pub name: Option<Offset<str>>,
            pub inventory: Option<Offset<[u8]>>,
            pub color: Color,
            pub test: Option<Any>,
            pub test4: Option<Offset<[Test]>>,
            pub testarrayofstring: Option<Offset<[Offset<str>]>>,
            pub testarrayoftables: Option<Offset<[Offset<Monster>]>>,
            pub enemy: Option<Offset<Monster>>,
            pub testnestedflatbuffer: Option<Offset<[u8]>>,
            pub testempty: Option<Offset<Stat>>,
            pub testbool: bool,
            pub testhashs32_fnv1: i32,
            pub testhashu32_fnv1: u32,
            pub testhashs64_fnv1: i64,
            pub testhashu64_fnv1: u64,
            pub testhashs32_fnv1a: i32,
            pub testhashu32_fnv1a: u32,
            pub testhashs64_fnv1a: i64,
            pub testhashu64_fnv1a: u64,
            pub testarrayofbools: Option<Offset<[bool]>>,
            pub testf: f32,
            pub testf2: f32,
            pub testf3: f32,
            pub testarrayofstring2: Option<Offset<[Offset<str>]>>,
            pub testarrayofsortedstruct: Option<Offset<[Ability]>>,
            pub flex: Option<Offset<[u8]>>,
            pub test5: Option<Offset<[Test]>>,
            pub vector_of_longs: Option<Offset<[i64]>>,
            pub vector_of_doubles: Option<Offset<[f64]>>,
            pub parent_namespace_test: Option<Offset<super::InParentNamespace>>,
            pub vector_of_referrables: Option<Offset<[Offset<Referrable>]>>,
            pub single_weak_reference: u64,
            pub vector_of_weak_references: Option<Offset<[u64]>>,
            pub vector_of_strong_referrables: Option<Offset<[Offset<Referrable>]>>,
            pub co_owning_reference: u64,
            pub vector_of_co_owning_references: Option<Offset<[u64]>>,
            pub non_owning_reference: u64,
            pub vector_of_non_owning_references: Option<Offset<[u64]>>,
            pub any_unique: Option<AnyUniqueAliases>,
            pub any_ambiguous: Option<AnyAmbiguousAliases>,
            pub vector_of_enums: Option<Offset<[Color]>>,
            pub signed_enum: Race,
        }

        impl Default for Monster {
            #[inline]
            fn default() -> Monster {
                Monster {
                    pos: None,
                    mana: 150,
                    hp: 100,
                    name: None,
                    inventory: None,
                    color: Color::Blue,
                    test: None,
                    test4: None,
                    testarrayofstring: None,
                    testarrayoftables: None,
                    enemy: None,
                    testnestedflatbuffer: None,
                    testempty: None,
                    testbool: false,
                    testhashs32_fnv1: 0,
                    testhashu32_fnv1: 0,
                    testhashs64_fnv1: 0,
                    testhashu64_fnv1: 0,
                    testhashs32_fnv1a: 0,
                    testhashu32_fnv1a: 0,
                    testhashs64_fnv1a: 0,
                    testhashu64_fnv1a: 0,
                    testarrayofbools: None,
                    testf: 3.14159,
                    testf2: 3.0,
                    testf3: 0.0,
                    testarrayofstring2: None,
                    testarrayofsortedstruct: None,
                    flex: None,
                    test5: None,
                    vector_of_longs: None,
                    vector_of_doubles: None,
                    parent_namespace_test: None,
                    vector_of_referrables: None,
                    single_weak_reference: 0,
                    vector_of_weak_references: None,
                    vector_of_strong_referrables: None,
                    co_owning_reference: 0,
                    vector_of_co_owning_references: None,
                    non_owning_reference: 0,
                    vector_of_non_owning_references: None,
                    any_unique: None,
                    any_ambiguous: None,
                    vector_of_enums: None,
                    signed_enum: Race::None,
                }
            }
        }

        unsafe impl FlatbufferTable for Monster {
            #[inline]
            fn validate_required(&self) {
                if self.name.is_none() {
                    panic!("Missing field 'name' while serializing Monster");
                }
            }

            #[inline]
            fn serialize<F: FlatbufferWriter>(
                &self,
                flatbuffer: &mut F,
            ) -> Result<RawOffset, OutOfBufferSpace> {
                let mut vtable = [0u8; 102];

                let mut size = 0;
                let mut alignment = 4;
                let mut vtable_len = 4;

                if self.pos != None {
                    vtable_len = vtable_len.max(4 + 2);
                    const CUR_ALIGN: usize = <Vec3 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[4..4+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Vec3 as FlatbufferPrimitive>::SIZE;
                }
                if self.testhashs64_fnv1 != 0 {
                    vtable_len = vtable_len.max(40 + 2);
                    const CUR_ALIGN: usize = <i64 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[40..40+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <i64 as FlatbufferPrimitive>::SIZE;
                }
                if self.testhashu64_fnv1 != 0 {
                    vtable_len = vtable_len.max(42 + 2);
                    const CUR_ALIGN: usize = <u64 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[42..42+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <u64 as FlatbufferPrimitive>::SIZE;
                }
                if self.testhashs64_fnv1a != 0 {
                    vtable_len = vtable_len.max(48 + 2);
                    const CUR_ALIGN: usize = <i64 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[48..48+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <i64 as FlatbufferPrimitive>::SIZE;
                }
                if self.testhashu64_fnv1a != 0 {
                    vtable_len = vtable_len.max(50 + 2);
                    const CUR_ALIGN: usize = <u64 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[50..50+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <u64 as FlatbufferPrimitive>::SIZE;
                }
                if self.single_weak_reference != 0 {
                    vtable_len = vtable_len.max(76 + 2);
                    const CUR_ALIGN: usize = <u64 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[76..76+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <u64 as FlatbufferPrimitive>::SIZE;
                }
                if self.co_owning_reference != 0 {
                    vtable_len = vtable_len.max(82 + 2);
                    const CUR_ALIGN: usize = <u64 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[82..82+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <u64 as FlatbufferPrimitive>::SIZE;
                }
                if self.non_owning_reference != 0 {
                    vtable_len = vtable_len.max(86 + 2);
                    const CUR_ALIGN: usize = <u64 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[86..86+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <u64 as FlatbufferPrimitive>::SIZE;
                }
                if self.name != None {
                    vtable_len = vtable_len.max(10 + 2);
                    const CUR_ALIGN: usize = <Offset<str> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[10..10+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<str> as FlatbufferPrimitive>::SIZE;
                }
                if self.inventory != None {
                    vtable_len = vtable_len.max(14 + 2);
                    const CUR_ALIGN: usize = <Offset<[u8]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[14..14+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[u8]> as FlatbufferPrimitive>::SIZE;
                }
                if self.test != None {
                    vtable_len = vtable_len.max(20 + 2);
                    const CUR_ALIGN: usize = <Offset<()> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[20..20+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<()> as FlatbufferPrimitive>::SIZE;
                }
                if self.test4 != None {
                    vtable_len = vtable_len.max(22 + 2);
                    const CUR_ALIGN: usize = <Offset<[Test]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[22..22+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[Test]> as FlatbufferPrimitive>::SIZE;
                }
                if self.testarrayofstring != None {
                    vtable_len = vtable_len.max(24 + 2);
                    const CUR_ALIGN: usize = <Offset<[Offset<str>]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[24..24+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[Offset<str>]> as FlatbufferPrimitive>::SIZE;
                }
                if self.testarrayoftables != None {
                    vtable_len = vtable_len.max(26 + 2);
                    const CUR_ALIGN: usize = <Offset<[Offset<Monster>]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[26..26+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[Offset<Monster>]> as FlatbufferPrimitive>::SIZE;
                }
                if self.enemy != None {
                    vtable_len = vtable_len.max(28 + 2);
                    const CUR_ALIGN: usize = <Offset<Monster> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[28..28+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<Monster> as FlatbufferPrimitive>::SIZE;
                }
                if self.testnestedflatbuffer != None {
                    vtable_len = vtable_len.max(30 + 2);
                    const CUR_ALIGN: usize = <Offset<[u8]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[30..30+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[u8]> as FlatbufferPrimitive>::SIZE;
                }
                if self.testempty != None {
                    vtable_len = vtable_len.max(32 + 2);
                    const CUR_ALIGN: usize = <Offset<Stat> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[32..32+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<Stat> as FlatbufferPrimitive>::SIZE;
                }
                if self.testhashs32_fnv1 != 0 {
                    vtable_len = vtable_len.max(36 + 2);
                    const CUR_ALIGN: usize = <i32 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[36..36+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <i32 as FlatbufferPrimitive>::SIZE;
                }
                if self.testhashu32_fnv1 != 0 {
                    vtable_len = vtable_len.max(38 + 2);
                    const CUR_ALIGN: usize = <u32 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[38..38+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <u32 as FlatbufferPrimitive>::SIZE;
                }
                if self.testhashs32_fnv1a != 0 {
                    vtable_len = vtable_len.max(44 + 2);
                    const CUR_ALIGN: usize = <i32 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[44..44+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <i32 as FlatbufferPrimitive>::SIZE;
                }
                if self.testhashu32_fnv1a != 0 {
                    vtable_len = vtable_len.max(46 + 2);
                    const CUR_ALIGN: usize = <u32 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[46..46+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <u32 as FlatbufferPrimitive>::SIZE;
                }
                if self.testarrayofbools != None {
                    vtable_len = vtable_len.max(52 + 2);
                    const CUR_ALIGN: usize = <Offset<[bool]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[52..52+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[bool]> as FlatbufferPrimitive>::SIZE;
                }
                if self.testf != 3.14159 {
                    vtable_len = vtable_len.max(54 + 2);
                    const CUR_ALIGN: usize = <f32 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[54..54+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <f32 as FlatbufferPrimitive>::SIZE;
                }
                if self.testf2 != 3.0 {
                    vtable_len = vtable_len.max(56 + 2);
                    const CUR_ALIGN: usize = <f32 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[56..56+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <f32 as FlatbufferPrimitive>::SIZE;
                }
                if self.testf3 != 0.0 {
                    vtable_len = vtable_len.max(58 + 2);
                    const CUR_ALIGN: usize = <f32 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[58..58+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <f32 as FlatbufferPrimitive>::SIZE;
                }
                if self.testarrayofstring2 != None {
                    vtable_len = vtable_len.max(60 + 2);
                    const CUR_ALIGN: usize = <Offset<[Offset<str>]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[60..60+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[Offset<str>]> as FlatbufferPrimitive>::SIZE;
                }
                if self.testarrayofsortedstruct != None {
                    vtable_len = vtable_len.max(62 + 2);
                    const CUR_ALIGN: usize = <Offset<[Ability]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[62..62+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[Ability]> as FlatbufferPrimitive>::SIZE;
                }
                if self.flex != None {
                    vtable_len = vtable_len.max(64 + 2);
                    const CUR_ALIGN: usize = <Offset<[u8]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[64..64+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[u8]> as FlatbufferPrimitive>::SIZE;
                }
                if self.test5 != None {
                    vtable_len = vtable_len.max(66 + 2);
                    const CUR_ALIGN: usize = <Offset<[Test]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[66..66+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[Test]> as FlatbufferPrimitive>::SIZE;
                }
                if self.vector_of_longs != None {
                    vtable_len = vtable_len.max(68 + 2);
                    const CUR_ALIGN: usize = <Offset<[i64]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[68..68+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[i64]> as FlatbufferPrimitive>::SIZE;
                }
                if self.vector_of_doubles != None {
                    vtable_len = vtable_len.max(70 + 2);
                    const CUR_ALIGN: usize = <Offset<[f64]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[70..70+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[f64]> as FlatbufferPrimitive>::SIZE;
                }
                if self.parent_namespace_test != None {
                    vtable_len = vtable_len.max(72 + 2);
                    const CUR_ALIGN: usize = <Offset<super::InParentNamespace> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[72..72+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<super::InParentNamespace> as FlatbufferPrimitive>::SIZE;
                }
                if self.vector_of_referrables != None {
                    vtable_len = vtable_len.max(74 + 2);
                    const CUR_ALIGN: usize = <Offset<[Offset<Referrable>]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[74..74+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[Offset<Referrable>]> as FlatbufferPrimitive>::SIZE;
                }
                if self.vector_of_weak_references != None {
                    vtable_len = vtable_len.max(78 + 2);
                    const CUR_ALIGN: usize = <Offset<[u64]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[78..78+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[u64]> as FlatbufferPrimitive>::SIZE;
                }
                if self.vector_of_strong_referrables != None {
                    vtable_len = vtable_len.max(80 + 2);
                    const CUR_ALIGN: usize = <Offset<[Offset<Referrable>]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[80..80+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[Offset<Referrable>]> as FlatbufferPrimitive>::SIZE;
                }
                if self.vector_of_co_owning_references != None {
                    vtable_len = vtable_len.max(84 + 2);
                    const CUR_ALIGN: usize = <Offset<[u64]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[84..84+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[u64]> as FlatbufferPrimitive>::SIZE;
                }
                if self.vector_of_non_owning_references != None {
                    vtable_len = vtable_len.max(88 + 2);
                    const CUR_ALIGN: usize = <Offset<[u64]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[88..88+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[u64]> as FlatbufferPrimitive>::SIZE;
                }
                if self.any_unique != None {
                    vtable_len = vtable_len.max(92 + 2);
                    const CUR_ALIGN: usize = <Offset<()> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[92..92+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<()> as FlatbufferPrimitive>::SIZE;
                }
                if self.any_ambiguous != None {
                    vtable_len = vtable_len.max(96 + 2);
                    const CUR_ALIGN: usize = <Offset<()> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[96..96+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<()> as FlatbufferPrimitive>::SIZE;
                }
                if self.vector_of_enums != None {
                    vtable_len = vtable_len.max(98 + 2);
                    const CUR_ALIGN: usize = <Offset<[Color]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[98..98+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[Color]> as FlatbufferPrimitive>::SIZE;
                }
                if self.mana != 150 {
                    vtable_len = vtable_len.max(6 + 2);
                    const CUR_ALIGN: usize = <i16 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[6..6+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <i16 as FlatbufferPrimitive>::SIZE;
                }
                if self.hp != 100 {
                    vtable_len = vtable_len.max(8 + 2);
                    const CUR_ALIGN: usize = <i16 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[8..8+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <i16 as FlatbufferPrimitive>::SIZE;
                }
                if self.color != Color::Blue {
                    vtable_len = vtable_len.max(16 + 2);
                    const CUR_ALIGN: usize = <Color as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[16..16+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Color as FlatbufferPrimitive>::SIZE;
                }
                if self.test != None {
                    vtable_len = vtable_len.max(18 + 2);
                    const CUR_ALIGN: usize = <AnyTag as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[18..18+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <AnyTag as FlatbufferPrimitive>::SIZE;
                }
                if self.testbool != false {
                    vtable_len = vtable_len.max(34 + 2);
                    const CUR_ALIGN: usize = <bool as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[34..34+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <bool as FlatbufferPrimitive>::SIZE;
                }
                if self.any_unique != None {
                    vtable_len = vtable_len.max(90 + 2);
                    const CUR_ALIGN: usize = <AnyUniqueAliasesTag as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[90..90+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <AnyUniqueAliasesTag as FlatbufferPrimitive>::SIZE;
                }
                if self.any_ambiguous != None {
                    vtable_len = vtable_len.max(94 + 2);
                    const CUR_ALIGN: usize = <AnyAmbiguousAliasesTag as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[94..94+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <AnyAmbiguousAliasesTag as FlatbufferPrimitive>::SIZE;
                }
                if self.signed_enum != Race::None {
                    vtable_len = vtable_len.max(100 + 2);
                    const CUR_ALIGN: usize = <Race as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[100..100+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Race as FlatbufferPrimitive>::SIZE;
                }
                flatbuffer.align_before_write(size, alignment - 1)?;
                if self.signed_enum != Race::None {
                    flatbuffer.write_primitive(&self.signed_enum)?;
                }
                if let Some(ref value) = self.any_ambiguous {
                    flatbuffer.write_primitive(&value.tag())?;
                }
                if let Some(ref value) = self.any_unique {
                    flatbuffer.write_primitive(&value.tag())?;
                }
                if self.testbool != false {
                    flatbuffer.write_primitive(&self.testbool)?;
                }
                if let Some(ref value) = self.test {
                    flatbuffer.write_primitive(&value.tag())?;
                }
                if self.color != Color::Blue {
                    flatbuffer.write_primitive(&self.color)?;
                }
                if self.hp != 100 {
                    flatbuffer.write_primitive(&self.hp)?;
                }
                if self.mana != 150 {
                    flatbuffer.write_primitive(&self.mana)?;
                }
                if let Some(ref value) = self.vector_of_enums {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.any_ambiguous {
                    flatbuffer.write_primitive(&value.offset())?;
                }
                if let Some(ref value) = self.any_unique {
                    flatbuffer.write_primitive(&value.offset())?;
                }
                if let Some(ref value) = self.vector_of_non_owning_references {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.vector_of_co_owning_references {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.vector_of_strong_referrables {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.vector_of_weak_references {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.vector_of_referrables {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.parent_namespace_test {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.vector_of_doubles {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.vector_of_longs {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.test5 {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.flex {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.testarrayofsortedstruct {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.testarrayofstring2 {
                    flatbuffer.write_primitive(value)?;
                }
                if self.testf3 != 0.0 {
                    flatbuffer.write_primitive(&self.testf3)?;
                }
                if self.testf2 != 3.0 {
                    flatbuffer.write_primitive(&self.testf2)?;
                }
                if self.testf != 3.14159 {
                    flatbuffer.write_primitive(&self.testf)?;
                }
                if let Some(ref value) = self.testarrayofbools {
                    flatbuffer.write_primitive(value)?;
                }
                if self.testhashu32_fnv1a != 0 {
                    flatbuffer.write_primitive(&self.testhashu32_fnv1a)?;
                }
                if self.testhashs32_fnv1a != 0 {
                    flatbuffer.write_primitive(&self.testhashs32_fnv1a)?;
                }
                if self.testhashu32_fnv1 != 0 {
                    flatbuffer.write_primitive(&self.testhashu32_fnv1)?;
                }
                if self.testhashs32_fnv1 != 0 {
                    flatbuffer.write_primitive(&self.testhashs32_fnv1)?;
                }
                if let Some(ref value) = self.testempty {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.testnestedflatbuffer {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.enemy {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.testarrayoftables {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.testarrayofstring {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.test4 {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.test {
                    flatbuffer.write_primitive(&value.offset())?;
                }
                if let Some(ref value) = self.inventory {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.name {
                    flatbuffer.write_primitive(value)?;
                }
                if self.non_owning_reference != 0 {
                    flatbuffer.write_primitive(&self.non_owning_reference)?;
                }
                if self.co_owning_reference != 0 {
                    flatbuffer.write_primitive(&self.co_owning_reference)?;
                }
                if self.single_weak_reference != 0 {
                    flatbuffer.write_primitive(&self.single_weak_reference)?;
                }
                if self.testhashu64_fnv1a != 0 {
                    flatbuffer.write_primitive(&self.testhashu64_fnv1a)?;
                }
                if self.testhashs64_fnv1a != 0 {
                    flatbuffer.write_primitive(&self.testhashs64_fnv1a)?;
                }
                if self.testhashu64_fnv1 != 0 {
                    flatbuffer.write_primitive(&self.testhashu64_fnv1)?;
                }
                if self.testhashs64_fnv1 != 0 {
                    flatbuffer.write_primitive(&self.testhashs64_fnv1)?;
                }
                if let Some(ref value) = self.pos {
                    flatbuffer.write_primitive(value)?;
                }
                flatbuffer.write_vtable_and_offset(&mut vtable[..vtable_len], size + 4)
            }
        }

        /// View of a flatbuffer `TypeAliases` object
        ///
        /// This struct is used for deserializing. For serializing see [`TypeAliases`](struct.TypeAliases.html).
        ///
        #[derive(Copy, Clone)]
        pub struct TypeAliasesView<'a> {
            table: Table<'a>,
        }

        #[doc(hidden)]
        impl<'a> FromTableField<'a> for TypeAliasesView<'a> {
            const INLINE_SIZE: usize = Table::INLINE_SIZE;

            #[inline]
            fn from_field(buf: &'a [u8], offset: usize) -> Result<Self, InvalidFlatbuffer> {
                FromTableField::from_field(buf, offset).map(|table| Self { table })
            }
        }

        impl<'a> TypeAliasesView<'a> {
            /// Getter for the `i8` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn i8_(&self) -> i8 {
                self.try_get_i8_().unwrap()
            }

            /// Getter for the `i8` field.
            ///
            #[inline]
            pub fn try_get_i8_(&self) -> Result<i8, InvalidFlatbuffer> {
                self.table.get_field(4).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `u8` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn u8_(&self) -> u8 {
                self.try_get_u8_().unwrap()
            }

            /// Getter for the `u8` field.
            ///
            #[inline]
            pub fn try_get_u8_(&self) -> Result<u8, InvalidFlatbuffer> {
                self.table.get_field(6).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `i16` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn i16_(&self) -> i16 {
                self.try_get_i16_().unwrap()
            }

            /// Getter for the `i16` field.
            ///
            #[inline]
            pub fn try_get_i16_(&self) -> Result<i16, InvalidFlatbuffer> {
                self.table.get_field(8).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `u16` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn u16_(&self) -> u16 {
                self.try_get_u16_().unwrap()
            }

            /// Getter for the `u16` field.
            ///
            #[inline]
            pub fn try_get_u16_(&self) -> Result<u16, InvalidFlatbuffer> {
                self.table.get_field(10).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `i32` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn i32_(&self) -> i32 {
                self.try_get_i32_().unwrap()
            }

            /// Getter for the `i32` field.
            ///
            #[inline]
            pub fn try_get_i32_(&self) -> Result<i32, InvalidFlatbuffer> {
                self.table.get_field(12).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `u32` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn u32_(&self) -> u32 {
                self.try_get_u32_().unwrap()
            }

            /// Getter for the `u32` field.
            ///
            #[inline]
            pub fn try_get_u32_(&self) -> Result<u32, InvalidFlatbuffer> {
                self.table.get_field(14).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `i64` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn i64_(&self) -> i64 {
                self.try_get_i64_().unwrap()
            }

            /// Getter for the `i64` field.
            ///
            #[inline]
            pub fn try_get_i64_(&self) -> Result<i64, InvalidFlatbuffer> {
                self.table.get_field(16).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `u64` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn u64_(&self) -> u64 {
                self.try_get_u64_().unwrap()
            }

            /// Getter for the `u64` field.
            ///
            #[inline]
            pub fn try_get_u64_(&self) -> Result<u64, InvalidFlatbuffer> {
                self.table.get_field(18).map(|value| value.unwrap_or(0))
            }

            /// Getter for the `f32` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn f32_(&self) -> f32 {
                self.try_get_f32_().unwrap()
            }

            /// Getter for the `f32` field.
            ///
            #[inline]
            pub fn try_get_f32_(&self) -> Result<f32, InvalidFlatbuffer> {
                self.table.get_field(20).map(|value| value.unwrap_or(0.0))
            }

            /// Getter for the `f64` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn f64_(&self) -> f64 {
                self.try_get_f64_().unwrap()
            }

            /// Getter for the `f64` field.
            ///
            #[inline]
            pub fn try_get_f64_(&self) -> Result<f64, InvalidFlatbuffer> {
                self.table.get_field(22).map(|value| value.unwrap_or(0.0))
            }

            /// Getter for the `v8` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn v8(&self) -> Option<Vector<'a, i8>> {
                self.try_get_v8().unwrap()
            }

            /// Getter for the `v8` field.
            ///
            #[inline]
            pub fn try_get_v8(&self) ->  Result<Option<Vector<'a, i8>>, InvalidFlatbuffer> {
                self.table.get_field(24)
            }

            /// Getter for the `vf64` field.
            ///
            ///
            /// # Panics
            ///
            /// If the value cannot be deserialized.
            #[inline]
            pub fn vf64(&self) -> Option<Vector<'a, f64>> {
                self.try_get_vf64().unwrap()
            }

            /// Getter for the `vf64` field.
            ///
            #[inline]
            pub fn try_get_vf64(&self) ->  Result<Option<Vector<'a, f64>>, InvalidFlatbuffer> {
                self.table.get_field(26)
            }

            /// Begin parsing a flatbuffer with a `Weapon` as the root object
            #[inline]
            pub fn from_buffer_as_root(buffer: &'a [u8]) -> Result<Self, InvalidFlatbuffer> {
                FromTableField::from_field(buffer, 0)
            }
        }

        impl<'a> fmt::Debug for TypeAliasesView<'a> {
            fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
                formatter.debug_struct("TypeAliasesView")
                    .field("i8_", &self.try_get_i8_())
                    .field("u8_", &self.try_get_u8_())
                    .field("i16_", &self.try_get_i16_())
                    .field("u16_", &self.try_get_u16_())
                    .field("i32_", &self.try_get_i32_())
                    .field("u32_", &self.try_get_u32_())
                    .field("i64_", &self.try_get_i64_())
                    .field("u64_", &self.try_get_u64_())
                    .field("f32_", &self.try_get_f32_())
                    .field("f64_", &self.try_get_f64_())
                    .field("v8", &self.try_get_v8())
                    .field("vf64", &self.try_get_vf64())
                    .finish()
            }
        }

        /// Builder for a flatbuffer `TypeAliases` object
        ///
        /// This struct is used for serializing. For deserializing see [`TypeAliasesView`](struct.TypeAliasesView.html).
        ///
        #[derive(Copy, Clone, Debug, PartialEq)]
        pub struct TypeAliases {
            pub i8_: i8,
            pub u8_: u8,
            pub i16_: i16,
            pub u16_: u16,
            pub i32_: i32,
            pub u32_: u32,
            pub i64_: i64,
            pub u64_: u64,
            pub f32_: f32,
            pub f64_: f64,
            pub v8: Option<Offset<[i8]>>,
            pub vf64: Option<Offset<[f64]>>,
        }

        impl Default for TypeAliases {
            #[inline]
            fn default() -> TypeAliases {
                TypeAliases {
                    i8_: 0,
                    u8_: 0,
                    i16_: 0,
                    u16_: 0,
                    i32_: 0,
                    u32_: 0,
                    i64_: 0,
                    u64_: 0,
                    f32_: 0.0,
                    f64_: 0.0,
                    v8: None,
                    vf64: None,
                }
            }
        }

        unsafe impl FlatbufferTable for TypeAliases {
            #[inline]
            fn validate_required(&self) {
            }

            #[inline]
            fn serialize<F: FlatbufferWriter>(
                &self,
                flatbuffer: &mut F,
            ) -> Result<RawOffset, OutOfBufferSpace> {
                let mut vtable = [0u8; 28];

                let mut size = 0;
                let mut alignment = 4;
                let mut vtable_len = 4;

                if self.i64_ != 0 {
                    vtable_len = vtable_len.max(16 + 2);
                    const CUR_ALIGN: usize = <i64 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[16..16+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <i64 as FlatbufferPrimitive>::SIZE;
                }
                if self.u64_ != 0 {
                    vtable_len = vtable_len.max(18 + 2);
                    const CUR_ALIGN: usize = <u64 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[18..18+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <u64 as FlatbufferPrimitive>::SIZE;
                }
                if self.f64_ != 0.0 {
                    vtable_len = vtable_len.max(22 + 2);
                    const CUR_ALIGN: usize = <f64 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[22..22+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <f64 as FlatbufferPrimitive>::SIZE;
                }
                if self.i32_ != 0 {
                    vtable_len = vtable_len.max(12 + 2);
                    const CUR_ALIGN: usize = <i32 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[12..12+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <i32 as FlatbufferPrimitive>::SIZE;
                }
                if self.u32_ != 0 {
                    vtable_len = vtable_len.max(14 + 2);
                    const CUR_ALIGN: usize = <u32 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[14..14+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <u32 as FlatbufferPrimitive>::SIZE;
                }
                if self.f32_ != 0.0 {
                    vtable_len = vtable_len.max(20 + 2);
                    const CUR_ALIGN: usize = <f32 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[20..20+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <f32 as FlatbufferPrimitive>::SIZE;
                }
                if self.v8 != None {
                    vtable_len = vtable_len.max(24 + 2);
                    const CUR_ALIGN: usize = <Offset<[i8]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[24..24+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[i8]> as FlatbufferPrimitive>::SIZE;
                }
                if self.vf64 != None {
                    vtable_len = vtable_len.max(26 + 2);
                    const CUR_ALIGN: usize = <Offset<[f64]> as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[26..26+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <Offset<[f64]> as FlatbufferPrimitive>::SIZE;
                }
                if self.i16_ != 0 {
                    vtable_len = vtable_len.max(8 + 2);
                    const CUR_ALIGN: usize = <i16 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[8..8+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <i16 as FlatbufferPrimitive>::SIZE;
                }
                if self.u16_ != 0 {
                    vtable_len = vtable_len.max(10 + 2);
                    const CUR_ALIGN: usize = <u16 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[10..10+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <u16 as FlatbufferPrimitive>::SIZE;
                }
                if self.i8_ != 0 {
                    vtable_len = vtable_len.max(4 + 2);
                    const CUR_ALIGN: usize = <i8 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[4..4+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <i8 as FlatbufferPrimitive>::SIZE;
                }
                if self.u8_ != 0 {
                    vtable_len = vtable_len.max(6 + 2);
                    const CUR_ALIGN: usize = <u8 as FlatbufferPrimitive>::ALIGNMENT;
                    alignment = alignment.max(CUR_ALIGN);
                    vtable[6..6+2].copy_from_slice(
                        &((size + 4) as u16).to_le_bytes());
                    size += <u8 as FlatbufferPrimitive>::SIZE;
                }
                flatbuffer.align_before_write(size, alignment - 1)?;
                if self.u8_ != 0 {
                    flatbuffer.write_primitive(&self.u8_)?;
                }
                if self.i8_ != 0 {
                    flatbuffer.write_primitive(&self.i8_)?;
                }
                if self.u16_ != 0 {
                    flatbuffer.write_primitive(&self.u16_)?;
                }
                if self.i16_ != 0 {
                    flatbuffer.write_primitive(&self.i16_)?;
                }
                if let Some(ref value) = self.vf64 {
                    flatbuffer.write_primitive(value)?;
                }
                if let Some(ref value) = self.v8 {
                    flatbuffer.write_primitive(value)?;
                }
                if self.f32_ != 0.0 {
                    flatbuffer.write_primitive(&self.f32_)?;
                }
                if self.u32_ != 0 {
                    flatbuffer.write_primitive(&self.u32_)?;
                }
                if self.i32_ != 0 {
                    flatbuffer.write_primitive(&self.i32_)?;
                }
                if self.f64_ != 0.0 {
                    flatbuffer.write_primitive(&self.f64_)?;
                }
                if self.u64_ != 0 {
                    flatbuffer.write_primitive(&self.u64_)?;
                }
                if self.i64_ != 0 {
                    flatbuffer.write_primitive(&self.i64_)?;
                }
                flatbuffer.write_vtable_and_offset(&mut vtable[..vtable_len], size + 4)
            }
        }
    }
    pub mod example2 {
        #![allow(unused_imports, irrefutable_let_patterns, dead_code, unused_mut)]
        use flatbuffers::{
            deserialize::{FromStructField, FromTableField, FromTableFieldUnion, Str, Table, Vector},
            errors::{InvalidFlatbuffer, OutOfBufferSpace, TryFromEnumError},
            serialize::{
                builder::FlatbufferWriter, FlatbufferPrimitive, FlatbufferTable, Offset, RawOffset,
            },
        };
        use core::{
            convert::{TryFrom, TryInto},
            fmt, ptr,
        };

        /// View of a flatbuffer `Monster` object
        ///
        /// This struct is used for deserializing. For serializing see [`Monster`](struct.Monster.html).
        ///
        #[derive(Copy, Clone)]
        pub struct MonsterView<'a> {
            table: Table<'a>,
        }

        #[doc(hidden)]
        impl<'a> FromTableField<'a> for MonsterView<'a> {
            const INLINE_SIZE: usize = Table::INLINE_SIZE;

            #[inline]
            fn from_field(buf: &'a [u8], offset: usize) -> Result<Self, InvalidFlatbuffer> {
                FromTableField::from_field(buf, offset).map(|table| Self { table })
            }
        }

        impl<'a> MonsterView<'a> {
            /// Begin parsing a flatbuffer with a `Weapon` as the root object
            #[inline]
            pub fn from_buffer_as_root(buffer: &'a [u8]) -> Result<Self, InvalidFlatbuffer> {
                FromTableField::from_field(buffer, 0)
            }
        }

        impl<'a> fmt::Debug for MonsterView<'a> {
            fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
                formatter.debug_struct("MonsterView")
                    .finish()
            }
        }

        /// Builder for a flatbuffer `Monster` object
        ///
        /// This struct is used for serializing. For deserializing see [`MonsterView`](struct.MonsterView.html).
        ///
        #[derive(Copy, Clone, Debug, PartialEq)]
        pub struct Monster {
        }

        impl Default for Monster {
            #[inline]
            fn default() -> Monster {
                Monster {
                }
            }
        }

        unsafe impl FlatbufferTable for Monster {
            #[inline]
            fn validate_required(&self) {
            }

            #[inline]
            fn serialize<F: FlatbufferWriter>(
                &self,
                flatbuffer: &mut F,
            ) -> Result<RawOffset, OutOfBufferSpace> {
                let mut vtable = [0u8; 6];

                let mut size = 0;
                let mut alignment = 4;
                let mut vtable_len = 4;

                flatbuffer.align_before_write(size, alignment - 1)?;
                flatbuffer.write_vtable_and_offset(&mut vtable[..vtable_len], size + 4)
            }
        }
    }

    /// View of a flatbuffer `InParentNamespace` object
    ///
    /// This struct is used for deserializing. For serializing see [`InParentNamespace`](struct.InParentNamespace.html).
    ///
    #[derive(Copy, Clone)]
    pub struct InParentNamespaceView<'a> {
        table: Table<'a>,
    }

    #[doc(hidden)]
    impl<'a> FromTableField<'a> for InParentNamespaceView<'a> {
        const INLINE_SIZE: usize = Table::INLINE_SIZE;

        #[inline]
        fn from_field(buf: &'a [u8], offset: usize) -> Result<Self, InvalidFlatbuffer> {
            FromTableField::from_field(buf, offset).map(|table| Self { table })
        }
    }

    impl<'a> InParentNamespaceView<'a> {
        /// Begin parsing a flatbuffer with a `Weapon` as the root object
        #[inline]
        pub fn from_buffer_as_root(buffer: &'a [u8]) -> Result<Self, InvalidFlatbuffer> {
            FromTableField::from_field(buffer, 0)
        }
    }

    impl<'a> fmt::Debug for InParentNamespaceView<'a> {
        fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
            formatter.debug_struct("InParentNamespaceView")
                .finish()
        }
    }

    /// Builder for a flatbuffer `InParentNamespace` object
    ///
    /// This struct is used for serializing. For deserializing see [`InParentNamespaceView`](struct.InParentNamespaceView.html).
    ///
    #[derive(Copy, Clone, Debug, PartialEq)]
    pub struct InParentNamespace {
    }

    impl Default for InParentNamespace {
        #[inline]
        fn default() -> InParentNamespace {
            InParentNamespace {
            }
        }
    }

    unsafe impl FlatbufferTable for InParentNamespace {
        #[inline]
        fn validate_required(&self) {
        }

        #[inline]
        fn serialize<F: FlatbufferWriter>(
            &self,
            flatbuffer: &mut F,
        ) -> Result<RawOffset, OutOfBufferSpace> {
            let mut vtable = [0u8; 6];

            let mut size = 0;
            let mut alignment = 4;
            let mut vtable_len = 4;

            flatbuffer.align_before_write(size, alignment - 1)?;
            flatbuffer.write_vtable_and_offset(&mut vtable[..vtable_len], size + 4)
        }
    }
}
