// automatically generated by the FlatBuffers compiler, do not modify


pub mod namespace_a {
    #![allow(unused_imports, irrefutable_let_patterns, dead_code, unused_mut)]
    use flatbuffers::{
        deserialize::{FromStructField, FromTableField, FromTableFieldUnion, Str, Table, Vector},
        errors::{InvalidFlatbuffer, OutOfBufferSpace, TryFromEnumError},
        serialize::{
            builder::FlatbufferWriter, FlatbufferPrimitive, FlatbufferTable, Offset, RawOffset,
        },
    };
    use core::{
        convert::{TryFrom, TryInto},
        fmt, ptr,
    };

    /// View of a flatbuffer `TableInFirstNS` object
    ///
    /// This struct is used for deserializing. For serializing see [`TableInFirstNS`](struct.TableInFirstNS.html).
    ///
    #[derive(Copy, Clone)]
    pub struct TableInFirstNSView<'a> {
        table: Table<'a>,
    }

    #[doc(hidden)]
    impl<'a> FromTableField<'a> for TableInFirstNSView<'a> {
        const INLINE_SIZE: usize = Table::INLINE_SIZE;

        #[inline]
        fn from_field(buf: &'a [u8], offset: usize) -> Result<Self, InvalidFlatbuffer> {
            FromTableField::from_field(buf, offset).map(|table| Self { table })
        }
    }

    impl<'a> TableInFirstNSView<'a> {
        /// Getter for the `foo_table` field.
        ///
        ///
        /// # Panics
        ///
        /// If the value cannot be deserialized.
        #[inline]
        pub fn foo_table(&self) -> Option<namespace_b::TableInNestedNSView<'a>> {
            self.try_get_foo_table().unwrap()
        }

        /// Getter for the `foo_table` field.
        ///
        #[inline]
        pub fn try_get_foo_table(&self) ->  Result<Option<namespace_b::TableInNestedNSView<'a>>, InvalidFlatbuffer> {
            self.table.get_field(4)
        }

        /// Getter for the `foo_enum` field.
        ///
        ///
        /// # Panics
        ///
        /// If the value cannot be deserialized.
        #[inline]
        pub fn foo_enum(&self) -> namespace_b::EnumInNestedNS {
            self.try_get_foo_enum().unwrap()
        }

        /// Getter for the `foo_enum` field.
        ///
        #[inline]
        pub fn try_get_foo_enum(&self) -> Result<namespace_b::EnumInNestedNS, InvalidFlatbuffer> {
            self.table.get_field(6).map(|value| value.unwrap_or(namespace_b::EnumInNestedNS::A))
        }

        /// Getter for the `foo_struct` field.
        ///
        ///
        /// # Panics
        ///
        /// If the value cannot be deserialized.
        #[inline]
        pub fn foo_struct(&self) -> Option<namespace_b::StructInNestedNSView<'a>> {
            self.try_get_foo_struct().unwrap()
        }

        /// Getter for the `foo_struct` field.
        ///
        #[inline]
        pub fn try_get_foo_struct(&self) ->  Result<Option<namespace_b::StructInNestedNSView<'a>>, InvalidFlatbuffer> {
            self.table.get_field(8)
        }

        /// Begin parsing a flatbuffer with a `Weapon` as the root object
        #[inline]
        pub fn from_buffer_as_root(buffer: &'a [u8]) -> Result<Self, InvalidFlatbuffer> {
            FromTableField::from_field(buffer, 0)
        }
    }

    impl<'a> fmt::Debug for TableInFirstNSView<'a> {
        fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
            formatter.debug_struct("TableInFirstNSView")
                .field("foo_table", &self.try_get_foo_table())
                .field("foo_enum", &self.try_get_foo_enum())
                .field("foo_struct", &self.try_get_foo_struct())
                .finish()
        }
    }

    /// Builder for a flatbuffer `TableInFirstNS` object
    ///
    /// This struct is used for serializing. For deserializing see [`TableInFirstNSView`](struct.TableInFirstNSView.html).
    ///
    #[derive(Copy, Clone, Debug, PartialEq)]
    pub struct TableInFirstNS {
        pub foo_table: Option<Offset<namespace_b::TableInNestedNS>>,
        pub foo_enum: namespace_b::EnumInNestedNS,
        pub foo_struct: Option<namespace_b::StructInNestedNS>,
    }

    impl Default for TableInFirstNS {
        #[inline]
        fn default() -> TableInFirstNS {
            TableInFirstNS {
                foo_table: None,
                foo_enum: namespace_b::EnumInNestedNS::A,
                foo_struct: None,
            }
        }
    }

    unsafe impl FlatbufferTable for TableInFirstNS {
        #[inline]
        fn validate_required(&self) {
        }

        #[inline]
        fn serialize<F: FlatbufferWriter>(
            &self,
            flatbuffer: &mut F,
        ) -> Result<RawOffset, OutOfBufferSpace> {
            let mut vtable = [0u8; 10];

            let mut size = 0;
            let mut alignment = 4;
            let mut vtable_len = 4;

            if self.foo_table != None {
                vtable_len = vtable_len.max(4 + 2);
                const CUR_ALIGN: usize = <Offset<namespace_b::TableInNestedNS> as FlatbufferPrimitive>::ALIGNMENT;
                alignment = alignment.max(CUR_ALIGN);
                vtable[4..4+2].copy_from_slice(
                    &((size + 4) as u16).to_le_bytes());
                size += <Offset<namespace_b::TableInNestedNS> as FlatbufferPrimitive>::SIZE;
            }
            if self.foo_struct != None {
                vtable_len = vtable_len.max(8 + 2);
                const CUR_ALIGN: usize = <namespace_b::StructInNestedNS as FlatbufferPrimitive>::ALIGNMENT;
                alignment = alignment.max(CUR_ALIGN);
                vtable[8..8+2].copy_from_slice(
                    &((size + 4) as u16).to_le_bytes());
                size += <namespace_b::StructInNestedNS as FlatbufferPrimitive>::SIZE;
            }
            if self.foo_enum != namespace_b::EnumInNestedNS::A {
                vtable_len = vtable_len.max(6 + 2);
                const CUR_ALIGN: usize = <namespace_b::EnumInNestedNS as FlatbufferPrimitive>::ALIGNMENT;
                alignment = alignment.max(CUR_ALIGN);
                vtable[6..6+2].copy_from_slice(
                    &((size + 4) as u16).to_le_bytes());
                size += <namespace_b::EnumInNestedNS as FlatbufferPrimitive>::SIZE;
            }
            flatbuffer.align_before_write(size, alignment - 1)?;
            if self.foo_enum != namespace_b::EnumInNestedNS::A {
                flatbuffer.write_primitive(&self.foo_enum)?;
            }
            if let Some(ref value) = self.foo_struct {
                flatbuffer.write_primitive(value)?;
            }
            if let Some(ref value) = self.foo_table {
                flatbuffer.write_primitive(value)?;
            }
            flatbuffer.write_vtable_and_offset(&mut vtable[..vtable_len], size + 4)
        }
    }

    /// View of a flatbuffer `SecondTableInA` object
    ///
    /// This struct is used for deserializing. For serializing see [`SecondTableInA`](struct.SecondTableInA.html).
    ///
    #[derive(Copy, Clone)]
    pub struct SecondTableInAView<'a> {
        table: Table<'a>,
    }

    #[doc(hidden)]
    impl<'a> FromTableField<'a> for SecondTableInAView<'a> {
        const INLINE_SIZE: usize = Table::INLINE_SIZE;

        #[inline]
        fn from_field(buf: &'a [u8], offset: usize) -> Result<Self, InvalidFlatbuffer> {
            FromTableField::from_field(buf, offset).map(|table| Self { table })
        }
    }

    impl<'a> SecondTableInAView<'a> {
        /// Getter for the `refer_to_c` field.
        ///
        ///
        /// # Panics
        ///
        /// If the value cannot be deserialized.
        #[inline]
        pub fn refer_to_c(&self) -> Option<super::namespace_c::TableInCView<'a>> {
            self.try_get_refer_to_c().unwrap()
        }

        /// Getter for the `refer_to_c` field.
        ///
        #[inline]
        pub fn try_get_refer_to_c(&self) ->  Result<Option<super::namespace_c::TableInCView<'a>>, InvalidFlatbuffer> {
            self.table.get_field(4)
        }

        /// Begin parsing a flatbuffer with a `Weapon` as the root object
        #[inline]
        pub fn from_buffer_as_root(buffer: &'a [u8]) -> Result<Self, InvalidFlatbuffer> {
            FromTableField::from_field(buffer, 0)
        }
    }

    impl<'a> fmt::Debug for SecondTableInAView<'a> {
        fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
            formatter.debug_struct("SecondTableInAView")
                .field("refer_to_c", &self.try_get_refer_to_c())
                .finish()
        }
    }

    /// Builder for a flatbuffer `SecondTableInA` object
    ///
    /// This struct is used for serializing. For deserializing see [`SecondTableInAView`](struct.SecondTableInAView.html).
    ///
    #[derive(Copy, Clone, Debug, PartialEq)]
    pub struct SecondTableInA {
        pub refer_to_c: Option<Offset<super::namespace_c::TableInC>>,
    }

    impl Default for SecondTableInA {
        #[inline]
        fn default() -> SecondTableInA {
            SecondTableInA {
                refer_to_c: None,
            }
        }
    }

    unsafe impl FlatbufferTable for SecondTableInA {
        #[inline]
        fn validate_required(&self) {
        }

        #[inline]
        fn serialize<F: FlatbufferWriter>(
            &self,
            flatbuffer: &mut F,
        ) -> Result<RawOffset, OutOfBufferSpace> {
            let mut vtable = [0u8; 6];

            let mut size = 0;
            let mut alignment = 4;
            let mut vtable_len = 4;

            if self.refer_to_c != None {
                vtable_len = vtable_len.max(4 + 2);
                const CUR_ALIGN: usize = <Offset<super::namespace_c::TableInC> as FlatbufferPrimitive>::ALIGNMENT;
                alignment = alignment.max(CUR_ALIGN);
                vtable[4..4+2].copy_from_slice(
                    &((size + 4) as u16).to_le_bytes());
                size += <Offset<super::namespace_c::TableInC> as FlatbufferPrimitive>::SIZE;
            }
            flatbuffer.align_before_write(size, alignment - 1)?;
            if let Some(ref value) = self.refer_to_c {
                flatbuffer.write_primitive(value)?;
            }
            flatbuffer.write_vtable_and_offset(&mut vtable[..vtable_len], size + 4)
        }
    }
}
pub mod namespace_c {
    #![allow(unused_imports, irrefutable_let_patterns, dead_code, unused_mut)]
    use flatbuffers::{
        deserialize::{FromStructField, FromTableField, FromTableFieldUnion, Str, Table, Vector},
        errors::{InvalidFlatbuffer, OutOfBufferSpace, TryFromEnumError},
        serialize::{
            builder::FlatbufferWriter, FlatbufferPrimitive, FlatbufferTable, Offset, RawOffset,
        },
    };
    use core::{
        convert::{TryFrom, TryInto},
        fmt, ptr,
    };

    /// View of a flatbuffer `TableInC` object
    ///
    /// This struct is used for deserializing. For serializing see [`TableInC`](struct.TableInC.html).
    ///
    #[derive(Copy, Clone)]
    pub struct TableInCView<'a> {
        table: Table<'a>,
    }

    #[doc(hidden)]
    impl<'a> FromTableField<'a> for TableInCView<'a> {
        const INLINE_SIZE: usize = Table::INLINE_SIZE;

        #[inline]
        fn from_field(buf: &'a [u8], offset: usize) -> Result<Self, InvalidFlatbuffer> {
            FromTableField::from_field(buf, offset).map(|table| Self { table })
        }
    }

    impl<'a> TableInCView<'a> {
        /// Getter for the `refer_to_a1` field.
        ///
        ///
        /// # Panics
        ///
        /// If the value cannot be deserialized.
        #[inline]
        pub fn refer_to_a1(&self) -> Option<super::namespace_a::TableInFirstNSView<'a>> {
            self.try_get_refer_to_a1().unwrap()
        }

        /// Getter for the `refer_to_a1` field.
        ///
        #[inline]
        pub fn try_get_refer_to_a1(&self) ->  Result<Option<super::namespace_a::TableInFirstNSView<'a>>, InvalidFlatbuffer> {
            self.table.get_field(4)
        }

        /// Getter for the `refer_to_a2` field.
        ///
        ///
        /// # Panics
        ///
        /// If the value cannot be deserialized.
        #[inline]
        pub fn refer_to_a2(&self) -> Option<super::namespace_a::SecondTableInAView<'a>> {
            self.try_get_refer_to_a2().unwrap()
        }

        /// Getter for the `refer_to_a2` field.
        ///
        #[inline]
        pub fn try_get_refer_to_a2(&self) ->  Result<Option<super::namespace_a::SecondTableInAView<'a>>, InvalidFlatbuffer> {
            self.table.get_field(6)
        }

        /// Begin parsing a flatbuffer with a `Weapon` as the root object
        #[inline]
        pub fn from_buffer_as_root(buffer: &'a [u8]) -> Result<Self, InvalidFlatbuffer> {
            FromTableField::from_field(buffer, 0)
        }
    }

    impl<'a> fmt::Debug for TableInCView<'a> {
        fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
            formatter.debug_struct("TableInCView")
                .field("refer_to_a1", &self.try_get_refer_to_a1())
                .field("refer_to_a2", &self.try_get_refer_to_a2())
                .finish()
        }
    }

    /// Builder for a flatbuffer `TableInC` object
    ///
    /// This struct is used for serializing. For deserializing see [`TableInCView`](struct.TableInCView.html).
    ///
    #[derive(Copy, Clone, Debug, PartialEq)]
    pub struct TableInC {
        pub refer_to_a1: Option<Offset<super::namespace_a::TableInFirstNS>>,
        pub refer_to_a2: Option<Offset<super::namespace_a::SecondTableInA>>,
    }

    impl Default for TableInC {
        #[inline]
        fn default() -> TableInC {
            TableInC {
                refer_to_a1: None,
                refer_to_a2: None,
            }
        }
    }

    unsafe impl FlatbufferTable for TableInC {
        #[inline]
        fn validate_required(&self) {
        }

        #[inline]
        fn serialize<F: FlatbufferWriter>(
            &self,
            flatbuffer: &mut F,
        ) -> Result<RawOffset, OutOfBufferSpace> {
            let mut vtable = [0u8; 8];

            let mut size = 0;
            let mut alignment = 4;
            let mut vtable_len = 4;

            if self.refer_to_a1 != None {
                vtable_len = vtable_len.max(4 + 2);
                const CUR_ALIGN: usize = <Offset<super::namespace_a::TableInFirstNS> as FlatbufferPrimitive>::ALIGNMENT;
                alignment = alignment.max(CUR_ALIGN);
                vtable[4..4+2].copy_from_slice(
                    &((size + 4) as u16).to_le_bytes());
                size += <Offset<super::namespace_a::TableInFirstNS> as FlatbufferPrimitive>::SIZE;
            }
            if self.refer_to_a2 != None {
                vtable_len = vtable_len.max(6 + 2);
                const CUR_ALIGN: usize = <Offset<super::namespace_a::SecondTableInA> as FlatbufferPrimitive>::ALIGNMENT;
                alignment = alignment.max(CUR_ALIGN);
                vtable[6..6+2].copy_from_slice(
                    &((size + 4) as u16).to_le_bytes());
                size += <Offset<super::namespace_a::SecondTableInA> as FlatbufferPrimitive>::SIZE;
            }
            flatbuffer.align_before_write(size, alignment - 1)?;
            if let Some(ref value) = self.refer_to_a2 {
                flatbuffer.write_primitive(value)?;
            }
            if let Some(ref value) = self.refer_to_a1 {
                flatbuffer.write_primitive(value)?;
            }
            flatbuffer.write_vtable_and_offset(&mut vtable[..vtable_len], size + 4)
        }
    }
}
