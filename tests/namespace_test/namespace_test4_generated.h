// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NAMESPACETEST4_NAMESPACEA_NAMESPACEB_H_
#define FLATBUFFERS_GENERATED_NAMESPACETEST4_NAMESPACEA_NAMESPACEB_H_

#include "flatbuffers/flatbuffers.h"


namespace NamespaceA {
namespace NamespaceB {

enum Color {
  Color_Purple = 0,
  Color_MIN = Color_Purple,
  Color_MAX = Color_Purple
};

inline const Color (&EnumValuesColor())[1] {
  static const Color values[] = {
    Color_Purple
  };
  return values;
}

inline const char * const *EnumNamesColor() {
  static const char * const names[2] = {
    "Purple",
    nullptr
  };
  return names;
}

inline const char *EnumNameColor(Color e) {
  if (flatbuffers::IsOutRange(e, Color_Purple, Color_Purple)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColor()[index];
}

inline const flatbuffers::TypeTable *ColorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    NamespaceA::NamespaceB::ColorTypeTable
  };
  static const char * const names[] = {
    "Purple"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 1, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace NamespaceB
}  // namespace NamespaceA

#endif  // FLATBUFFERS_GENERATED_NAMESPACETEST4_NAMESPACEA_NAMESPACEB_H_
