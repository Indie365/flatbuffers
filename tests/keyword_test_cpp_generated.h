// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_KEYWORDTESTCPP_NAMESPACE_H_
#define FLATBUFFERS_GENERATED_KEYWORDTESTCPP_NAMESPACE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

namespace namespace_ {

struct noexcept_;
struct noexcept_Builder;

struct delete_;
struct delete_Builder;

enum explicit_ : int32_t {
  explicit__void_ = 0,
  explicit__extern_ = 1,
  explicit__mutable_ = 2,
  explicit__MIN = explicit__void_,
  explicit__MAX = explicit__mutable_
};

inline const explicit_ (&EnumValuesexplicit_())[3] {
  static const explicit_ values[] = {
    explicit__void_,
    explicit__extern_,
    explicit__mutable_
  };
  return values;
}

inline const char * const *EnumNamesexplicit_() {
  static const char * const names[4] = {
    "void_",
    "extern_",
    "mutable_",
    nullptr
  };
  return names;
}

inline const char *EnumNameexplicit_(explicit_ e) {
  if (flatbuffers::IsOutRange(e, explicit__void_, explicit__mutable_)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesexplicit_()[index];
}

enum public_ : int32_t {
  public__NONE = 0,
  public__MIN = public__NONE,
  public__MAX = public__NONE
};

inline const public_ (&EnumValuespublic_())[1] {
  static const public_ values[] = {
    public__NONE
  };
  return values;
}

inline const char * const *EnumNamespublic_() {
  static const char * const names[2] = {
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNamepublic_(public_ e) {
  if (flatbuffers::IsOutRange(e, public__NONE, public__NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamespublic_()[index];
}

enum throw_ : uint8_t {
  throw__NONE = 0,
  throw__static_ = 1,
  throw__try_ = 2,
  throw__MIN = throw__NONE,
  throw__MAX = throw__try_
};

inline const throw_ (&EnumValuesthrow_())[3] {
  static const throw_ values[] = {
    throw__NONE,
    throw__static_,
    throw__try_
  };
  return values;
}

inline const char * const *EnumNamesthrow_() {
  static const char * const names[4] = {
    "NONE",
    "static_",
    "try_",
    nullptr
  };
  return names;
}

inline const char *EnumNamethrow_(throw_ e) {
  if (flatbuffers::IsOutRange(e, throw__NONE, throw__try_)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesthrow_()[index];
}

bool Verifythrow_(flatbuffers::Verifier &verifier, const void *obj, throw_ type);
bool Verifythrow_Vector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct noexcept_ FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef noexcept_Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SWITCH_ = 4,
    VT_PRIVATE_ = 6,
    VT_DEFAULT_ = 8,
    VT_FRIEND_ = 10
  };
  namespace_::explicit_ switch_() const {
    return static_cast<namespace_::explicit_>(GetField<int32_t>(VT_SWITCH_, 0));
  }
  namespace_::public_ private_() const {
    return static_cast<namespace_::public_>(GetField<int32_t>(VT_PRIVATE_, 0));
  }
  bool default_() const {
    return GetField<uint8_t>(VT_DEFAULT_, 0) != 0;
  }
  const flatbuffers::String *friend_() const {
    return GetPointer<const flatbuffers::String *>(VT_FRIEND_);
  }
  bool KeyCompareLessThan(const noexcept_ * const o) const {
    return *friend_() < *o->friend_();
  }
  int KeyCompareWithValue(const char *_friend_) const {
    return strcmp(friend_()->c_str(), _friend_);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SWITCH_, 4) &&
           VerifyField<int32_t>(verifier, VT_PRIVATE_, 4) &&
           VerifyField<uint8_t>(verifier, VT_DEFAULT_, 1) &&
           VerifyOffsetRequired(verifier, VT_FRIEND_) &&
           verifier.VerifyString(friend_()) &&
           verifier.EndTable();
  }
};

struct noexcept_Builder {
  typedef noexcept_ Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_switch_(namespace_::explicit_ switch_) {
    fbb_.AddElement<int32_t>(noexcept_::VT_SWITCH_, static_cast<int32_t>(switch_), 0);
  }
  void add_private_(namespace_::public_ private_) {
    fbb_.AddElement<int32_t>(noexcept_::VT_PRIVATE_, static_cast<int32_t>(private_), 0);
  }
  void add_default_(bool default_) {
    fbb_.AddElement<uint8_t>(noexcept_::VT_DEFAULT_, static_cast<uint8_t>(default_), 0);
  }
  void add_friend_(flatbuffers::Offset<flatbuffers::String> friend_) {
    fbb_.AddOffset(noexcept_::VT_FRIEND_, friend_);
  }
  explicit noexcept_Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<noexcept_> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<noexcept_>(end);
    fbb_.Required(o, noexcept_::VT_FRIEND_);
    return o;
  }
};

inline flatbuffers::Offset<noexcept_> Createnoexcept_(
    flatbuffers::FlatBufferBuilder &_fbb,
    namespace_::explicit_ switch_ = namespace_::explicit__void_,
    namespace_::public_ private_ = namespace_::public__NONE,
    bool default_ = false,
    flatbuffers::Offset<flatbuffers::String> friend_ = 0) {
  noexcept_Builder builder_(_fbb);
  builder_.add_friend_(friend_);
  builder_.add_private_(private_);
  builder_.add_switch_(switch_);
  builder_.add_default_(default_);
  return builder_.Finish();
}

inline flatbuffers::Offset<noexcept_> Createnoexcept_Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    namespace_::explicit_ switch_ = namespace_::explicit__void_,
    namespace_::public_ private_ = namespace_::public__NONE,
    bool default_ = false,
    const char *friend_ = nullptr) {
  auto friend___ = friend_ ? _fbb.CreateString(friend_) : 0;
  return namespace_::Createnoexcept_(
      _fbb,
      switch_,
      private_,
      default_,
      friend___);
}

struct delete_ FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef delete_Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSTEXPR_TYPE = 4,
    VT_CONSTEXPR_ = 6,
    VT_GOTO_ = 8,
    VT_DYNAMIC_CAST_ = 10,
    VT_INLINE_ = 12
  };
  namespace_::throw_ constexpr_type() const {
    return static_cast<namespace_::throw_>(GetField<uint8_t>(VT_CONSTEXPR_TYPE, 0));
  }
  const void *constexpr_() const {
    return GetPointer<const void *>(VT_CONSTEXPR_);
  }
  const namespace_::noexcept_ *constexpr__as_static_() const {
    return constexpr_type() == namespace_::throw__static_ ? static_cast<const namespace_::noexcept_ *>(constexpr_()) : nullptr;
  }
  const namespace_::noexcept_ *constexpr__as_try_() const {
    return constexpr_type() == namespace_::throw__try_ ? static_cast<const namespace_::noexcept_ *>(constexpr_()) : nullptr;
  }
  const flatbuffers::Vector<flatbuffers::Offset<namespace_::noexcept_>> *goto_() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<namespace_::noexcept_>> *>(VT_GOTO_);
  }
  int16_t dynamic_cast_() const {
    return GetField<int16_t>(VT_DYNAMIC_CAST_, 150);
  }
  bool KeyCompareLessThan(const delete_ * const o) const {
    return dynamic_cast_() < o->dynamic_cast_();
  }
  int KeyCompareWithValue(int16_t _dynamic_cast_) const {
    return static_cast<int>(dynamic_cast_() > _dynamic_cast_) - static_cast<int>(dynamic_cast_() < _dynamic_cast_);
  }
  const flatbuffers::Vector<double> *inline_() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_INLINE_);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CONSTEXPR_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONSTEXPR_) &&
           Verifythrow_(verifier, constexpr_(), constexpr_type()) &&
           VerifyOffset(verifier, VT_GOTO_) &&
           verifier.VerifyVector(goto_()) &&
           verifier.VerifyVectorOfTables(goto_()) &&
           VerifyField<int16_t>(verifier, VT_DYNAMIC_CAST_, 2) &&
           VerifyOffset(verifier, VT_INLINE_) &&
           verifier.VerifyVector(inline_()) &&
           verifier.EndTable();
  }
};

struct delete_Builder {
  typedef delete_ Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_constexpr_type(namespace_::throw_ constexpr_type) {
    fbb_.AddElement<uint8_t>(delete_::VT_CONSTEXPR_TYPE, static_cast<uint8_t>(constexpr_type), 0);
  }
  void add_constexpr_(flatbuffers::Offset<void> constexpr_) {
    fbb_.AddOffset(delete_::VT_CONSTEXPR_, constexpr_);
  }
  void add_goto_(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<namespace_::noexcept_>>> goto_) {
    fbb_.AddOffset(delete_::VT_GOTO_, goto_);
  }
  void add_dynamic_cast_(int16_t dynamic_cast_) {
    fbb_.AddElement<int16_t>(delete_::VT_DYNAMIC_CAST_, dynamic_cast_, 150);
  }
  void add_inline_(flatbuffers::Offset<flatbuffers::Vector<double>> inline_) {
    fbb_.AddOffset(delete_::VT_INLINE_, inline_);
  }
  explicit delete_Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<delete_> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<delete_>(end);
    return o;
  }
};

inline flatbuffers::Offset<delete_> Createdelete_(
    flatbuffers::FlatBufferBuilder &_fbb,
    namespace_::throw_ constexpr_type = namespace_::throw__NONE,
    flatbuffers::Offset<void> constexpr_ = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<namespace_::noexcept_>>> goto_ = 0,
    int16_t dynamic_cast_ = 150,
    flatbuffers::Offset<flatbuffers::Vector<double>> inline_ = 0) {
  delete_Builder builder_(_fbb);
  builder_.add_inline_(inline_);
  builder_.add_goto_(goto_);
  builder_.add_constexpr_(constexpr_);
  builder_.add_dynamic_cast_(dynamic_cast_);
  builder_.add_constexpr_type(constexpr_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<delete_> Createdelete_Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    namespace_::throw_ constexpr_type = namespace_::throw__NONE,
    flatbuffers::Offset<void> constexpr_ = 0,
    std::vector<flatbuffers::Offset<namespace_::noexcept_>> *goto_ = nullptr,
    int16_t dynamic_cast_ = 150,
    const std::vector<double> *inline_ = nullptr) {
  auto goto___ = goto_ ? _fbb.CreateVectorOfSortedTables<namespace_::noexcept_>(goto_) : 0;
  auto inline___ = inline_ ? _fbb.CreateVector<double>(*inline_) : 0;
  return namespace_::Createdelete_(
      _fbb,
      constexpr_type,
      constexpr_,
      goto___,
      dynamic_cast_,
      inline___);
}

inline bool Verifythrow_(flatbuffers::Verifier &verifier, const void *obj, throw_ type) {
  switch (type) {
    case throw__NONE: {
      return true;
    }
    case throw__static_: {
      auto ptr = reinterpret_cast<const namespace_::noexcept_ *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case throw__try_: {
      auto ptr = reinterpret_cast<const namespace_::noexcept_ *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool Verifythrow_Vector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!Verifythrow_(
        verifier,  values->Get(i), types->GetEnum<throw_>(i))) {
      return false;
    }
  }
  return true;
}

inline const namespace_::delete_ *Getdelete_(const void *buf) {
  return flatbuffers::GetRoot<namespace_::delete_>(buf);
}

inline const namespace_::delete_ *GetSizePrefixeddelete_(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<namespace_::delete_>(buf);
}

inline bool Verifydelete_Buffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<namespace_::delete_>(nullptr);
}

inline bool VerifySizePrefixeddelete_Buffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<namespace_::delete_>(nullptr);
}

inline void Finishdelete_Buffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<namespace_::delete_> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixeddelete_Buffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<namespace_::delete_> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace namespace_

#endif  // FLATBUFFERS_GENERATED_KEYWORDTESTCPP_NAMESPACE_H_
