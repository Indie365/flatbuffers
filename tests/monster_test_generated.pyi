from __future__ import annotations

import flatbuffers
import numpy as np

import typing
from flatbuffers import table

class Color(object):
  Red: int
  Green: int
  Blue: int
class Race(object):
  None_: int
  Human: int
  Dwarf: int
  Elf: int
class LongEnum(object):
  LongOne: int
  LongTwo: int
  LongBig: int
class Any(object):
  NONE: int
  Monster: int
  TestSimpleTableWithEnum: int
  MyGame_Example2_Monster: int
def AnyCreator(unionType: int, table: table.Table): ...
class AnyUniqueAliases(object):
  NONE: int
  M: int
  TS: int
  M2: int
def AnyUniqueAliasesCreator(unionType: int, table: table.Table): ...
class AnyAmbiguousAliases(object):
  NONE: int
  M1: int
  M2: int
  M3: int
def AnyAmbiguousAliasesCreator(unionType: int, table: table.Table): ...
class InParentNamespace(object):
  @classmethod
  def GetRootAs(cls, buf: bytes, offset: int) -> InParentNamespace: ...
  @classmethod
  def GetRootAsInParentNamespace(cls, buf: bytes, offset: int) -> InParentNamespace: ...
  @classmethod
  def InParentNamespaceBufferHasIdentifier(cls, buf: bytes, offset: int, size_prefixed: bool) -> bool: ...
  def Init(self, buf: bytes, pos: int) -> None: ...
class InParentNamespaceT(object):
  @classmethod
  def InitFromBuf(cls, buf: bytes, pos: int) -> InParentNamespaceT: ...
  @classmethod
  def InitFromPackedBuf(cls, buf: bytes, pos: int = 0) -> InParentNamespaceT: ...
  @classmethod
  def InitFromObj(cls, inParentNamespace: InParentNamespace) -> InParentNamespaceT: ...
  def _UnPack(self, inParentNamespace: InParentNamespace) -> None: ...
  def Pack(self, builder: flatbuffers.Builder) -> None: ...
class Monster(object):
  @classmethod
  def GetRootAs(cls, buf: bytes, offset: int) -> Monster: ...
  @classmethod
  def GetRootAsMonster(cls, buf: bytes, offset: int) -> Monster: ...
  @classmethod
  def MonsterBufferHasIdentifier(cls, buf: bytes, offset: int, size_prefixed: bool) -> bool: ...
  def Init(self, buf: bytes, pos: int) -> None: ...
class MonsterT(object):
  @classmethod
  def InitFromBuf(cls, buf: bytes, pos: int) -> MonsterT: ...
  @classmethod
  def InitFromPackedBuf(cls, buf: bytes, pos: int = 0) -> MonsterT: ...
  @classmethod
  def InitFromObj(cls, monster: Monster) -> MonsterT: ...
  def _UnPack(self, monster: Monster) -> None: ...
  def Pack(self, builder: flatbuffers.Builder) -> None: ...
class Test(object):
  @classmethod
  def SizeOf(cls) -> int: ...

  def Init(self, buf: bytes, pos: int) -> None: ...
  def A(self) -> int: ...
  def B(self) -> int: ...
class TestT(object):
  a: int
  b: int
  @classmethod
  def InitFromBuf(cls, buf: bytes, pos: int) -> TestT: ...
  @classmethod
  def InitFromPackedBuf(cls, buf: bytes, pos: int = 0) -> TestT: ...
  @classmethod
  def InitFromObj(cls, test: Test) -> TestT: ...
  def _UnPack(self, test: Test) -> None: ...
  def Pack(self, builder: flatbuffers.Builder) -> None: ...
class TestSimpleTableWithEnum(object):
  @classmethod
  def GetRootAs(cls, buf: bytes, offset: int) -> TestSimpleTableWithEnum: ...
  @classmethod
  def GetRootAsTestSimpleTableWithEnum(cls, buf: bytes, offset: int) -> TestSimpleTableWithEnum: ...
  @classmethod
  def TestSimpleTableWithEnumBufferHasIdentifier(cls, buf: bytes, offset: int, size_prefixed: bool) -> bool: ...
  def Init(self, buf: bytes, pos: int) -> None: ...
  def Color(self) -> int: ...
class TestSimpleTableWithEnumT(object):
  color: int
  @classmethod
  def InitFromBuf(cls, buf: bytes, pos: int) -> TestSimpleTableWithEnumT: ...
  @classmethod
  def InitFromPackedBuf(cls, buf: bytes, pos: int = 0) -> TestSimpleTableWithEnumT: ...
  @classmethod
  def InitFromObj(cls, testSimpleTableWithEnum: TestSimpleTableWithEnum) -> TestSimpleTableWithEnumT: ...
  def _UnPack(self, testSimpleTableWithEnum: TestSimpleTableWithEnum) -> None: ...
  def Pack(self, builder: flatbuffers.Builder) -> None: ...
class Vec3(object):
  @classmethod
  def SizeOf(cls) -> int: ...

  def Init(self, buf: bytes, pos: int) -> None: ...
  def X(self) -> float: ...
  def Y(self) -> float: ...
  def Z(self) -> float: ...
  def Test1(self) -> float: ...
  def Test2(self) -> int: ...
  def Test3(self, obj: Test) -> Test: ...
class Vec3T(object):
  x: float
  y: float
  z: float
  test1: float
  test2: int
  test3: typing.Optional[TestT]
  @classmethod
  def InitFromBuf(cls, buf: bytes, pos: int) -> Vec3T: ...
  @classmethod
  def InitFromPackedBuf(cls, buf: bytes, pos: int = 0) -> Vec3T: ...
  @classmethod
  def InitFromObj(cls, vec3: Vec3) -> Vec3T: ...
  def _UnPack(self, vec3: Vec3) -> None: ...
  def Pack(self, builder: flatbuffers.Builder) -> None: ...
class Ability(object):
  @classmethod
  def SizeOf(cls) -> int: ...

  def Init(self, buf: bytes, pos: int) -> None: ...
  def Id(self) -> int: ...
  def Distance(self) -> int: ...
class AbilityT(object):
  id: int
  distance: int
  @classmethod
  def InitFromBuf(cls, buf: bytes, pos: int) -> AbilityT: ...
  @classmethod
  def InitFromPackedBuf(cls, buf: bytes, pos: int = 0) -> AbilityT: ...
  @classmethod
  def InitFromObj(cls, ability: Ability) -> AbilityT: ...
  def _UnPack(self, ability: Ability) -> None: ...
  def Pack(self, builder: flatbuffers.Builder) -> None: ...
class StructOfStructs(object):
  @classmethod
  def SizeOf(cls) -> int: ...

  def Init(self, buf: bytes, pos: int) -> None: ...
  def A(self, obj: Ability) -> Ability: ...
  def B(self, obj: Test) -> Test: ...
  def C(self, obj: Ability) -> Ability: ...
class StructOfStructsT(object):
  a: typing.Optional[AbilityT]
  b: typing.Optional[TestT]
  c: typing.Optional[AbilityT]
  @classmethod
  def InitFromBuf(cls, buf: bytes, pos: int) -> StructOfStructsT: ...
  @classmethod
  def InitFromPackedBuf(cls, buf: bytes, pos: int = 0) -> StructOfStructsT: ...
  @classmethod
  def InitFromObj(cls, structOfStructs: StructOfStructs) -> StructOfStructsT: ...
  def _UnPack(self, structOfStructs: StructOfStructs) -> None: ...
  def Pack(self, builder: flatbuffers.Builder) -> None: ...
class StructOfStructsOfStructs(object):
  @classmethod
  def SizeOf(cls) -> int: ...

  def Init(self, buf: bytes, pos: int) -> None: ...
  def A(self, obj: StructOfStructs) -> StructOfStructs: ...
class StructOfStructsOfStructsT(object):
  a: typing.Optional[StructOfStructsT]
  @classmethod
  def InitFromBuf(cls, buf: bytes, pos: int) -> StructOfStructsOfStructsT: ...
  @classmethod
  def InitFromPackedBuf(cls, buf: bytes, pos: int = 0) -> StructOfStructsOfStructsT: ...
  @classmethod
  def InitFromObj(cls, structOfStructsOfStructs: StructOfStructsOfStructs) -> StructOfStructsOfStructsT: ...
  def _UnPack(self, structOfStructsOfStructs: StructOfStructsOfStructs) -> None: ...
  def Pack(self, builder: flatbuffers.Builder) -> None: ...
class Stat(object):
  @classmethod
  def GetRootAs(cls, buf: bytes, offset: int) -> Stat: ...
  @classmethod
  def GetRootAsStat(cls, buf: bytes, offset: int) -> Stat: ...
  @classmethod
  def StatBufferHasIdentifier(cls, buf: bytes, offset: int, size_prefixed: bool) -> bool: ...
  def Init(self, buf: bytes, pos: int) -> None: ...
  def Id(self) -> typing.Optional[str]: ...
  def Val(self) -> int: ...
  def Count(self) -> int: ...
class StatT(object):
  id: typing.Optional[str]
  val: int
  count: int
  @classmethod
  def InitFromBuf(cls, buf: bytes, pos: int) -> StatT: ...
  @classmethod
  def InitFromPackedBuf(cls, buf: bytes, pos: int = 0) -> StatT: ...
  @classmethod
  def InitFromObj(cls, stat: Stat) -> StatT: ...
  def _UnPack(self, stat: Stat) -> None: ...
  def Pack(self, builder: flatbuffers.Builder) -> None: ...
class Referrable(object):
  @classmethod
  def GetRootAs(cls, buf: bytes, offset: int) -> Referrable: ...
  @classmethod
  def GetRootAsReferrable(cls, buf: bytes, offset: int) -> Referrable: ...
  @classmethod
  def ReferrableBufferHasIdentifier(cls, buf: bytes, offset: int, size_prefixed: bool) -> bool: ...
  def Init(self, buf: bytes, pos: int) -> None: ...
  def Id(self) -> int: ...
class ReferrableT(object):
  id: int
  @classmethod
  def InitFromBuf(cls, buf: bytes, pos: int) -> ReferrableT: ...
  @classmethod
  def InitFromPackedBuf(cls, buf: bytes, pos: int = 0) -> ReferrableT: ...
  @classmethod
  def InitFromObj(cls, referrable: Referrable) -> ReferrableT: ...
  def _UnPack(self, referrable: Referrable) -> None: ...
  def Pack(self, builder: flatbuffers.Builder) -> None: ...
class Monster(object):
  @classmethod
  def GetRootAs(cls, buf: bytes, offset: int) -> Monster: ...
  @classmethod
  def GetRootAsMonster(cls, buf: bytes, offset: int) -> Monster: ...
  @classmethod
  def MonsterBufferHasIdentifier(cls, buf: bytes, offset: int, size_prefixed: bool) -> bool: ...
  def Init(self, buf: bytes, pos: int) -> None: ...
  def Pos(self) -> typing.Optional[Vec3]: ...
  def Mana(self) -> int: ...
  def Hp(self) -> int: ...
  def Name(self) -> typing.Optional[str]: ...
  def Inventory(self, i: int) -> int: ...
  def InventoryAsNumpy(self) -> np.ndarray: ...
  def InventoryLength(self) -> int: ...
  def InventoryIsNone(self) -> bool: ...
  def Color(self) -> int: ...
  def TestType(self) -> int: ...
  def Test(self) -> typing.Optional[table.Table]: ...
  def Test4(self, i: int) -> typing.Optional[Test]: ...
  def Test4Length(self) -> int: ...
  def Test4IsNone(self) -> bool: ...
  def Testarrayofstring(self, i: int) -> str: ...
  def TestarrayofstringLength(self) -> int: ...
  def TestarrayofstringIsNone(self) -> bool: ...
  def Testarrayoftables(self, i: int) -> typing.Optional[Monster]: ...
  def TestarrayoftablesLength(self) -> int: ...
  def TestarrayoftablesIsNone(self) -> bool: ...
  def Enemy(self) -> typing.Optional[Monster]: ...
  def Testnestedflatbuffer(self, i: int) -> int: ...
  def TestnestedflatbufferAsNumpy(self) -> np.ndarray: ...
  def TestnestedflatbufferNestedRoot(self) -> typing.Optional[Monster]: ...
  def TestnestedflatbufferLength(self) -> int: ...
  def TestnestedflatbufferIsNone(self) -> bool: ...
  def Testempty(self) -> typing.Optional[Stat]: ...
  def Testbool(self) -> bool: ...
  def Testhashs32Fnv1(self) -> int: ...
  def Testhashu32Fnv1(self) -> int: ...
  def Testhashs64Fnv1(self) -> int: ...
  def Testhashu64Fnv1(self) -> int: ...
  def Testhashs32Fnv1a(self) -> int: ...
  def Testhashu32Fnv1a(self) -> int: ...
  def Testhashs64Fnv1a(self) -> int: ...
  def Testhashu64Fnv1a(self) -> int: ...
  def Testarrayofbools(self, i: int) -> bool: ...
  def TestarrayofboolsAsNumpy(self) -> np.ndarray: ...
  def TestarrayofboolsLength(self) -> int: ...
  def TestarrayofboolsIsNone(self) -> bool: ...
  def Testf(self) -> float: ...
  def Testf2(self) -> float: ...
  def Testf3(self) -> float: ...
  def Testarrayofstring2(self, i: int) -> str: ...
  def Testarrayofstring2Length(self) -> int: ...
  def Testarrayofstring2IsNone(self) -> bool: ...
  def Testarrayofsortedstruct(self, i: int) -> typing.Optional[Ability]: ...
  def TestarrayofsortedstructLength(self) -> int: ...
  def TestarrayofsortedstructIsNone(self) -> bool: ...
  def Flex(self, i: int) -> int: ...
  def FlexAsNumpy(self) -> np.ndarray: ...
  def FlexLength(self) -> int: ...
  def FlexIsNone(self) -> bool: ...
  def Test5(self, i: int) -> typing.Optional[Test]: ...
  def Test5Length(self) -> int: ...
  def Test5IsNone(self) -> bool: ...
  def VectorOfLongs(self, i: int) -> int: ...
  def VectorOfLongsAsNumpy(self) -> np.ndarray: ...
  def VectorOfLongsLength(self) -> int: ...
  def VectorOfLongsIsNone(self) -> bool: ...
  def VectorOfDoubles(self, i: int) -> float: ...
  def VectorOfDoublesAsNumpy(self) -> np.ndarray: ...
  def VectorOfDoublesLength(self) -> int: ...
  def VectorOfDoublesIsNone(self) -> bool: ...
  def ParentNamespaceTest(self) -> typing.Optional[InParentNamespace]: ...
  def VectorOfReferrables(self, i: int) -> typing.Optional[Referrable]: ...
  def VectorOfReferrablesLength(self) -> int: ...
  def VectorOfReferrablesIsNone(self) -> bool: ...
  def SingleWeakReference(self) -> int: ...
  def VectorOfWeakReferences(self, i: int) -> int: ...
  def VectorOfWeakReferencesAsNumpy(self) -> np.ndarray: ...
  def VectorOfWeakReferencesLength(self) -> int: ...
  def VectorOfWeakReferencesIsNone(self) -> bool: ...
  def VectorOfStrongReferrables(self, i: int) -> typing.Optional[Referrable]: ...
  def VectorOfStrongReferrablesLength(self) -> int: ...
  def VectorOfStrongReferrablesIsNone(self) -> bool: ...
  def CoOwningReference(self) -> int: ...
  def VectorOfCoOwningReferences(self, i: int) -> int: ...
  def VectorOfCoOwningReferencesAsNumpy(self) -> np.ndarray: ...
  def VectorOfCoOwningReferencesLength(self) -> int: ...
  def VectorOfCoOwningReferencesIsNone(self) -> bool: ...
  def NonOwningReference(self) -> int: ...
  def VectorOfNonOwningReferences(self, i: int) -> int: ...
  def VectorOfNonOwningReferencesAsNumpy(self) -> np.ndarray: ...
  def VectorOfNonOwningReferencesLength(self) -> int: ...
  def VectorOfNonOwningReferencesIsNone(self) -> bool: ...
  def AnyUniqueType(self) -> int: ...
  def AnyUnique(self) -> typing.Optional[table.Table]: ...
  def AnyAmbiguousType(self) -> int: ...
  def AnyAmbiguous(self) -> typing.Optional[table.Table]: ...
  def VectorOfEnums(self, i: int) -> int: ...
  def VectorOfEnumsAsNumpy(self) -> np.ndarray: ...
  def VectorOfEnumsLength(self) -> int: ...
  def VectorOfEnumsIsNone(self) -> bool: ...
  def SignedEnum(self) -> int: ...
  def Testrequirednestedflatbuffer(self, i: int) -> int: ...
  def TestrequirednestedflatbufferAsNumpy(self) -> np.ndarray: ...
  def TestrequirednestedflatbufferNestedRoot(self) -> typing.Optional[Monster]: ...
  def TestrequirednestedflatbufferLength(self) -> int: ...
  def TestrequirednestedflatbufferIsNone(self) -> bool: ...
  def ScalarKeySortedTables(self, i: int) -> typing.Optional[Stat]: ...
  def ScalarKeySortedTablesLength(self) -> int: ...
  def ScalarKeySortedTablesIsNone(self) -> bool: ...
  def NativeInline(self) -> typing.Optional[Test]: ...
  def LongEnumNonEnumDefault(self) -> int: ...
  def LongEnumNormalDefault(self) -> int: ...
  def NanDefault(self) -> float: ...
  def InfDefault(self) -> float: ...
  def PositiveInfDefault(self) -> float: ...
  def InfinityDefault(self) -> float: ...
  def PositiveInfinityDefault(self) -> float: ...
  def NegativeInfDefault(self) -> float: ...
  def NegativeInfinityDefault(self) -> float: ...
  def DoubleInfDefault(self) -> float: ...
class MonsterT(object):
  pos: typing.Optional[Vec3T]
  mana: int
  hp: int
  name: typing.Optional[str]
  inventory: typing.List[int]
  color: int
  testType: int
  typing.Union[None, MonsterT, TestSimpleTableWithEnumT, MonsterT]
  test4: typing.List[TestT]
  testarrayofstring: typing.List[str]
  testarrayoftables: typing.List[MonsterT]
  enemy: typing.Optional[MonsterT]
  testnestedflatbuffer: typing.List[int]
  testempty: typing.Optional[StatT]
  testbool: bool
  testhashs32Fnv1: int
  testhashu32Fnv1: int
  testhashs64Fnv1: int
  testhashu64Fnv1: int
  testhashs32Fnv1a: int
  testhashu32Fnv1a: int
  testhashs64Fnv1a: int
  testhashu64Fnv1a: int
  testarrayofbools: typing.List[bool]
  testf: float
  testf2: float
  testf3: float
  testarrayofstring2: typing.List[str]
  testarrayofsortedstruct: typing.List[AbilityT]
  flex: typing.List[int]
  test5: typing.List[TestT]
  vectorOfLongs: typing.List[int]
  vectorOfDoubles: typing.List[float]
  parentNamespaceTest: typing.Optional[InParentNamespaceT]
  vectorOfReferrables: typing.List[ReferrableT]
  singleWeakReference: int
  vectorOfWeakReferences: typing.List[int]
  vectorOfStrongReferrables: typing.List[ReferrableT]
  coOwningReference: int
  vectorOfCoOwningReferences: typing.List[int]
  nonOwningReference: int
  vectorOfNonOwningReferences: typing.List[int]
  anyUniqueType: int
  typing.Union[None, MonsterT, TestSimpleTableWithEnumT, MonsterT]
  anyAmbiguousType: int
  typing.Union[None, MonsterT, MonsterT, MonsterT]
  vectorOfEnums: typing.List[int]
  signedEnum: int
  testrequirednestedflatbuffer: typing.List[int]
  scalarKeySortedTables: typing.List[StatT]
  nativeInline: typing.Optional[TestT]
  longEnumNonEnumDefault: int
  longEnumNormalDefault: int
  nanDefault: float
  infDefault: float
  positiveInfDefault: float
  infinityDefault: float
  positiveInfinityDefault: float
  negativeInfDefault: float
  negativeInfinityDefault: float
  doubleInfDefault: float
  @classmethod
  def InitFromBuf(cls, buf: bytes, pos: int) -> MonsterT: ...
  @classmethod
  def InitFromPackedBuf(cls, buf: bytes, pos: int = 0) -> MonsterT: ...
  @classmethod
  def InitFromObj(cls, monster: Monster) -> MonsterT: ...
  def _UnPack(self, monster: Monster) -> None: ...
  def Pack(self, builder: flatbuffers.Builder) -> None: ...
class TypeAliases(object):
  @classmethod
  def GetRootAs(cls, buf: bytes, offset: int) -> TypeAliases: ...
  @classmethod
  def GetRootAsTypeAliases(cls, buf: bytes, offset: int) -> TypeAliases: ...
  @classmethod
  def TypeAliasesBufferHasIdentifier(cls, buf: bytes, offset: int, size_prefixed: bool) -> bool: ...
  def Init(self, buf: bytes, pos: int) -> None: ...
  def I8(self) -> int: ...
  def U8(self) -> int: ...
  def I16(self) -> int: ...
  def U16(self) -> int: ...
  def I32(self) -> int: ...
  def U32(self) -> int: ...
  def I64(self) -> int: ...
  def U64(self) -> int: ...
  def F32(self) -> float: ...
  def F64(self) -> float: ...
  def V8(self, i: int) -> int: ...
  def V8AsNumpy(self) -> np.ndarray: ...
  def V8Length(self) -> int: ...
  def V8IsNone(self) -> bool: ...
  def Vf64(self, i: int) -> float: ...
  def Vf64AsNumpy(self) -> np.ndarray: ...
  def Vf64Length(self) -> int: ...
  def Vf64IsNone(self) -> bool: ...
class TypeAliasesT(object):
  i8: int
  u8: int
  i16: int
  u16: int
  i32: int
  u32: int
  i64: int
  u64: int
  f32: float
  f64: float
  v8: typing.List[int]
  vf64: typing.List[float]
  @classmethod
  def InitFromBuf(cls, buf: bytes, pos: int) -> TypeAliasesT: ...
  @classmethod
  def InitFromPackedBuf(cls, buf: bytes, pos: int = 0) -> TypeAliasesT: ...
  @classmethod
  def InitFromObj(cls, typeAliases: TypeAliases) -> TypeAliasesT: ...
  def _UnPack(self, typeAliases: TypeAliases) -> None: ...
  def Pack(self, builder: flatbuffers.Builder) -> None: ...

