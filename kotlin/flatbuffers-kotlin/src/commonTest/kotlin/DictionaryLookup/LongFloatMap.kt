// automatically generated by the FlatBuffers compiler, do not modify

package DictionaryLookup

import com.google.flatbuffers.kotlin.*
@Suppress("unused")
class LongFloatMap : Table() {

    fun init(i: Int, buffer: ReadWriteBuffer) : LongFloatMap = reset(i, buffer)
    fun assign(i: Int, buffer: ReadWriteBuffer) : LongFloatMap = init(i, buffer)

    fun entries(j: Int) : DictionaryLookup.LongFloatEntry? = entries(DictionaryLookup.LongFloatEntry(), j)
    fun entries(obj: DictionaryLookup.LongFloatEntry, j: Int) : DictionaryLookup.LongFloatEntry? = lookupField(4, null ) { obj.assign(indirect(vector(it) + j * 4), bb) }
    val entriesLength : Int get() = lookupField(4, 0 ) { vectorLength(it) }
    fun entriesByKey(key: Long) : DictionaryLookup.LongFloatEntry? = lookupField(4, null ) { DictionaryLookup.LongFloatEntry.lookupByKey(null, vector(it), key, bb) }
    fun entriesByKey(obj: DictionaryLookup.LongFloatEntry, key: Long) : DictionaryLookup.LongFloatEntry? = lookupField(4, null ) { DictionaryLookup.LongFloatEntry.lookupByKey(obj, vector(it), key, bb) }

    companion object {
        fun validateVersion() = VERSION_2_0_8

        fun asRoot(buffer: ReadWriteBuffer) : LongFloatMap = asRoot(buffer, LongFloatMap())
        fun asRoot(buffer: ReadWriteBuffer, obj: LongFloatMap) : LongFloatMap = obj.assign(buffer.getInt(buffer.limit) + buffer.limit, buffer)


        class LongFloatMapBuilder(val builder: FlatBufferBuilder) {

            var entries : ArrayOffset<DictionaryLookup.LongFloatEntry>
                get() = error("This methods should never be called")
                set(value) = addEntries(builder, value)
        }
        fun createLongFloatMap(builder: FlatBufferBuilder, lambda: LongFloatMapBuilder.() -> Unit = {}) : Offset<LongFloatMap> {
            val b = LongFloatMapBuilder(builder)
            startLongFloatMap(builder)
            b.apply(lambda)
            return endLongFloatMap(builder)
        }

        fun createLongFloatMap(builder: FlatBufferBuilder, entriesOffset: ArrayOffset<DictionaryLookup.LongFloatEntry>) : Offset<LongFloatMap> {
            builder.startTable(1)
            addEntries(builder, entriesOffset)
            return endLongFloatMap(builder)
        }
        fun startLongFloatMap(builder: FlatBufferBuilder) = builder.startTable(1)

        fun addEntries(builder: FlatBufferBuilder, entries: ArrayOffset<DictionaryLookup.LongFloatEntry>) = builder.addOffset(0, entries, null)

        fun createEntriesVector(builder: FlatBufferBuilder, data: Array<Offset<DictionaryLookup.LongFloatEntry>>) : ArrayOffset<DictionaryLookup.LongFloatEntry> {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }

        fun startEntriesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun endLongFloatMap(builder: FlatBufferBuilder) : Offset<LongFloatMap> {
            val o: Offset<LongFloatMap> = builder.endTable()
            return o
        }

        fun finishLongFloatMapBuffer(builder: FlatBufferBuilder, offset: Offset<LongFloatMap>) = builder.finish(offset)

        fun finishSizePrefixedLongFloatMapBuffer(builder: FlatBufferBuilder, offset: Offset<LongFloatMap>) = builder.finishSizePrefixed(offset)
    }
}
