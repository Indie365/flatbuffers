// automatically generated by the FlatBuffers compiler, do not modify

package MyGame.Example

import com.google.flatbuffers.kotlin.*
import kotlin.math.sign
/**
 * an example documentation comment: "monster object"
 */
@Suppress("unused")
class Monster : Table() {

    fun init(i: Int, buffer: ReadWriteBuffer) : Monster = reset(i, buffer)
    fun assign(i: Int, buffer: ReadWriteBuffer) : Monster = init(i, buffer)

    val pos : MyGame.Example.Vec3? get() = pos(MyGame.Example.Vec3())
    fun pos(obj: MyGame.Example.Vec3) : MyGame.Example.Vec3? = lookupField(4, null ) { obj.assign(it + bufferPos, bb) }

    val mana : Short get() = lookupField(6, 150 ) { bb.getShort(it + bufferPos) }

    val hp : Short get() = lookupField(8, 100 ) { bb.getShort(it + bufferPos) }

    val name : String? get() = lookupField(10, null ) { string(it + bufferPos) }
    fun nameAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 10, 1)

    fun inventory(j: Int) : UByte = lookupField(14, 0u ) { bb.get(vector(it) + j * 1).toUByte() }
    val inventoryLength : Int get() = lookupField(14, 0 ) { vectorLength(it) }
    fun inventoryAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 14, 1)

    val color : UByte get() = lookupField(16, 8u ) { bb.get(it + bufferPos).toUByte() }

    val testType : UByte get() = lookupField(18, 0u ) { bb.get(it + bufferPos).toUByte() }

    fun test(obj: Table) : Table? = lookupField(20, null ) { union(obj, it + bufferPos) }

    fun test4(j: Int) : MyGame.Example.Test? = test4(MyGame.Example.Test(), j)
    fun test4(obj: MyGame.Example.Test, j: Int) : MyGame.Example.Test? = lookupField(22, null ) { obj.assign(vector(it) + j * 4, bb) }
    val test4Length : Int get() = lookupField(22, 0 ) { vectorLength(it) }

    fun testarrayofstring(j: Int) : String? = lookupField(24, null ) { string(vector(it) + j * 4) }
    val testarrayofstringLength : Int get() = lookupField(24, 0 ) { vectorLength(it) }

    /**
     * an example documentation comment: this will end up in the generated code
     * multiline too
     */
    fun testarrayoftables(j: Int) : MyGame.Example.Monster? = testarrayoftables(MyGame.Example.Monster(), j)
    fun testarrayoftables(obj: MyGame.Example.Monster, j: Int) : MyGame.Example.Monster? = lookupField(26, null ) { obj.assign(indirect(vector(it) + j * 4), bb) }
    val testarrayoftablesLength : Int get() = lookupField(26, 0 ) { vectorLength(it) }
    fun testarrayoftablesByKey(key: String) : MyGame.Example.Monster? = lookupField(26, null ) { MyGame.Example.Monster.lookupByKey(null, vector(it), key, bb) }
    fun testarrayoftablesByKey(obj: MyGame.Example.Monster, key: String) : MyGame.Example.Monster? = lookupField(26, null ) { MyGame.Example.Monster.lookupByKey(obj, vector(it), key, bb) }

    val enemy : MyGame.Example.Monster? get() = enemy(MyGame.Example.Monster())
    fun enemy(obj: MyGame.Example.Monster) : MyGame.Example.Monster? = lookupField(28, null ) { obj.assign(indirect(it + bufferPos), bb) }

    fun testnestedflatbuffer(j: Int) : UByte = lookupField(30, 0u ) { bb.get(vector(it) + j * 1).toUByte() }
    val testnestedflatbufferLength : Int get() = lookupField(30, 0 ) { vectorLength(it) }
    fun testnestedflatbufferAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 30, 1)
    val testnestedflatbufferAsMonster : MyGame.Example.Monster? get() = testnestedflatbufferAsMonster(MyGame.Example.Monster())
    fun testnestedflatbufferAsMonster(obj: MyGame.Example.Monster) : MyGame.Example.Monster? = lookupField(30, null ) { obj.assign(indirect(vector(it)), bb) }

    val testempty : MyGame.Example.Stat? get() = testempty(MyGame.Example.Stat())
    fun testempty(obj: MyGame.Example.Stat) : MyGame.Example.Stat? = lookupField(32, null ) { obj.assign(indirect(it + bufferPos), bb) }

    val testbool : Boolean get() = lookupField(34, false ) { 0.toByte() != bb.get(it + bufferPos) }

    val testhashs32Fnv1 : Int get() = lookupField(36, 0 ) { bb.getInt(it + bufferPos) }

    val testhashu32Fnv1 : UInt get() = lookupField(38, 0u ) { bb.getInt(it + bufferPos).toUInt() }

    val testhashs64Fnv1 : Long get() = lookupField(40, 0L ) { bb.getLong(it + bufferPos) }

    val testhashu64Fnv1 : ULong get() = lookupField(42, 0UL ) { bb.getLong(it + bufferPos).toULong() }

    val testhashs32Fnv1a : Int get() = lookupField(44, 0 ) { bb.getInt(it + bufferPos) }

    val testhashu32Fnv1a : UInt get() = lookupField(46, 0u ) { bb.getInt(it + bufferPos).toUInt() }

    val testhashs64Fnv1a : Long get() = lookupField(48, 0L ) { bb.getLong(it + bufferPos) }

    val testhashu64Fnv1a : ULong get() = lookupField(50, 0UL ) { bb.getLong(it + bufferPos).toULong() }

    fun testarrayofbools(j: Int) : Boolean = lookupField(52, false ) { 0.toByte() != bb.get(vector(it) + j * 1) }
    val testarrayofboolsLength : Int get() = lookupField(52, 0 ) { vectorLength(it) }
    fun testarrayofboolsAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 52, 1)

    val testf : Float get() = lookupField(54, 3.14159f ) { bb.getFloat(it + bufferPos) }

    val testf2 : Float get() = lookupField(56, 3.0f ) { bb.getFloat(it + bufferPos) }

    val testf3 : Float get() = lookupField(58, 0.0f ) { bb.getFloat(it + bufferPos) }

    fun testarrayofstring2(j: Int) : String? = lookupField(60, null ) { string(vector(it) + j * 4) }
    val testarrayofstring2Length : Int get() = lookupField(60, 0 ) { vectorLength(it) }

    fun testarrayofsortedstruct(j: Int) : MyGame.Example.Ability? = testarrayofsortedstruct(MyGame.Example.Ability(), j)
    fun testarrayofsortedstruct(obj: MyGame.Example.Ability, j: Int) : MyGame.Example.Ability? = lookupField(62, null ) { obj.assign(vector(it) + j * 8, bb) }
    val testarrayofsortedstructLength : Int get() = lookupField(62, 0 ) { vectorLength(it) }

    fun flex(j: Int) : UByte = lookupField(64, 0u ) { bb.get(vector(it) + j * 1).toUByte() }
    val flexLength : Int get() = lookupField(64, 0 ) { vectorLength(it) }
    fun flexAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 64, 1)

    fun test5(j: Int) : MyGame.Example.Test? = test5(MyGame.Example.Test(), j)
    fun test5(obj: MyGame.Example.Test, j: Int) : MyGame.Example.Test? = lookupField(66, null ) { obj.assign(vector(it) + j * 4, bb) }
    val test5Length : Int get() = lookupField(66, 0 ) { vectorLength(it) }

    fun vectorOfLongs(j: Int) : Long = lookupField(68, 0 ) { bb.getLong(vector(it) + j * 8) }
    val vectorOfLongsLength : Int get() = lookupField(68, 0 ) { vectorLength(it) }
    fun vectorOfLongsAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 68, 8)

    fun vectorOfDoubles(j: Int) : Double = lookupField(70, 0.0 ) { bb.getDouble(vector(it) + j * 8) }
    val vectorOfDoublesLength : Int get() = lookupField(70, 0 ) { vectorLength(it) }
    fun vectorOfDoublesAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 70, 8)

    val parentNamespaceTest : MyGame.InParentNamespace? get() = parentNamespaceTest(MyGame.InParentNamespace())
    fun parentNamespaceTest(obj: MyGame.InParentNamespace) : MyGame.InParentNamespace? = lookupField(72, null ) { obj.assign(indirect(it + bufferPos), bb) }

    fun vectorOfReferrables(j: Int) : MyGame.Example.Referrable? = vectorOfReferrables(MyGame.Example.Referrable(), j)
    fun vectorOfReferrables(obj: MyGame.Example.Referrable, j: Int) : MyGame.Example.Referrable? = lookupField(74, null ) { obj.assign(indirect(vector(it) + j * 4), bb) }
    val vectorOfReferrablesLength : Int get() = lookupField(74, 0 ) { vectorLength(it) }
    fun vectorOfReferrablesByKey(key: ULong) : MyGame.Example.Referrable? = lookupField(74, null ) { MyGame.Example.Referrable.lookupByKey(null, vector(it), key, bb) }
    fun vectorOfReferrablesByKey(obj: MyGame.Example.Referrable, key: ULong) : MyGame.Example.Referrable? = lookupField(74, null ) { MyGame.Example.Referrable.lookupByKey(obj, vector(it), key, bb) }

    val singleWeakReference : ULong get() = lookupField(76, 0UL ) { bb.getLong(it + bufferPos).toULong() }

    fun vectorOfWeakReferences(j: Int) : ULong = lookupField(78, 0uL ) { bb.getLong(vector(it) + j * 8).toULong() }
    val vectorOfWeakReferencesLength : Int get() = lookupField(78, 0 ) { vectorLength(it) }
    fun vectorOfWeakReferencesAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 78, 8)

    fun vectorOfStrongReferrables(j: Int) : MyGame.Example.Referrable? = vectorOfStrongReferrables(MyGame.Example.Referrable(), j)
    fun vectorOfStrongReferrables(obj: MyGame.Example.Referrable, j: Int) : MyGame.Example.Referrable? = lookupField(80, null ) { obj.assign(indirect(vector(it) + j * 4), bb) }
    val vectorOfStrongReferrablesLength : Int get() = lookupField(80, 0 ) { vectorLength(it) }
    fun vectorOfStrongReferrablesByKey(key: ULong) : MyGame.Example.Referrable? = lookupField(80, null ) { MyGame.Example.Referrable.lookupByKey(null, vector(it), key, bb) }
    fun vectorOfStrongReferrablesByKey(obj: MyGame.Example.Referrable, key: ULong) : MyGame.Example.Referrable? = lookupField(80, null ) { MyGame.Example.Referrable.lookupByKey(obj, vector(it), key, bb) }

    val coOwningReference : ULong get() = lookupField(82, 0UL ) { bb.getLong(it + bufferPos).toULong() }

    fun vectorOfCoOwningReferences(j: Int) : ULong = lookupField(84, 0uL ) { bb.getLong(vector(it) + j * 8).toULong() }
    val vectorOfCoOwningReferencesLength : Int get() = lookupField(84, 0 ) { vectorLength(it) }
    fun vectorOfCoOwningReferencesAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 84, 8)

    val nonOwningReference : ULong get() = lookupField(86, 0UL ) { bb.getLong(it + bufferPos).toULong() }

    fun vectorOfNonOwningReferences(j: Int) : ULong = lookupField(88, 0uL ) { bb.getLong(vector(it) + j * 8).toULong() }
    val vectorOfNonOwningReferencesLength : Int get() = lookupField(88, 0 ) { vectorLength(it) }
    fun vectorOfNonOwningReferencesAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 88, 8)

    val anyUniqueType : UByte get() = lookupField(90, 0u ) { bb.get(it + bufferPos).toUByte() }

    fun anyUnique(obj: Table) : Table? = lookupField(92, null ) { union(obj, it + bufferPos) }

    val anyAmbiguousType : UByte get() = lookupField(94, 0u ) { bb.get(it + bufferPos).toUByte() }

    fun anyAmbiguous(obj: Table) : Table? = lookupField(96, null ) { union(obj, it + bufferPos) }

    fun vectorOfEnums(j: Int) : UByte = lookupField(98, 0u ) { bb.get(vector(it) + j * 1).toUByte() }
    val vectorOfEnumsLength : Int get() = lookupField(98, 0 ) { vectorLength(it) }
    fun vectorOfEnumsAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 98, 1)

    val signedEnum : Byte get() = lookupField(100, -1 ) { bb.get(it + bufferPos) }

    fun testrequirednestedflatbuffer(j: Int) : UByte = lookupField(102, 0u ) { bb.get(vector(it) + j * 1).toUByte() }
    val testrequirednestedflatbufferLength : Int get() = lookupField(102, 0 ) { vectorLength(it) }
    fun testrequirednestedflatbufferAsBuffer() : ReadBuffer = vectorAsBuffer(bb, 102, 1)
    val testrequirednestedflatbufferAsMonster : MyGame.Example.Monster? get() = testrequirednestedflatbufferAsMonster(MyGame.Example.Monster())
    fun testrequirednestedflatbufferAsMonster(obj: MyGame.Example.Monster) : MyGame.Example.Monster? = lookupField(102, null ) { obj.assign(indirect(vector(it)), bb) }

    fun scalarKeySortedTables(j: Int) : MyGame.Example.Stat? = scalarKeySortedTables(MyGame.Example.Stat(), j)
    fun scalarKeySortedTables(obj: MyGame.Example.Stat, j: Int) : MyGame.Example.Stat? = lookupField(104, null ) { obj.assign(indirect(vector(it) + j * 4), bb) }
    val scalarKeySortedTablesLength : Int get() = lookupField(104, 0 ) { vectorLength(it) }
    fun scalarKeySortedTablesByKey(key: UShort) : MyGame.Example.Stat? = lookupField(104, null ) { MyGame.Example.Stat.lookupByKey(null, vector(it), key, bb) }
    fun scalarKeySortedTablesByKey(obj: MyGame.Example.Stat, key: UShort) : MyGame.Example.Stat? = lookupField(104, null ) { MyGame.Example.Stat.lookupByKey(obj, vector(it), key, bb) }

    val nativeInline : MyGame.Example.Test? get() = nativeInline(MyGame.Example.Test())
    fun nativeInline(obj: MyGame.Example.Test) : MyGame.Example.Test? = lookupField(106, null ) { obj.assign(it + bufferPos, bb) }

    val longEnumNonEnumDefault : ULong get() = lookupField(108, 0UL ) { bb.getLong(it + bufferPos).toULong() }

    val longEnumNormalDefault : ULong get() = lookupField(110, 2UL ) { bb.getLong(it + bufferPos).toULong() }

    override fun keysCompare(o1: Int, o2: Int, buffer: ReadWriteBuffer) : Int {
         return compareStrings(offset(10, o1, buffer), offset(10, o2, buffer), buffer)
    }
    companion object {
        fun validateVersion() = VERSION_2_0_8

        fun asRoot(buffer: ReadWriteBuffer) : Monster = asRoot(buffer, Monster())
        fun asRoot(buffer: ReadWriteBuffer, obj: Monster) : Monster = obj.assign(buffer.getInt(buffer.limit) + buffer.limit, buffer)

        fun MonsterBufferHasIdentifier(buffer: ReadWriteBuffer) : Boolean = hasIdentifier(buffer, "MONS")

        fun startMonster(builder: FlatBufferBuilder) = builder.startTable(54)

        fun addPos(builder: FlatBufferBuilder, pos: Int) = builder.addStruct(0, pos, 0)

        fun addMana(builder: FlatBufferBuilder, mana: Short) = builder.addShort(1, mana, 150)

        fun addHp(builder: FlatBufferBuilder, hp: Short) = builder.addShort(2, hp, 100)

        fun addName(builder: FlatBufferBuilder, name: Int)  {
            builder.addOffset(name)
            builder.slot(3)
        }

        fun addInventory(builder: FlatBufferBuilder, inventory: Int) = builder.addOffset(5, inventory, 0)

        fun createInventoryVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }

        fun startInventoryVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)

        fun addColor(builder: FlatBufferBuilder, color: UByte) = builder.addByte(6, color.toByte(), 8)

        fun addTestType(builder: FlatBufferBuilder, testType: UByte) = builder.addByte(7, testType.toByte(), 0)

        fun addTest(builder: FlatBufferBuilder, test: Int) = builder.addOffset(8, test, 0)

        fun addTest4(builder: FlatBufferBuilder, test4: Int) = builder.addOffset(9, test4, 0)

        fun startTest4Vector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 2)

        fun addTestarrayofstring(builder: FlatBufferBuilder, testarrayofstring: Int) = builder.addOffset(10, testarrayofstring, 0)

        fun createTestarrayofstringVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }

        fun startTestarrayofstringVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun addTestarrayoftables(builder: FlatBufferBuilder, testarrayoftables: Int) = builder.addOffset(11, testarrayoftables, 0)

        fun createTestarrayoftablesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }

        fun startTestarrayoftablesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun addEnemy(builder: FlatBufferBuilder, enemy: Int) = builder.addOffset(12, enemy, 0)

        fun addTestnestedflatbuffer(builder: FlatBufferBuilder, testnestedflatbuffer: Int) = builder.addOffset(13, testnestedflatbuffer, 0)

        fun createTestnestedflatbufferVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }

        fun startTestnestedflatbufferVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)

        fun addTestempty(builder: FlatBufferBuilder, testempty: Int) = builder.addOffset(14, testempty, 0)

        fun addTestbool(builder: FlatBufferBuilder, testbool: Boolean) = builder.addBoolean(15, testbool, false)

        fun addTesthashs32Fnv1(builder: FlatBufferBuilder, testhashs32Fnv1: Int) = builder.addInt(16, testhashs32Fnv1, 0)

        fun addTesthashu32Fnv1(builder: FlatBufferBuilder, testhashu32Fnv1: UInt) = builder.addInt(17, testhashu32Fnv1.toInt(), 0)

        fun addTesthashs64Fnv1(builder: FlatBufferBuilder, testhashs64Fnv1: Long) = builder.addLong(18, testhashs64Fnv1, 0L)

        fun addTesthashu64Fnv1(builder: FlatBufferBuilder, testhashu64Fnv1: ULong) = builder.addLong(19, testhashu64Fnv1.toLong(), 0)

        fun addTesthashs32Fnv1a(builder: FlatBufferBuilder, testhashs32Fnv1a: Int) = builder.addInt(20, testhashs32Fnv1a, 0)

        fun addTesthashu32Fnv1a(builder: FlatBufferBuilder, testhashu32Fnv1a: UInt) = builder.addInt(21, testhashu32Fnv1a.toInt(), 0)

        fun addTesthashs64Fnv1a(builder: FlatBufferBuilder, testhashs64Fnv1a: Long) = builder.addLong(22, testhashs64Fnv1a, 0L)

        fun addTesthashu64Fnv1a(builder: FlatBufferBuilder, testhashu64Fnv1a: ULong) = builder.addLong(23, testhashu64Fnv1a.toLong(), 0)

        fun addTestarrayofbools(builder: FlatBufferBuilder, testarrayofbools: Int) = builder.addOffset(24, testarrayofbools, 0)

        fun createTestarrayofboolsVector(builder: FlatBufferBuilder, data: BooleanArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addBoolean(data[i])
            }
            return builder.endVector()
        }

        fun startTestarrayofboolsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)

        fun addTestf(builder: FlatBufferBuilder, testf: Float) = builder.addFloat(25, testf, 3.14159)

        fun addTestf2(builder: FlatBufferBuilder, testf2: Float) = builder.addFloat(26, testf2, 3.0)

        fun addTestf3(builder: FlatBufferBuilder, testf3: Float) = builder.addFloat(27, testf3, 0.0)

        fun addTestarrayofstring2(builder: FlatBufferBuilder, testarrayofstring2: Int) = builder.addOffset(28, testarrayofstring2, 0)

        fun createTestarrayofstring2Vector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }

        fun startTestarrayofstring2Vector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun addTestarrayofsortedstruct(builder: FlatBufferBuilder, testarrayofsortedstruct: Int) = builder.addOffset(29, testarrayofsortedstruct, 0)

        fun startTestarrayofsortedstructVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(8, numElems, 4)

        fun addFlex(builder: FlatBufferBuilder, flex: Int) = builder.addOffset(30, flex, 0)

        fun createFlexVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }

        fun startFlexVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)

        fun addTest5(builder: FlatBufferBuilder, test5: Int) = builder.addOffset(31, test5, 0)

        fun startTest5Vector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 2)

        fun addVectorOfLongs(builder: FlatBufferBuilder, vectorOfLongs: Int) = builder.addOffset(32, vectorOfLongs, 0)

        fun createVectorOfLongsVector(builder: FlatBufferBuilder, data: LongArray) : Int {
            builder.startVector(8, data.size, 8)
            for (i in data.size - 1 downTo 0) {
                builder.addLong(data[i])
            }
            return builder.endVector()
        }

        fun startVectorOfLongsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(8, numElems, 8)

        fun addVectorOfDoubles(builder: FlatBufferBuilder, vectorOfDoubles: Int) = builder.addOffset(33, vectorOfDoubles, 0)

        fun createVectorOfDoublesVector(builder: FlatBufferBuilder, data: DoubleArray) : Int {
            builder.startVector(8, data.size, 8)
            for (i in data.size - 1 downTo 0) {
                builder.addDouble(data[i])
            }
            return builder.endVector()
        }

        fun startVectorOfDoublesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(8, numElems, 8)

        fun addParentNamespaceTest(builder: FlatBufferBuilder, parentNamespaceTest: Int) = builder.addOffset(34, parentNamespaceTest, 0)

        fun addVectorOfReferrables(builder: FlatBufferBuilder, vectorOfReferrables: Int) = builder.addOffset(35, vectorOfReferrables, 0)

        fun createVectorOfReferrablesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }

        fun startVectorOfReferrablesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun addSingleWeakReference(builder: FlatBufferBuilder, singleWeakReference: ULong) = builder.addLong(36, singleWeakReference.toLong(), 0)

        fun addVectorOfWeakReferences(builder: FlatBufferBuilder, vectorOfWeakReferences: Int) = builder.addOffset(37, vectorOfWeakReferences, 0)

        fun createVectorOfWeakReferencesVector(builder: FlatBufferBuilder, data: ULongArray) : Int {
            builder.startVector(8, data.size, 8)
            for (i in data.size - 1 downTo 0) {
                builder.addLong(data[i].toLong())
            }
            return builder.endVector()
        }

        fun startVectorOfWeakReferencesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(8, numElems, 8)

        fun addVectorOfStrongReferrables(builder: FlatBufferBuilder, vectorOfStrongReferrables: Int) = builder.addOffset(38, vectorOfStrongReferrables, 0)

        fun createVectorOfStrongReferrablesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }

        fun startVectorOfStrongReferrablesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun addCoOwningReference(builder: FlatBufferBuilder, coOwningReference: ULong) = builder.addLong(39, coOwningReference.toLong(), 0)

        fun addVectorOfCoOwningReferences(builder: FlatBufferBuilder, vectorOfCoOwningReferences: Int) = builder.addOffset(40, vectorOfCoOwningReferences, 0)

        fun createVectorOfCoOwningReferencesVector(builder: FlatBufferBuilder, data: ULongArray) : Int {
            builder.startVector(8, data.size, 8)
            for (i in data.size - 1 downTo 0) {
                builder.addLong(data[i].toLong())
            }
            return builder.endVector()
        }

        fun startVectorOfCoOwningReferencesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(8, numElems, 8)

        fun addNonOwningReference(builder: FlatBufferBuilder, nonOwningReference: ULong) = builder.addLong(41, nonOwningReference.toLong(), 0)

        fun addVectorOfNonOwningReferences(builder: FlatBufferBuilder, vectorOfNonOwningReferences: Int) = builder.addOffset(42, vectorOfNonOwningReferences, 0)

        fun createVectorOfNonOwningReferencesVector(builder: FlatBufferBuilder, data: ULongArray) : Int {
            builder.startVector(8, data.size, 8)
            for (i in data.size - 1 downTo 0) {
                builder.addLong(data[i].toLong())
            }
            return builder.endVector()
        }

        fun startVectorOfNonOwningReferencesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(8, numElems, 8)

        fun addAnyUniqueType(builder: FlatBufferBuilder, anyUniqueType: UByte) = builder.addByte(43, anyUniqueType.toByte(), 0)

        fun addAnyUnique(builder: FlatBufferBuilder, anyUnique: Int) = builder.addOffset(44, anyUnique, 0)

        fun addAnyAmbiguousType(builder: FlatBufferBuilder, anyAmbiguousType: UByte) = builder.addByte(45, anyAmbiguousType.toByte(), 0)

        fun addAnyAmbiguous(builder: FlatBufferBuilder, anyAmbiguous: Int) = builder.addOffset(46, anyAmbiguous, 0)

        fun addVectorOfEnums(builder: FlatBufferBuilder, vectorOfEnums: Int) = builder.addOffset(47, vectorOfEnums, 0)

        fun createVectorOfEnumsVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }

        fun startVectorOfEnumsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)

        fun addSignedEnum(builder: FlatBufferBuilder, signedEnum: Byte) = builder.addByte(48, signedEnum, -1)

        fun addTestrequirednestedflatbuffer(builder: FlatBufferBuilder, testrequirednestedflatbuffer: Int) = builder.addOffset(49, testrequirednestedflatbuffer, 0)

        fun createTestrequirednestedflatbufferVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }

        fun startTestrequirednestedflatbufferVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)

        fun addScalarKeySortedTables(builder: FlatBufferBuilder, scalarKeySortedTables: Int) = builder.addOffset(50, scalarKeySortedTables, 0)

        fun createScalarKeySortedTablesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }

        fun startScalarKeySortedTablesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)

        fun addNativeInline(builder: FlatBufferBuilder, nativeInline: Int) = builder.addStruct(51, nativeInline, 0)

        fun addLongEnumNonEnumDefault(builder: FlatBufferBuilder, longEnumNonEnumDefault: ULong) = builder.addLong(52, longEnumNonEnumDefault.toLong(), 0)

        fun addLongEnumNormalDefault(builder: FlatBufferBuilder, longEnumNormalDefault: ULong) = builder.addLong(53, longEnumNormalDefault.toLong(), 2)

        fun endMonster(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
                builder.required(o, 10)
            return o
        }

        fun finishMonsterBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "MONS")

        fun finishSizePrefixedMonsterBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "MONS")

        fun lookupByKey(obj: Monster?, vectorLocation: Int, key: String, bb: ReadWriteBuffer) : Monster? {
            val byteKey = key.encodeToByteArray()
            var span = bb.getInt(vectorLocation - 4)
            var start = 0
            while (span != 0) {
                var middle = span / 2
                val tableOffset = indirect(vectorLocation + 4 * (start + middle), bb)
                val comp = compareStrings(offset(10, bb.capacity - tableOffset, bb), byteKey, bb)
                when {
                    comp > 0 -> span = middle
                    comp < 0 -> {
                        middle++
                        start += middle
                        span -= middle
                    }
                    else -> {
                        return (obj ?: Monster()).assign(tableOffset, bb)
                    }
                }
            }
            return null
        }
    }
}
